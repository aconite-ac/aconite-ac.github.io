<!DOCTYPE HTML>
<html lang="ja" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Theorem Proving in Lean 4 日本語訳</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme && theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar && sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title_page.html">Theorem Proving in Lean 4 日本語訳</a></li><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> イントロダクション</a></li><li class="chapter-item expanded "><a href="dependent_type_theory.html"><strong aria-hidden="true">2.</strong> 依存型理論</a></li><li class="chapter-item expanded "><a href="propositions_and_proofs.html"><strong aria-hidden="true">3.</strong> 命題と証明</a></li><li class="chapter-item expanded "><a href="quantifiers_and_equality.html"><strong aria-hidden="true">4.</strong> 量化子と等号</a></li><li class="chapter-item expanded "><a href="tactics.html"><strong aria-hidden="true">5.</strong> タクティク</a></li><li class="chapter-item expanded "><a href="interacting_with_lean.html"><strong aria-hidden="true">6.</strong> Leanとの対話</a></li><li class="chapter-item expanded "><a href="inductive_types.html"><strong aria-hidden="true">7.</strong> 帰納型</a></li><li class="chapter-item expanded "><a href="induction_and_recursion.html"><strong aria-hidden="true">8.</strong> 帰納と再帰</a></li><li class="chapter-item expanded "><a href="structures_and_records.html"><strong aria-hidden="true">9.</strong> 構造体とレコード</a></li><li class="chapter-item expanded "><a href="type_classes.html"><strong aria-hidden="true">10.</strong> 型クラス</a></li><li class="chapter-item expanded "><a href="conv.html"><strong aria-hidden="true">11.</strong> 変換タクティクモード</a></li><li class="chapter-item expanded "><a href="axioms_and_computation.html"><strong aria-hidden="true">12.</strong> 公理と計算</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Theorem Proving in Lean 4 日本語訳</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/aconite-ac/theorem_proving_in_lean4" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="theorem-proving-in-lean-4"><a class="header" href="#theorem-proving-in-lean-4">Theorem Proving in Lean 4</a></h1>
<p><em>by Jeremy Avigad, Leonardo de Moura, Soonho Kong and Sebastian Ullrich, with contributions from the Lean Community</em></p>
<p>このテキストは読者がLean 4を使うことを前提にしています。Lean 4をインストールするには、<a href="https://lean-lang.org/lean4/doc/">Lean 4 Manual</a>の節<a href="https://lean-lang.org/lean4/doc/quickstart.html">Quickstart</a>をご覧ください。このテキストの最初のバージョンはLean 2用に書かれました。Lean 3用のバージョンは<a href="https://leanprover.github.io/theorem_proving_in_lean/">こちら</a>で入手可能です。</p>
<h2 id="この翻訳について"><a class="header" href="#この翻訳について">この翻訳について</a></h2>
<p><em>translated by aconite</em>(2章～12章)<em>, Haruhisa Enomoto</em>(1章)</p>
<p>この翻訳は有志による<strong>非公式</strong>翻訳です。翻訳に際して、表現を大きく変えた箇所や、分かりやすさを期すため記述やコード例を追加した箇所があります。また、用語の訳が一般的でない可能性があります。誤りを含む可能性もあります。必要に応じて原文<a href="https://lean-lang.org/theorem_proving_in_lean4/">Theorem Proving in Lean 4</a> (<a href="https://github.com/leanprover/theorem_proving_in_lean4">GitHub</a>)もご覧ください。</p>
<p>原文のライセンスは<a href="https://github.com/leanprover/theorem_proving_in_lean4/blob/master/LICENSE">Apache License 2.0</a>であり、それに基づいて原文を翻訳・公開しています。</p>
<p>この翻訳のソースは<a href="https://github.com/aconite-ac/theorem_proving_in_lean4">GitHubリポジトリ</a>から入手可能です。また、ページ右上端のGitHubマークを押してGitHubリポジトリに移動することもできます。この翻訳の全ページとソースは<a href="LICENSE">Apache License 2.0</a>の下で公開されています。</p>
<p>誤字脱字、内容の誤りの指摘、フォークからのPull Request、フォークによる翻訳の改変等は歓迎いたします。基本的に、ご指摘は<a href="https://github.com/aconite-ac/theorem_proving_in_lean4/issues">GitHubリポジトリのIssues</a>で受け付けます。</p>
<p>翻訳に際して、機械翻訳サービス<a href="https://www.deepl.com/ja/translator">DeepL翻訳</a>を参考にしました。</p>
<h2 id="バージョン情報"><a class="header" href="#バージョン情報">バージョン情報</a></h2>
<p>この翻訳は原文のcommit <a href="https://github.com/leanprover/theorem_proving_in_lean4/tree/81b028359684646f2db48e3909ee81b4fad51dfb">81b028359684646f2db48e3909ee81b4fad51dfb</a> (Date: Fri Mar 1 14:54:59 2024 -0600)に基づいています。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-イントロダクション"><a class="header" href="#introduction-イントロダクション">Introduction (イントロダクション)</a></h1>
<h2 id="computers-and-theorem-proving-コンピュータと定理証明"><a class="header" href="#computers-and-theorem-proving-コンピュータと定理証明">Computers and Theorem Proving (コンピュータと定理証明)</a></h2>
<p><em>Formal verification</em>(形式検証)では、論理的・計算的手法を使って、厳密な数学用語で表現された主張を立証する。この主張には、通常の数学の定理の他にも、ハードウェアやソフトウェアの一部、 ネットワークプロトコル、機械的・ハイブリッドシステムがその仕様を満たしているという主張も含まれる。実際には、数学的主張の検証をすることと、システムの正しさを検証することの間には、明確な区別はない。というのも、形式検証では、ハードウェアやソフトウェアのシステムを数学的な言葉で記述する必要があり、その時点で、その正しさに関する主張を立証することは、定理証明の一形態となる。逆に、数学の定理の証明には長い計算が必要な場合があり、その場合、定理の真偽を検証するには、その計算が想定通りに実行されることを検証する必要がある。</p>
<p>数学的な主張を裏付けるための最も信頼性のある方法は証明を与えることであり、20世紀の論理学の発展により、従来の証明方法のすべてではないにせよ、そのほとんどが、いくつかの基礎的な体系における小さな公理と規則の集合に還元できることが明らかになった。この還元のもとで、コンピューターが主張の立証に役立つ方法は2つある: 1つは、そもそも証明を「発見」する手助けをすること、もう1つは証明とされるものが正しいかどうかを「検証」する手助けをすることである。</p>
<p><em>Automated theorem proving</em>(自動定理証明)は、この「発見」の側面に焦点を当てている。resolution theorem provers(導出原理に基づく証明器)、tableau theorem provers(タブロー定理証明器)、fast satisfiability solvers(高速充足可能性ソルバー)などは、命題論理や一階論理における公式の正しさを証明する手段を提供する。また、整数や実数に対する線形式や非線形式など、特定の言語や領域に対する探索手続きや決定手続きを提供するシステムもある。SMT(satisfiability modulo theories, 充足可能性モジュロ理論)のようなアーキテクチャは、領域一般的な探索手法と領域固有の手続きを組み合わせたものである。数式処理システムや高度な数学ソフトウェア・パッケージは、数学的計算を実行したり、数学的上界または下界を確立したり、数学的対象を見つけたりする手段を提供する。計算は証明と見なすこともでき、これらのシステムも数学的主張の立証に役立つ。</p>
<p>自動推論システムは、そのパワーと効率性を追求する結果、しばしば健全性の保証を犠牲にしている。このようなシステムにはバグがあることもあり、システムが導いた結果が正しいことを保証するのは難しい。対照的に、<em>interactive theorem proving</em>(対話型定理証明)は、定理証明の「検証」の側面に焦点を当て、全ての主張が適切な公理的基礎づけにおける証明によって保証されることを要求する。その基準は非常に高く、推論の全てのルールと計算の全てのステップは、それ以前の定義や定理に訴えることで正当化されなければならず、それら全ては最終的には基本的な公理や規則にまで遡る。実際、このようなシステムのほとんどは、他のシステムに伝達したり、独立にチェックしたりできる、完全に精緻化された「証明オブジェクト」を提供する。このような証明を構築するためには、通常ユーザーからの入力やインタラクションがより多く必要となるが、それによってより深く複雑な証明を得ることができる。</p>
<p><em>Lean Theorem Prover</em>(Lean定理証明器)は、これら対話型定理証明と自動定理証明との間のギャップを埋めることを目的としている。このために、ユーザーとのインタラクションと完全に明記された公理的証明の構築が可能であるフレームワークの内部で、自動化されたツールと方法が使えるようにする。そのゴールは、数学的推論と複雑なシステムについての推論の両方をサポートし、両方の領域における主張を検証することである。</p>
<p>Leanの基礎となる論理は計算的解釈を持ち、Leanはプログラミング言語とみなすこともできる。もっと言えば、Leanは厳密な意味論を持つプログラムを書くためのシステムであり、プログラムが計算する関数について推論を行うためのシステムである。Leanはまた、独自の<em>metaprogramming language</em>(メタプログラミング言語)として機能するメカニズムを持つ。つまり、Leanそのものを使って自動化を実装したり、Leanの機能を拡張したりすることができる。Leanのこのような側面は、無料のオンラインテキスト<a href="https://lean-lang.org/functional_programming_in_lean/">Functional Programming in Lean</a>で解説されるが、システムの計算的側面はここでも登場するだろう。</p>
<h2 id="about-lean-leanについて"><a class="header" href="#about-lean-leanについて">About Lean (Leanについて)</a></h2>
<p><em>Lean</em>プロジェクトは、2013年にMicrosoft Research RedmondのLeonardo de Mouraによって立ち上げられた、現在進行中の長期的な取り組みであり、自動化への潜在的可能性の多くは時間をかけて徐々に実現されるだろう。Leanは<a href="LICENSE">Apache License 2.0</a>の下でリリースされている。これは寛容なオープンソースライセンスであり、他の人がコードと数学ライブラリを自由に利用し、拡張することを許可している。</p>
<p>Leanをあなたのコンピュータにインストールするには、<a href="https://lean-lang.org/lean4/doc/quickstart.html">Quickstart</a>にある指示を参照するのがよいだろう。LeanのソースコードとLeanのビルド方法は、<a href="https://github.com/leanprover/lean4/">https://github.com/leanprover/lean4/</a>から入手できる。</p>
<p>このチュートリアルは、Lean 4として知られるLeanの現在のバージョンについて記述する。</p>
<h2 id="about-this-book-この本について"><a class="header" href="#about-this-book-この本について">About this Book (この本について)</a></h2>
<p>この本は、Leanで証明を記述し検証する方法を学ぶために意図されている。そのために必要な背景情報の多くは、Lean特有のものではない。まず最初に、Leanがベースにしている論理システムを学ぶ。これは<em>dependent type theory</em>(依存型理論)の一種で、通常の数学の定理のほとんどを証明するのに十分強力であり、またそれを自然な方法で行うのに十分な表現力を持っている。より具体的には、Leanは<em>Calculus of Constructions</em>として知られるシステムのうち、帰納型を持つものの一種に基づいている。Leanは依存型理論で数学的対象を定義し数学的主張を表現できるだけでなく、依存型理論を証明を書くための言語としても使用できる。</p>
<p>完全に詳述された公理的証明は非常に複雑であるため、定理証明の課題は、できるだけ多くの細部をコンピュータに埋めさせることである。<a href="./dependent_type_theory.html">2章 Dependent Type Theory (依存型理論)</a>では、これを行う様々な方法を学ぶことができる。例えば、項の書き換えや、項や式を自動的に単純化するLeanの自動化手法などである。同様に、<em>elaboration</em>や<em>type inference</em>(型推論)の方法も、柔軟な代数的推論をサポートするために使うことができる。</p>
<p>最後に、システムとのコミュニケーションに使用する言語や、複雑な理論やデータを管理するためにLeanが提供するメカニズムなど、Lean特有の機能について学ぶ。</p>
<p>本文中には、以下のようなLeanのコード例が見られる:</p>
<pre><code class="language-lean">theorem and_commutative (p q : Prop) : p ∧ q → q ∧ p :=
  fun hpq : p ∧ q =&gt;
  have hp : p := And.left hpq
  have hq : q := And.right hpq
  show q ∧ p from And.intro hq hp
</code></pre>
<p>(訳者注: 以下の文章は、文章中にあるようにVS Codeのコマンドを用いて翻訳元英語版を開いた際の話だと思われます。)
この本を<a href="https://code.visualstudio.com/">VS Code</a>の中で読んでいると、&quot;try it!&quot;というボタンが表示される。このボタンを押すと、コード例を正しくコンパイルするのに十分な周囲の非表示コードとともに、エディタにコード例がコピーされる。読者はコード例を自由に修正することができ、それに応じてLeanは読者が入力した結果をチェックし、継続的にフィードバックを提供する。この後の章を読み進めながら、自分でコード例を実行し、自分自身で書いたコードを試してみることをお勧めする。本書はVS Code上で「Lean 4: Open Documentation View」コマンドで開くことができる。</p>
<h2 id="acknowledgments-謝辞"><a class="header" href="#acknowledgments-謝辞">Acknowledgments (謝辞)</a></h2>
<p>This tutorial is an open access project maintained on Github. Many people have contributed to the effort, providing
corrections, suggestions, examples, and text. We are grateful to Ulrik Buchholz, Kevin Buzzard, Mario Carneiro, Nathan
Carter, Eduardo Cavazos, Amine Chaieb, Joe Corneli, William DeMeo, Marcus Klaas de Vries, Ben Dyer, Gabriel Ebner,
Anthony Hart, Simon Hudon, Sean Leather, Assia Mahboubi, Gihan Marasingha, Patrick Massot, Christopher John Mazey,
Sebastian Ullrich, Floris van Doorn, Daniel Velleman, Théo Zimmerman, Paul Chisholm, Chris Lovett, and Siddhartha Gadgil for their contributions.  Please see <a href="https://github.com/leanprover/">lean prover</a> and <a href="https://github.com/leanprover-community/">lean community</a> for an up to date list
of our amazing contributors.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dependent-type-theory-依存型理論"><a class="header" href="#dependent-type-theory-依存型理論">Dependent Type Theory (依存型理論)</a></h1>
<p>Dependent Type Theory(依存型理論)は強力で表現力の高い言語であり、複雑な数学的主張を表現したり、複雑なハードウェアやソフトウェアの仕様を記述したり、これら両方について自然で統一された方法で推論したりすることができる。Leanは<em>Calculus of Constructions</em>として知られる依存型理論の一種に基づいている。そして、Leanは「非累積的宇宙の可算無限階層」と「帰納型」を備えている。この章が終わるころには、これらが意味するところを理解できているだろう。</p>
<h2 id="simple-type-theory-単純型理論"><a class="header" href="#simple-type-theory-単純型理論">Simple Type Theory (単純型理論)</a></h2>
<p>「型理論」という名前は「全てのexpression(式 あるいは 項)はそれに関連した型を持つ」という事実に由来する。例えば、適切な文脈の下で項 <code>x + 0</code> は自然数型を持ち、項 <code>f</code> は自然数を受け取り自然数を返す関数型を持つ。正確な定義を述べると、Leanにおいて「自然数」とは「任意精度の符号なし整数」のことである。</p>
<p>Leanでは項を次のように宣言する。</p>
<pre><code class="language-lean">-- def &lt;項の名前(識別子)&gt; : &lt;項の型&gt; := &lt;項の定義式&gt;
def m : Nat := 1           -- `m` は自然数型を持つ
def b1 : Bool := true      -- `b1` はブール型を持つ
def b2 : Bool := false
</code></pre>
<p>項の型をチェックするには次のようにする。</p>
<pre><code class="language-lean"><span class="boring">def m : Nat := 1
</span><span class="boring">def b1 : Bool := true
</span><span class="boring">def b2 : Bool := false
</span>-- #check &lt;項&gt;
#check m                   -- output: Nat
#check b1 &amp;&amp; b2            -- `&amp;&amp;` は「かつ」 output: Bool
#check b1 || b2            -- `||` は「または」 output: Bool
</code></pre>
<p>項を評価する(項の値を計算する)には次のようにする。</p>
<pre><code class="language-lean"><span class="boring">def m : Nat := 1
</span><span class="boring">def b1 : Bool := true
</span><span class="boring">def b2 : Bool := false
</span>-- #eval &lt;項&gt;
#eval 5 * 4                -- 20
#eval m + 2                -- 3
#eval b1 &amp;&amp; b2             -- false
</code></pre>
<p><code>/-</code> と <code>-/</code> はコメントブロックを形成し、その中のテキストは無視される。同様に、<code>--</code> から行末までもコメントとみなされ、コメントは無視される。コメントブロックは入れ子にすることができる。そのため、多くのプログラミング言語と同じように、コードの塊を「コメントアウト」することができる。</p>
<p><code>def</code> キーワードは現在の作業環境で新しい名前付きの項を宣言(定義)する。上の例では、<code>def m : Nat := 1</code> は値が <code>1</code> である <code>Nat</code> 型の新しい項 <code>m</code> を定義している。<code>#check &lt;項の名前&gt;</code> コマンドはその項が持つ型を報告するようLeanに要求する。Leanでは、システムに情報を問い合わせる補助コマンドは基本的にハッシュ記号(<code>#</code>)から始まる。<code>#eval &lt;項の名前&gt;</code> コマンドはその項を評価するようLeanに要求する。いくつかの項を自分で宣言し、いくつかの項を自分で型チェックしてみてほしい。<code>def</code> を使って新しいオブジェクトを宣言することは、システム上で実験するための良い方法である。</p>
<p>Simple Type Theory(単純型理論)が強力なのは、他の型から新しい型を作ることができるからである。例えば、<code>a</code> と <code>b</code> が型なら、<code>a -&gt; b</code> は <code>a</code> から <code>b</code> への関数の型を表し、<code>a × b</code> は <code>a</code> の要素と <code>b</code> の要素からなるペアの型(<code>a</code> と <code>b</code> の直積型)を表す。ここで、<code>×</code> はUnicode記号であることに注意してほしい。LeanではUnicodeを使用する。Unicodeを適切に使用することで読みやすさを向上させることができる。また、全ての現代的なエディタはUnicodeをサポートしている。Leanの標準ライブラリでは、型を表すギリシャ文字や、<code>-&gt;</code> をよりコンパクトにしたUnicode記号 <code>→</code> をよく見かける。</p>
<p><code>→</code> や <code>×</code> などを使った例を掲載する。</p>
<pre><code class="language-lean">#check Nat → Nat                   -- `→` は &quot;\to&quot; あるいは &quot;\r&quot; と打つと入力できる
#check Nat -&gt; Nat                  -- `-&gt;` は `→` のASCII表記

#check Nat × Nat                   -- `×` は &quot;\times&quot; と打つと入力できる
#check Prod Nat Nat                -- `Prod Nat Nat` は `Nat × Nat` のASCII表記

#check Nat → Nat → Nat
#check Nat → (Nat → Nat)           -- これは1つ上と同じである。つまり、`→` は右結合的である
#check Nat × Nat → Nat
#check (Nat → Nat) → Nat           -- 関数を受け取る関数の型

#check Nat.succ                    -- Nat → Nat
#check (0, 1)                      -- Nat × Nat
#check Nat.add                     -- Nat → Nat → Nat

#check Nat.succ 2                  -- Nat
#check Nat.add 3                   -- Nat → Nat
#check Nat.add 5 2                 -- Nat
#check (5, 9).1                    -- Nat
#check (5, 9).2                    -- Nat

#eval Nat.succ 2                   -- 3
#eval Nat.add 5 2                  -- 7
#eval (5, 9).1                     -- 5
#eval (5, 9).2                     -- 9
#eval Nat.add (10, 7).1 (10, 7).2  -- 17
</code></pre>
<p>今一度、自分でいくつかの例を作り、これらのコマンドを試してほしい。</p>
<p>基本的な構文を見てみよう。Unicodeの矢印 <code>→</code> は <code>\to</code>、<code>\r</code>、<code>\-&gt;</code> と打つことで入力できる。ASCIIの代替記号 <code>-&gt;</code> も使用できる。したがって、<code>Nat -&gt; Nat</code> と <code>Nat → Nat</code> は同じ意味である。どちらの式も、入力として自然数を受け取り、出力として自然数を返す関数の型を表す。直積型を表すUnicode記号 <code>×</code> は <code>\times</code> と打つと入力できる。一般に、<code>α</code>、<code>β</code>、<code>γ</code> のような小文字のギリシャ文字を使って型を表す。これらは <code>\a</code>、<code>\b</code>、<code>\c</code> と打つと入力できる。</p>
<p>以下に上述した記号の入力方法をまとめる。</p>
<table><thead><tr><th style="text-align: center">入力</th><th style="text-align: center">記号</th></tr></thead><tbody>
<tr><td style="text-align: center">\to</td><td style="text-align: center">→</td></tr>
<tr><td style="text-align: center">\r</td><td style="text-align: center">→</td></tr>
<tr><td style="text-align: center">-&gt;</td><td style="text-align: center">→</td></tr>
<tr><td style="text-align: center">\times</td><td style="text-align: center">×</td></tr>
<tr><td style="text-align: center">\a</td><td style="text-align: center">α</td></tr>
<tr><td style="text-align: center">\b</td><td style="text-align: center">β</td></tr>
<tr><td style="text-align: center">\g</td><td style="text-align: center">γ</td></tr>
</tbody></table>
<p>上記の例について注意すべきことがさらにいくつかある。まず、項 <code>x</code> に対する関数 <code>f</code> の適用は <code>f x</code> と表記される(例: <code>Nat.succ 2</code>)。次に、型の記述において <code>→</code> は右結合的である。例えば、<code>Nat.add</code> の型は <code>Nat → Nat → Nat</code> であり、これは <code>Nat → (Nat → Nat)</code> と等価である。したがって、<code>Nat.add</code> を、自然数を受け取り「自然数を受け取り自然数を返す関数」を返す関数とみなすことができる。型理論においては、<code>Nat.add</code> を自然数のペアを入力として受け取り、自然数を出力として返す関数として表現するよりも、一般的にこちらの方が便利である。つまり、<code>Nat.add</code> の型を <code>Nat × Nat → Nat</code> とするよりも、<code>Nat → Nat → Nat</code> とする方が便利である。これにより、例えば <code>Nat.add</code> 関数を「部分適用」することができる。上記の例は <code>Nat.add 3</code> は <code>Nat → Nat</code> 型を持つことを示している。すなわち、<code>Nat.add 3</code> は2番目の引数 <code>n</code> を「待つ」関数を返す。したがって、<code>Nat.add 3</code> は <code>Nat.add 3 n</code> と書くのと等価である。</p>
<p><code>m : Nat</code> と <code>n : Nat</code> があれば、<code>(m, n)</code> は <code>Nat × Nat</code> 型を持つ <code>m</code> と <code>n</code> の順序対を表すことが分かっただろう。この記法は自然数のペアを作る方法を与えてくれる。逆に、<code>p : Nat × Nat</code> とすると、<code>p.1 : Nat</code>、<code>p.2 : Nat</code> となる。この記法を使うとペアの2つの成分を取り出すことができる。</p>
<h2 id="types-as-objects-項としての型"><a class="header" href="#types-as-objects-項としての型">Types as objects (項としての型)</a></h2>
<p>型そのもの(<code>Nat</code> や <code>Bool</code> など)も項であるとみなすことは、Leanの依存型理論が単純型理論を拡張するのに使う手法の1つである。そうみなすためには、<code>Nat</code> や <code>Bool</code> などの各型も型を持っていなければならない。</p>
<pre><code class="language-lean">#check Nat               -- Type
#check Bool              -- Type
#check Nat → Bool        -- Type
#check Nat × Bool        -- Type
#check Nat → Nat         -- ...
#check Nat × Nat → Nat
#check Nat → Nat → Nat
#check Nat → (Nat → Nat)
#check Nat → Nat → Bool
#check (Nat → Nat) → Nat
</code></pre>
<p>上の各式が <code>Type</code> 型の項であることがわかるだろう。型を表す新しい定数を宣言することもできる:</p>
<pre><code class="language-lean">def α : Type := Nat
def β : Type := Bool
def F : Type → Type := List
def G : Type → Type → Type := Prod

#check α        -- Type
#check F α      -- Type
#check F Nat    -- Type
#check G α      -- Type → Type
#check G α β    -- Type
#check G α Nat  -- Type
</code></pre>
<p>上の例が示すように、<code>Type → Type → Type</code> 型を持つ関数の例、すなわち直積 <code>Prod</code> はすでに見た:</p>
<pre><code class="language-lean">def α : Type := Nat
def β : Type := Bool

#check Prod α β       -- Type
#check α × β          -- Type

#check Prod Nat Nat   -- Type
#check Nat × Nat      -- Type
</code></pre>
<p>任意の型 <code>α</code> が与えられたとき、型 <code>List α</code> は型 <code>α</code> の項からなるリストの型を表す。</p>
<pre><code class="language-lean">def α : Type := Nat

#check List α    -- Type
#check List Nat  -- Type
</code></pre>
<p>Leanの全ての式(項)が型を持っていることを考えれば、「<code>Type</code> そのものはどのような型を持っているのか」と問うのは自然なことである。</p>
<pre><code class="language-lean">#check Type      -- Type 1
</code></pre>
<p>では <code>Type 1</code> の型を予想し、それから実際に <code>Type 1</code> の型をチェックしてみよう。</p>
<pre><code class="language-lean">#check Type 1
#check Type 2
#check Type 3
#check Type 4
</code></pre>
<p>予想は当たっただろうか。この実験において、我々は「Leanは型の無限階層の上に成り立っている」というLeanの型付けシステムの最も精緻な側面の一つに突き当たっている。</p>
<p><code>Type 0</code> は <code>Nat</code> のような「小さい」あるいは「普通の」型たちからなる宇宙だと思ってほしい。<code>Type 1</code> は <code>Type 0</code> を項にもつより大きい宇宙であり、<code>Type 2</code> は <code>Type 1</code> を項にもつより大きい宇宙である。この列に限りはない。つまり、任意の自然数 <code>n</code> に対して、型 <code>Type n</code> が存在する。<code>Type</code> とは <code>Type 0</code> の略称である:</p>
<pre><code class="language-lean">#check Type
#check Type 0
</code></pre>
<p>次の表は、今議論されていることを理解するのに役立つだろう。右方向に進むと「宇宙」がより大きいものへと変化し、下方向に進むと「度」と呼ばれるものが変化する。</p>
<table><thead><tr><th style="text-align: center"></th><th style="text-align: center"></th><th style="text-align: center"></th><th style="text-align: center"></th><th style="text-align: center"></th><th style="text-align: center"></th></tr></thead><tbody>
<tr><td style="text-align: center">sort</td><td style="text-align: center">Prop (Sort 0)</td><td style="text-align: center">Type (Sort 1)</td><td style="text-align: center">Type 1 (Sort 2)</td><td style="text-align: center">Type 2 (Sort 3)</td><td style="text-align: center">...</td></tr>
<tr><td style="text-align: center">type(型)</td><td style="text-align: center">True</td><td style="text-align: center">Bool</td><td style="text-align: center">Nat -&gt; Type</td><td style="text-align: center">Type -&gt; Type 1</td><td style="text-align: center">...</td></tr>
<tr><td style="text-align: center">term(項)</td><td style="text-align: center">trivial</td><td style="text-align: center">true</td><td style="text-align: center">fun n =&gt; Fin n</td><td style="text-align: center">fun (_ : Type) =&gt; Type</td><td style="text-align: center">...</td></tr>
</tbody></table>
<p>いくつかの演算子は型の宇宙に対して<em>polymorphic</em>(多相)である必要がある。例えば、<code>List α</code> は、<code>α</code> がどの型宇宙にいようと意味をなすべきである。多相な関数 <code>List</code> の型は次のように表記される:</p>
<pre><code class="language-lean">#check List    -- List.{u} (α : Type u) : Type u
</code></pre>
<p>ここで、<code>u</code> は宇宙レベルを表す変数である。コマンド <code>#check List</code> の出力は、<code>α</code> が型 <code>Type n</code> を持つなら、<code>List α</code> も <code>Type n</code> を持つことを表している。関数 <code>Prod</code> も多相である:</p>
<pre><code class="language-lean">#check Prod    -- Prod.{u, v} (α : Type u) (β : Type v) : Type (max u v)
</code></pre>
<p><code>universe</code> コマンドを使うと、明示的に宇宙変数を宣言することができる。宇宙変数を使うと多相な項を定義することができる:</p>
<pre><code class="language-lean">universe u
def F (α : Type u) : Type u := Prod α α       -- `Type u` に属する型 `α` を受け取ると、`α` と `α` の直積型を返す関数
#check F                                      -- Type u → Type u
</code></pre>
<p>次のように <code>{}</code> を用いて宇宙パラメータを指定することもできる。そうすれば <code>universe</code> コマンドの使用を回避できる。</p>
<pre><code class="language-lean">def F.{u} (α : Type u) : Type u := Prod α α

#check F    -- Type u → Type u
</code></pre>
<h2 id="function-abstraction-and-evaluation-関数抽象と評価"><a class="header" href="#function-abstraction-and-evaluation-関数抽象と評価">Function Abstraction and Evaluation (関数抽象と評価)</a></h2>
<p>Leanでは、キーワード <code>fun</code> (あるいは <code>λ</code>) を使うと、式から関数を作ることができる。</p>
<pre><code class="language-lean">-- 括弧は省略可能
-- fun (&lt;入力引数の名前&gt; : &lt;入力引数の型名&gt;) =&gt; &lt;関数の出力を定義する式&gt;
-- λ (&lt;入力引数の名前&gt; : &lt;入力引数の型名&gt;) =&gt; &lt;関数の出力を定義する式&gt;
#check fun (x : Nat) =&gt; x + 5   -- Nat → Nat
#check λ (x : Nat) =&gt; x + 5     -- `λ` と `fun` は同じ意味
#check fun x =&gt; x + 5           -- `x` は `Nat` 型だと推論される
#check λ x =&gt; x + 5             -- `x` は `Nat` 型だと推論される
</code></pre>
<p>要求されたパラメータを通すことにより、ラムダ関数を評価することができる。</p>
<pre><code class="language-lean">#eval (λ x : Nat =&gt; x + 5) 10    -- 15
</code></pre>
<p>もし入力引数 <code>x : α</code> があり、さらに式 <code>t : β</code> が作れるなら、式 <code>fun (x : α) =&gt; t</code> (<code>λ (x : α) =&gt; t</code>) は型 <code>α → β</code> を持つ。このように、「入力引数」と「出力を定義する式」を結びつけて新しい関数を作るプロセスは<em>lambda abstraction</em>(ラムダ抽象)として知られている。<code>fun (x : α) =&gt; t</code> は型 <code>α</code> から型 <code>β</code> への、任意の値 <code>x</code> を値 <code>t</code> に写す関数だと考えてほしい。</p>
<p>他のいくつかの例を挙げる:</p>
<pre><code class="language-lean">#check fun x : Nat =&gt; fun y : Bool =&gt; if not y then x + 1 else x + 2
#check fun (x : Nat) (y : Bool) =&gt; if not y then x + 1 else x + 2
#check fun x y =&gt; if not y then x + 1 else x + 2   -- Nat → Bool → Nat
</code></pre>
<p>Leanはこの3つの例を全く同じ式であると解釈する。最後の例では、入力の型が省略されているにも関わらず、<code>#check</code> コマンドは期待した型を返してくれている。これはLeanが式 <code>if not y then x + 1 else x + 2</code> から入力の型を推論したからである。</p>
<p>関数の操作の数学的に一般的な例は、ラムダ抽象を用いて記述することができる:</p>
<pre><code class="language-lean">def f (n : Nat) : String := toString n
def g (s : String) : Bool := s.length &gt; 0

#check fun x : Nat =&gt; x        -- Nat → Nat
#check fun x : Nat =&gt; true     -- Nat → Bool
#check fun x : Nat =&gt; g (f x)  -- Nat → Bool
#check fun x =&gt; g (f x)        -- Nat → Bool
</code></pre>
<p>これらの式の意味を考えてみよう。式 <code>fun x : Nat =&gt; x</code> は <code>Nat</code> 上の恒等関数を表す。式 <code>fun x : Nat =&gt; true</code> は常に <code>true</code> を返す定数関数を表す。式 <code>fun x : Nat =&gt; g (f x)</code> は <code>f</code> と <code>g</code> の合成を表す。一般的に、入力引数の型注釈を省略して、Leanに型を推論してもらうことができる。例えば、<code>fun x : Nat =&gt; g (f x)</code> の代わりに <code>fun x =&gt; g (f x)</code> と書くことができる。</p>
<p>入力引数として関数を与えることもできる:</p>
<pre><code class="language-lean">#check fun (g : String → Bool) (f : Nat → String) (x : Nat) =&gt; g (f x)
-- (String → Bool) → (Nat → String) → Nat → Bool
</code></pre>
<p>何なら型を入力引数として与えることもできる:</p>
<pre><code class="language-lean">#check fun (α β γ : Type) (g : β → γ) (f : α → β) (x : α) =&gt; g (f x)
</code></pre>
<p>例えば、最後の式は3つの型 <code>α</code>、<code>β</code>、<code>γ</code> と2つの関数 <code>g : β → γ</code> と <code>f : α → β</code> を受け取り、<code>g</code> と <code>f</code> の合成を返す。(この関数の型が意味をなすようにするには「依存積」の概念が必要になるが、それは後ほど説明される。)</p>
<p>ラムダ抽象の一般的な形式は <code>fun x : α =&gt; t</code> である。ここで、変数 <code>x</code> は<em>bounded variable</em>(束縛変数)と呼ばれる: この <code>x</code> は実際単なるプレースホルダーであり、その「スコープ」は式 <code>t</code> の中に限定され、<code>t</code> を超えて広く及ぶことはない。例えば、定数 <code>b</code> が既に宣言されていたとする。この後に項 <code>fun (b : β) (x : α) =&gt; b</code> を作ったとしても、その中の <code>b</code> は既存の定数 <code>b</code> には影響しない。ラムダ抽象内の束縛変数名はどのように変えてもいい。実際、項 <code>fun (b : β) (x : α) =&gt; b</code> と項 <code>fun (u : β) (z : α) =&gt; u</code> は全く同じ関数である。</p>
<p>束縛変数の名前を変えることで互いに同じだと分かる式たちのことを<em>alpha equivalent</em>(α-同値)と呼ぶ。そして、α-同値なものは「同じ」だとみなされる。Leanはα-同値を認識している。</p>
<p>項 <code>t : α → β</code> を 項 <code>s : α</code> に適用すると、項 <code>t s : β</code> が得られることに注意してほしい。型を入力として受け取るようにし、分かりやすさのため束縛変数をリネームすると、以前の例は次のように書き換えられる:</p>
<pre><code class="language-lean">#check (fun x : Nat =&gt; x) 1     -- Nat
#check (fun x : Nat =&gt; true) 1  -- Bool

def f (n : Nat) : String := toString n
def g (s : String) : Bool := s.length &gt; 0

#check
  (fun (α β γ : Type) (u : β → γ) (v : α → β) (x : α) =&gt; u (v x)) Nat String Bool g f 0
  -- Bool
</code></pre>
<p>期待通り、式 <code>(fun x : Nat =&gt; x) 1</code> は <code>Nat</code> 型を持つ。もっと詳しいことが言える: <code>1</code> に式 <code>(fun x : Nat =&gt; x)</code> を適用したら、値 <code>1</code> が出力されるべきである。そして、実際にそうである:</p>
<pre><code class="language-lean">def f (n : Nat) : String := toString n
def g (s : String) : Bool := s.length &gt; 0

#eval (fun x : Nat =&gt; x) 1     -- 1
#eval (fun x : Nat =&gt; true) 1  -- true
#eval (fun (α β γ : Type) (u : β → γ) (v : α → β) (x : α) =&gt; u (v x)) Nat String Bool g f 0  -- true
</code></pre>
<p>これらの項がどのように評価されているのかは後ほど学ぶ。今のところ、次の依存型理論の重要な特徴に注目してほしい: 全ての項が計算上の動作を持ち、またnormalization(正規化)の概念をサポートしている。原則として、同じ値に簡約される2つの項は<em>definitionally equal</em>であると呼ばれる。Leanの型チェッカーはdefinitionally equalである2つの項を「同じ」とみなす。Leanは2つの項の間の相等関係を認識しサポートするために最善を尽くす。</p>
<p>Leanは完全なプログラミング言語である。バイナリ実行ファイルを生成するコンパイラと、対話型のインタプリタがある。コマンド <code>#eval</code> で式を評価することができ、<code>#eval</code> は関数をテストする方法として好まれている。</p>
<h2 id="definitions-定義"><a class="header" href="#definitions-定義">Definitions (定義)</a></h2>
<p><code>def</code> キーワードは名前付きの新しい項を宣言する重要な方法を提供することを思い出してほしい。</p>
<pre><code class="language-lean">-- def &lt;関数の名前&gt; (&lt;入力引数の名前&gt; : &lt;入力引数の型&gt;) : &lt;出力の型&gt; := &lt;出力を定義する式&gt;

def double (x : Nat) : Nat :=
  x + x
</code></pre>
<p>他のプログラミング言語における関数の働きを知っていると、この定義の仕方がより馴染み深くなるかもしれない。<code>double</code> は <code>Nat</code> 型の入力パラメータ <code>x</code> を取り、呼び出すと <code>x + x</code> を出力する関数である。したがって、出力の型は <code>Nat</code> 型である。この関数は次のように使うことができる:</p>
<pre><code class="language-lean"><span class="boring">def double (x : Nat) : Nat :=
</span><span class="boring"> x + x
</span>#eval double 3    -- 6
</code></pre>
<p><code>def</code> を名前付きのラムダ抽象だと考えることもできる。次の例は直前の例と同じ結果を得る:</p>
<pre><code class="language-lean">def double : Nat → Nat :=
  fun x =&gt; x + x

#eval double 3    -- 6
</code></pre>
<p>型を推論するのに十分な情報があるなら、型宣言を省略することができる。型推論はLeanの重要な部分である:</p>
<pre><code class="language-lean">def double :=
  fun (x : Nat) =&gt; x + x
#eval double 3    -- 6
</code></pre>
<p>改めて、定義に用いる一般的な文法は次のように書ける。</p>
<pre><code>def foo : α := bar
</code></pre>
<p>ここで <code>α</code> は式 <code>bar</code> により定義される出力の型である。Leanは通常、型 <code>α</code> が何であるかを推論できるため、<code>α</code> を省略しても問題ないことが多い。しかし、<code>α</code> を明示的に書くことはしばしば良いことである。型の明示は書き手の意図を明確にする。そして、Leanは <code>bar</code> が持つ型と <code>α</code> が一致するかをチェックしてくれる。もし一致しなければ、Leanはエラーを返す。</p>
<p>右辺 <code>bar</code> はラムダ式に限らずどんな式でもよい。したがって、<code>def</code> は次のように単に値に名前を付けるために使ってもよい:</p>
<pre><code class="language-lean">def pi := 3.141592654
</code></pre>
<p><code>def</code> は複数の入力パラメータを受け取ることができる。2つの自然数を足し合わせる関数を作ってみよう:</p>
<pre><code class="language-lean">def add (x y : Nat) :=
  x + y

#eval add 3 2               -- 5
</code></pre>
<p>パラメータリストは2つ以上に分けて書くこともできる:</p>
<pre><code class="language-lean"><span class="boring">def double (x : Nat) : Nat :=
</span><span class="boring"> x + x
</span>def add (x : Nat) (y : Nat) :=
  x + y

#eval add (double 3) (7 + 9)  -- 22
</code></pre>
<p>最後の行では、<code>add</code> への第1引数を作るために <code>double</code> 関数を呼び出したことに注意してほしい。</p>
<p><code>def</code> の中では他の面白い式を使うこともできる:</p>
<pre><code class="language-lean">def greater (x y : Nat) :=
  if x &gt; y then x
  else y

#eval greater 7 6             -- 7
#eval greater 99 100          -- 100
#eval greater 5 5             -- 5
</code></pre>
<p><code>greater</code> 関数がどんな働きをするかはおそらく推測できるだろう。</p>
<p>入力として他の関数を受け取る関数を定義することもできる。次の定義 <code>doTwice</code> は第1引数として与えられた関数 <code>f</code> を2回呼び出し、<code>f</code> に第2引数 <code>x</code> を入力して得られた出力を再び <code>f</code> に入力し、そこから得られた出力を返す:</p>
<pre><code class="language-lean">def double :=
  fun (x : Nat) =&gt; x + x

def square :=
  fun (x : Nat) =&gt; x * x

def doTwice (f : Nat → Nat) (x : Nat) : Nat :=
  f (f x)

#eval doTwice double 2        -- 8
#eval doTwice square 3        -- 81
</code></pre>
<p>少し抽象的な例を見てみよう。次のように型を入力引数として指定することができる:</p>
<pre><code class="language-lean">def compose (α β γ : Type) (g : β → γ) (f : α → β) (x : α) : γ :=
  g (f x)
</code></pre>
<p><code>compose</code> は入力引数として任意の2つの関数 <code>g</code>、<code>f</code> を受け取る。ただし、<code>g</code> と <code>f</code> はともにただ1つの入力を受け取る関数でなければならない。さらに <code>g : β → γ</code> と <code>f : α → β</code> は、<code>f</code> の出力の型と <code>g</code> の入力の型が一致していなければならないという制約を意味する。<code>g</code> と <code>f</code> が以上の制約を満たすなら、<code>compose</code> は意味をなす。そうでなければ2つの関数は合成不可能である。</p>
<p><code>compose</code> は型 <code>α</code> を持つ第3引数 <code>x</code> をとる。<code>x</code> は <code>f</code> に入力され、<code>f</code> からの出力は <code>g</code> に入力される。<code>g</code> は型 <code>γ</code> の項を返す。したがって、<code>compose</code> 関数の返り値の型も <code>γ</code> である。</p>
<p><code>compose</code> は任意の型 <code>α β γ</code> について機能するという意味で非常に普遍的である。これは任意の2つの関数 <code>g f</code> がともにただ1つの入力を受け取り、<code>f</code> の出力の型と <code>g</code> の入力の型が一致しているならば、<code>compose</code> は <code>g</code> と <code>f</code> を合成できることを意味する。以下に例を挙げる:</p>
<pre><code class="language-lean">def double :=
  fun (x : Nat) =&gt; x + x

def square :=
  fun (x : Nat) =&gt; x * x

def compose (α β γ : Type) (g : β → γ) (f : α → β) (x : α) : γ :=
  g (f x)

#eval compose Nat Nat Nat double square 3        -- 18
#eval compose Nat Nat Nat square double 3        -- 36
</code></pre>
<h2 id="local-definitions-ローカルな定義"><a class="header" href="#local-definitions-ローカルな定義">Local Definitions (ローカルな定義)</a></h2>
<p>キーワード <code>let</code> を使うと「ローカルな」定義を導入することができる。式 <code>let a := t1; t2</code> は <code>t2</code> の中に現れる全ての <code>a</code> を <code>t1</code> で置き換えたものとdefinitionally equalである。</p>
<pre><code class="language-lean">#check let y := 2 + 2; y * y   -- Nat
#eval  let y := 2 + 2; y * y   -- 16

def double_square (x : Nat) : Nat :=
  let y := x + x; y * y

#eval double_square 2   -- 16
</code></pre>
<p><code>y * y</code> の中に現れる全ての <code>y</code> を <code>x + x</code> で置き換えることにより、<code>double_square x</code> は項 <code>(x + x) * (x + x)</code> とdefinitionally equalであることが分かる。<code>let</code> 文を繋げることで、複数のローカルな定義を組み合わせることもできる:</p>
<pre><code class="language-lean">#check let y := 2 + 2; let z := y + y; z * z   -- Nat
#eval  let y := 2 + 2; let z := y + y; z * z   -- 64
</code></pre>
<p>改行を挟めば <code>;</code> を省略することができる。</p>
<pre><code class="language-lean">def double_square (x : Nat) : Nat :=
  let y := x + x
  y * y
</code></pre>
<p>式 <code>let a := t1; t2</code> の意味は <code>(fun a =&gt; t2) t1</code> の意味と非常に似ているが、この2つは同じではないことに注意してほしい。<code>let a := t1; t2</code> において、<code>t2</code> の中に現れる <code>a</code> は <code>t1</code> の省略形だと考えるべきである。一方 <code>(fun a =&gt; t2) t1</code> では、<code>a</code> は変数である。したがって、<code>fun a =&gt; t2</code> は <code>a</code> の値に依存せずに意味をなさなければならない。<code>let</code> は強力な省略手法であり、<code>let a := t1; t2</code> とは表現できても <code>(fun a =&gt; t2) t1</code> とは表現できない式が存在する。練習問題として、次の例において、なぜ <code>foo</code> は型チェックをパスするが <code>bar</code> は型チェックをパスしないのかを理解してみよう。</p>
<pre><code class="language-lean">def foo := let a := Nat; fun x : a =&gt; x + 2
/-
  def bar := (fun a =&gt; fun x : a =&gt; x + 2) Nat
-/
</code></pre>
<h2 id="variables-and-sections-変数とセクション"><a class="header" href="#variables-and-sections-変数とセクション">Variables and Sections (変数とセクション)</a></h2>
<p>次の3つの関数の定義を考えてみよう:</p>
<pre><code class="language-lean">def compose (α β γ : Type) (g : β → γ) (f : α → β) (x : α) : γ :=
  g (f x)

def doTwice (α : Type) (h : α → α) (x : α) : α :=
  h (h x)

def doThrice (α : Type) (h : α → α) (x : α) : α :=
  h (h (h x))
  
#print compose
#print doTwice
#print doThrice
</code></pre>
<p>Leanでは、<code>variable</code> コマンドを使うとこのような定義をよりコンパクトにすることができる。<code>variable (&lt;変数の名前&gt; : &lt;変数の型名&gt;)</code> と書くと具体的な関数・定数定義と独立して変数名に型を付けることができる:</p>
<pre><code class="language-lean">variable (α β γ : Type)

def compose (g : β → γ) (f : α → β) (x : α) : γ :=
  g (f x)

def doTwice (h : α → α) (x : α) : α :=
  h (h x)

def doThrice (h : α → α) (x : α) : α :=
  h (h (h x))
  
#print compose
#print doTwice
#print doThrice
</code></pre>
<p><code>variable</code> を使うと、<code>Type</code> に限らない任意の型を変数に与えることができる:</p>
<pre><code class="language-lean">variable (α β γ : Type)
variable (g : β → γ) (f : α → β) (h : α → α)
variable (x : α)

def compose := g (f x)
def doTwice := h (h x)
def doThrice := h (h (h x))

#print compose
#print doTwice
#print doThrice
</code></pre>
<p><code>#print &lt;定義の名前&gt;</code> コマンドを使うと、指定した定義に関する情報が表示される。<code>#print</code> コマンドを使うと、上の3つの定義グループが同じ3つの関数を定義していることを確認することができる。</p>
<p><code>variable</code> コマンドは、このコマンドで宣言された変数を参照する定義に、該当変数を束縛変数(入力引数)として挿入するようLeanに指示する。Leanは賢いので、各定義の中でどの変数が明示的あるいは暗黙のうちに使われているかを特定することができる。例えば、Leanは <code>doTwice</code> の中で変数 <code>h</code> と <code>x</code> のみならず、<code>α</code> が使われていることを特定することができる。したがって、<code>α</code>、<code>β</code>、<code>γ</code>、<code>g</code>、<code>f</code>、<code>h</code>、<code>x</code> は指定した型を持つ固定された項であると考えて定義を書けば、後はLeanが自動的に定義を抽象化してくれるのである。</p>
<p>一度 <code>variable</code> を使って変数が宣言されれば、その変数は宣言されたところから現在のファイルの最後まで有効である。しかしながら、変数のスコープを制限した方が使いやすいときもある。変数のスコープを制限するために、Leanはキーワード <code>section</code> を提供する:</p>
<pre><code class="language-lean">section useful
  variable (α β γ : Type)
  variable (g : β → γ) (f : α → β) (h : α → α)
  variable (x : α)
  
  #check α              -- セクション内で変数 `α` は参照可能。
  
  def compose := g (f x)
  def doTwice := h (h x)
  def doThrice := h (h (h x))
end useful

#check compose          -- セクション内で定義された関数はセクション外でも参照可能。 
-- #check α             -- エラー。セクション外で変数 `α` は参照不可能。
</code></pre>
<p>例で示した通り、<code>variable</code> を用いてセクション内で宣言された変数は、セクション外ではもはや参照不可能である。</p>
<p>セクション内の行をインデントする必要はない。また、セクションに名前を付ける必要もない。つまり、無名の <code>section</code> と <code>end</code> を使うことができる。ただし、セクションに名前を付けた場合は、同じ名前を使ってセクションを閉じる必要がある。また、セクションは入れ子にすることができ、入れ子になったセクションを使うと段階的に新しい変数を宣言することができる。</p>
<h2 id="namespaces-名前空間"><a class="header" href="#namespaces-名前空間">Namespaces (名前空間)</a></h2>
<p>キーワード <code>namespace</code> を使うと、入れ子にできる階層的な名前空間を作ることができ、その中に定義を入れて定義をグループ化することができる:</p>
<pre><code class="language-lean">namespace Foo
  def a : Nat := 5
  def f (x : Nat) : Nat := x + 7

  def fa : Nat := f a
  def ffa : Nat := f (f a)

  #check a
  #check f
  #check fa
  #check ffa
  #check Foo.fa
end Foo

-- #check a  -- error
-- #check f  -- error
#check Foo.a
#check Foo.f
#check Foo.fa
#check Foo.ffa

open Foo

#check a
#check f
#check fa
#check Foo.fa
</code></pre>
<p>名前空間 <code>Foo</code> 内で宣言した全ての識別子(定義の名前)は、宣言時の名前の頭に &quot;<code>Foo.</code>&quot; を付けたフルネームを持つ。名前空間 <code>Foo</code> の中では、&quot;<code>Foo.</code>&quot; を省略した短い名前で識別子を参照することができる。しかし、名前空間 <code>Foo</code> の外では、&quot;<code>Foo.</code>&quot; を省略しないフルネームを使って識別子を参照しなければならない。セクションとは違い、名前空間には名前を付ける必要がある。Leanにおいて、ただ1つの無名の名前空間はルートレベルに存在する。これ以外に無名の名前空間の存在は許されない。</p>
<p><code>open &lt;名前空間名&gt;</code> コマンドを使うと、&quot;<code>&lt;名前空間名&gt;.</code>&quot; を省略した短い名前を使えるようになる。モジュール(外部ファイル)をインポートしたときは、短い名前を使うためにそのモジュールが含む名前空間を開きたくなるかもしれない。一方で、開きたい名前空間A内のある識別子 <code>A.bar</code> と他の名前空間B内の使用したい識別子 <code>B.bar</code> が衝突するときは、名前空間を開かず、そのような定義をフルネームで保護されたままにしておきたいと思うかもしれない。このように、名前空間は作業環境において名前を管理する方法を提供する。</p>
<p>例えば、Leanはリストに関する定義と定理を名前空間 <code>List</code> の中でグループ化している。</p>
<pre><code class="language-lean">#check List.nil
#check List.cons
#check List.map
</code></pre>
<p><code>open List</code> を使うと、これらの定義に短い名前でアクセスできるようになる:</p>
<pre><code class="language-lean">open List

#check nil
#check cons
#check map
</code></pre>
<p>セクションのように、名前空間は入れ子にすることができる:</p>
<pre><code class="language-lean">namespace Foo
  def a : Nat := 5
  def f (x : Nat) : Nat := x + 7

  def fa : Nat := f a

  namespace Bar
    def ffa : Nat := f (f a)

    #check fa
    #check ffa
  end Bar

  #check fa
  #check Bar.ffa
end Foo

#check Foo.fa
#check Foo.Bar.ffa

open Foo

#check fa
#check Bar.ffa
</code></pre>
<p><code>namespace &lt;名前空間名&gt;</code>を用いることで、名前空間は閉じた後再び開くことができる。インポート元の名前空間をインポート先で開くことさえできる。</p>
<pre><code class="language-lean">namespace Foo
  def a : Nat := 5
  def f (x : Nat) : Nat := x + 7

  def fa : Nat := f a
end Foo

#check Foo.a
#check Foo.f

namespace Foo
  def ffa : Nat := f (f a)
end Foo

#check Foo.ffa
</code></pre>
<p>閉じられた名前空間は、例え他のファイルの中であっても、再び開くことができる:</p>
<pre><code class="language-lean">namespace Foo
  def a : Nat := 5
  def f (x : Nat) : Nat := x + 7

  def fa : Nat := f a
end Foo

#check Foo.a
#check Foo.f

namespace Foo
  def ffa : Nat := f (f a)
end Foo
</code></pre>
<p>セクションと同様、入れ子になった名前空間は開かれた順に閉じられなければならない。名前空間とセクションは異なる役割を持つ: 名前空間はデータを整理し、セクションは定義に挿入される変数の宣言を整理する。セクションは <code>set_option</code> や <code>open</code> のようなコマンドのスコープを区切るのにも便利である。</p>
<p>しかしながら、多くの側面で <code>namespace ... end</code> ブロックは <code>section ... end</code> ブロックと同様に振る舞う。特に、名前空間内で <code>variable</code> コマンドを使った場合、そのスコープは名前空間内に限定される。同様に、名前空間内で <code>open</code> コマンドを使った場合、<code>open</code> コマンドの効果はその名前空間が閉じられたときに切れる。</p>
<h2 id="what-makes-dependent-type-theory-dependent-何が依存型理論を依存たらしめているのか"><a class="header" href="#what-makes-dependent-type-theory-dependent-何が依存型理論を依存たらしめているのか">What makes dependent type theory dependent? (何が依存型理論を依存たらしめているのか？)</a></h2>
<p>「型はパラメータ(引数)に依存することができる」、これが簡潔な説明である。既に良い例を見てきた: 型 <code>List α</code> は引数 <code>α</code> に依存し、この依存性こそが <code>List Nat</code> と <code>List Bool</code> を区別する。別の例として、型 <code>Vector α n</code> について考えてみよう。<code>Vector α n</code> は型 <code>α</code> の項からなる長さ <code>n</code> のベクトル(動的配列)の型である。この型は<strong>2つの</strong>パラメータ、ベクトルの要素の型 <code>α : Type</code> とベクトルの長さ <code>n : Nat</code> に依存する。</p>
<p>今、リストの先頭に新しい要素を挿入する関数 <code>cons</code> を作りたいとしよう。<code>cons</code> はどんな型を持つだろうか。このような関数は<strong>多相</strong>であってほしい: <code>cons</code> 関数は <code>Nat</code>、<code>Bool</code>、ひいては任意の型 <code>α</code> に対して同様に動作してほしい。これは、<code>cons</code> は最初の引数として型 <code>α</code> をとるべきであることを意味する。そうすれば、任意の型 <code>α</code> に対して、<code>cons α</code> は型 <code>α</code> の項からなるリスト <code>List α</code> のための挿入関数となる。さらに、挿入する要素 <code>a : α</code> と <code>a</code> が挿入されるリスト <code>as : List α</code> が引数として必要だろう。これらの引数があれば、<code>cons</code> は <code>a</code> を <code>as</code> の先頭に挿入した新しいリストを作り、出力することができる。したがって <code>cons α a as : List α</code> という形の定義が適切だと考えられる。</p>
<p><code>cons α</code> が型 <code>α → List α → List α</code> を持つべきなのは明らかである。それでは、型を与える前の <code>cons</code> はどんな型を持つべきだろうか。<code>cons</code> の持つ型として最初に思いつくのは <code>Type → α → List α → List α</code> だろう。しかしこれは意味をなさない: <code>α</code> は <code>Type</code> 型の引数を参照すべきだが、<code>Type → α → List α → List α</code> 内の <code>α</code> は何も参照しない。言い換えれば、<code>α</code> と <code>List α</code> の意味は型 <code>Type</code> の引数によって決まるが、<code>Type → α → List α → List α</code> は型 <code>Type</code> の引数に関する情報を持たない。つまり、<code>α</code> と <code>List α</code> は最初の引数 <code>α : Type</code> に依存しているのである。実際に <code>cons</code> の型を <code>#check</code> で確認してみよう。</p>
<pre><code class="language-lean">def cons (α : Type) (a : α) (as : List α) : List α :=
  List.cons a as

#check cons Nat        -- Nat → List Nat → List Nat
#check cons Bool       -- Bool → List Bool → List Bool
#check cons            -- (α : Type) → α → List α → List α
</code></pre>
<p>これは<em>dependent function type</em>(依存関数型 あるいは 依存積型 あるいは パイ(Π)型)あるいは<em>dependent arrow type</em>(依存矢印型)の一例である。<code>α : Type</code> と <code>β : α → Type</code> があるとき、<code>β</code> は <code>α</code> 上の型の族だと思ってほしい。つまり、項 <code>β : α → Type</code> を任意の <code>a : α</code> に <code>β a : Type</code> を割り当てる関数だと考えるのである。このとき、型 <code>(a : α) → β a</code> は任意の <code>a : α</code> に型 <code>β a</code> の項 <code>f a</code> を割り当てる関数 <code>f</code> の型を表す。言い換えると、関数 <code>f</code> によって返される値 <code>f a</code> の型 <code>β a</code> は入力 <code>a</code> に依存して変わる。<code>(a : α) → β a</code> という記法は、入力に依存して出力の型が変わるような関数の型を記述することができるのである。</p>
<p><code>(a : α) → β</code> という依存関数型の記法は、任意の式 <code>β</code> に対して、たとえ <code>β</code> が引数 <code>a : α</code> に依存して変わるときでも、意味をなすのである。これは <code>α → β</code> という単純関数型の記法は <code>β</code> が引数 <code>a : α</code> に依存して変わるときには意味をなさないことと対照的である。つまり、依存関数型は単純関数型より表現の幅が広い。<code>β</code> が <code>a</code> に依存しないときは、型 <code>(a : α) → β</code> と 型 <code>α → β</code> に違いはない。実際、依存型理論において、そしてLeanにおいて、<code>α → β</code> という記法は、<code>β</code> が <code>a : α</code> に依存しないときの <code>(a : α) → β</code> の略記に過ぎない。</p>
<p>リストの例に戻る。<code>#check</code> コマンドを使うと、以下の <code>List</code> に関する関数の型をチェックすることができる。
記号 <code>@</code>、それから括弧 <code>()</code> と波括弧 <code>{}</code> の違いについてはすぐ後で説明する。</p>
<pre><code class="language-lean">#check @List.cons    -- {α : Type u_1} → α → List α → List α
#check @List.nil     -- {α : Type u_1} → List α
#check @List.length  -- {α : Type u_1} → List α → Nat
#check @List.append  -- {α : Type u_1} → List α → List α → List α
</code></pre>
<p><code>β</code> が <code>α</code> に依存できるようにすることで依存関数型 <code>(a : α) → β a</code> が関数型 <code>α → β</code> を一般化するのと同様に、<em>dependent Cartesian product type</em>(依存直積型 あるいは 依存和型 あるいは シグマ型) <code>(a : α) × β a</code> は直積型 <code>α × β</code> を一般化する。依存直積型は <code>β</code> が <code>a</code> に依存することを可能にする。依存直積型はシグマ(Σ)型とも呼ばれ、<code>(a : α) × β a</code> は <code>Σ a : α, β a</code> とも書かれる。Leanにおいて、<code>⟨a, b⟩</code> あるいは <code>Sigma.mk a b</code> と書くと依存ペアを作ることができる。<code>⟨</code> は <code>\langle</code> または <code>\&lt;</code> と打つと入力でき、<code>⟩</code> は <code>\rangle</code> または <code>\&gt;</code> と打つと入力できる。</p>
<pre><code class="language-lean">universe u v

def f (α : Type u) (β : α → Type v) (a : α) (b : β a) : (a : α) × β a :=
  ⟨a, b⟩

def g (α : Type u) (β : α → Type v) (a : α) (b : β a) : Σ a : α, β a :=
  Sigma.mk a b

#print f
#print g

def h1 (x : Nat) : Nat :=
  (f Type (fun α =&gt; α) Nat x).2

#eval h1 5 -- 5

def h2 (x : Nat) : Nat :=
  (g Type (fun α =&gt; α) Nat x).2

#eval h2 5 -- 5

def i : Type :=                 -- iは ``Nat`` 型のこと
  (f Type (fun α =&gt; α) Nat 5).1

def test : i := 5 + 5

#eval test -- 10
</code></pre>
<p>上記の <code>f</code> と <code>g</code> は同じ関数である。</p>
<h2 id="implicit-arguments-暗黙の引数"><a class="header" href="#implicit-arguments-暗黙の引数">Implicit Arguments (暗黙の引数)</a></h2>
<p>次のようなリストの実装 <code>Lst</code> があるとする:</p>
<pre><code class="language-lean"><span class="boring">universe u
</span><span class="boring">def Lst (α : Type u) : Type u := List α
</span><span class="boring">def Lst.cons (α : Type u) (a : α) (as : Lst α) : Lst α := List.cons a as
</span><span class="boring">def Lst.nil (α : Type u) : Lst α := List.nil
</span><span class="boring">def Lst.append (α : Type u) (as bs : Lst α) : Lst α := List.append as bs
</span>#check Lst          -- Lst.{u} (α : Type u) : Type u
#check Lst.cons     -- Lst.cons.{u} (α : Type u) (a : α) (as : Lst α) : Lst α
#check Lst.nil      -- Lst.nil.{u} (α : Type u) : Lst α
#check Lst.append   -- Lst.append.{u} (α : Type u) (as bs : Lst α) : Lst α
</code></pre>
<p>このとき、次のように <code>Nat</code> の項からなるリストを作ることができる:</p>
<pre><code class="language-lean"><span class="boring">universe u
</span><span class="boring">def Lst (α : Type u) : Type u := List α
</span><span class="boring">def Lst.cons (α : Type u) (a : α) (as : Lst α) : Lst α := List.cons a as
</span><span class="boring">def Lst.nil (α : Type u) : Lst α := List.nil
</span><span class="boring">def Lst.append (α : Type u) (as bs : Lst α) : Lst α := List.append as bs
</span><span class="boring">#check Lst          -- Type u_1 → Type u_1
</span><span class="boring">#check Lst.cons     -- (α : Type u_1) → α → Lst α → Lst α
</span><span class="boring">#check Lst.nil      -- (α : Type u_1) → Lst α
</span><span class="boring">#check Lst.append   -- (α : Type u_1) → Lst α → Lst α → Lst α
</span>#check Lst.cons Nat 0 (Lst.nil Nat)      -- Lst Nat
#eval Lst.cons Nat 0 (Lst.nil Nat)       -- [0]

def as : Lst Nat := Lst.nil Nat
def bs : Lst Nat := Lst.cons Nat 5 (Lst.nil Nat)

#check Lst.append Nat as bs              -- Lst Nat
#eval Lst.append Nat as bs               -- [5]
</code></pre>
<p><code>Lst</code> とそのコンストラクタ <code>Lst.cons</code>、<code>Lst.nil</code>、<code>Lst.append</code> は型について多相であるため、これらを使うときは毎回型 <code>Nat</code> を引数として与えなければならない。しかし、この情報は冗長である。<code>Lst.cons Nat 5 (Lst.nil Nat)</code> について考えてみよう。第二引数が <code>5 : Nat</code> であることから、<code>α</code>　が <code>Nat</code> であることは容易に推論できる。同様に、<code>Lst.cons Nat 5 (Lst.nil Nat)</code> の <code>Lst.nil</code> の引数が <code>Nat</code> であることも、<code>Lst.cons</code> の引数の情報 <code>(as : Lst α)</code> と <code>α</code> が <code>Nat</code> であることを照らし合わせれば分かる。</p>
<p>言わば、たとえ <code>Lst.cons Nat 5 (Lst.nil Nat)</code> が虫に食われて <code>Lst.cons _ 5 (Lst.nil _)</code> となっていたとしても、各 <code>_</code> に入る型が何であるか推論できるのである。</p>
<p>これは依存型理論の中心的な特徴である: 項は多くの情報を持つ。そしていくつかの失われた情報は文脈から推論できる。Leanでは、アンダースコア <code>_</code> を使うことで、ここの情報を自動で埋めてほしいとシステムに指示することができる。これは「implicit argument(暗黙の引数)」と呼ばれている。次に例を挙げる:</p>
<pre><code class="language-lean"><span class="boring">universe u
</span><span class="boring">def Lst (α : Type u) : Type u := List α
</span><span class="boring">def Lst.cons (α : Type u) (a : α) (as : Lst α) : Lst α := List.cons a as
</span><span class="boring">def Lst.nil (α : Type u) : Lst α := List.nil
</span><span class="boring">def Lst.append (α : Type u) (as bs : Lst α) : Lst α := List.append as bs
</span><span class="boring">#check Lst          -- Type u_1 → Type u_1
</span><span class="boring">#check Lst.cons     -- (α : Type u_1) → α → Lst α → Lst α
</span><span class="boring">#check Lst.nil      -- (α : Type u_1) → Lst α
</span><span class="boring">#check Lst.append   -- (α : Type u_1) → Lst α → Lst α → Lst α
</span>#check Lst.cons _ 0 (Lst.nil _)      -- Lst Nat

def as : Lst Nat := Lst.nil _
def bs : Lst Nat := Lst.cons _ 5 (Lst.nil _)

#check Lst.append _ as bs            -- Lst Nat
</code></pre>
<p>見事に推論に成功している。</p>
<p>しかし、アンダースコアをいちいち入力するのはやはり面倒である。関数が一般的に文脈から推論できる引数をとる場合、「この引数は(デフォルトでは)暗黙のうちに推論してほしい引数である」とLeanに指示することができる。次のように波括弧 <code>{}</code> で引数をくくると、その引数を暗黙の引数とすることができる:</p>
<pre><code class="language-lean">universe u
def Lst (α : Type u) : Type u := List α

def Lst.cons {α : Type u} (a : α) (as : Lst α) : Lst α := List.cons a as
def Lst.nil {α : Type u} : Lst α := List.nil
def Lst.append {α : Type u} (as bs : Lst α) : Lst α := List.append as bs

#check Lst.cons 0 Lst.nil      -- Lst Nat

def as : Lst Nat := Lst.nil
def bs : Lst Nat := Lst.cons 5 Lst.nil

#check Lst.append as bs        -- Lst Nat
</code></pre>
<p>変わったのは、関数の定義において <code>α : Type u</code> を波括弧で囲んだことだけである。他の例も挙げる:</p>
<pre><code class="language-lean">universe u
def ident {α : Type u} (x : α) := x

#check ident         -- ?m → ?m
#check ident 1       -- Nat
#check ident &quot;hello&quot; -- String
#check @ident        -- {α : Type u_1} → α → α
</code></pre>
<p>この例では、関数 <code>ident</code> の第1引数が暗黙の引数になっている。こうすることで、型の指定が隠され、見かけ上 <code>ident</code> が任意の型の引数を取るように見える。実際、<code>ident</code> と同じ機能を持つ関数 <code>id</code> は標準ライブラリ内でこのように定義されている。今回は、名前の衝突を避けるため、伝統的でない名前 <code>ident</code> を用いた。</p>
<p><code>variable</code> コマンドを使ったときも、変数を暗黙の引数として指定することができる。</p>
<pre><code class="language-lean">universe u

section
  variable {α : Type u}
  variable (x : α)
  def ident := x
end

#check ident           -- {α : Type u_1} → α → α
#check ident 4         -- Nat
#check ident &quot;hello&quot;   -- String
</code></pre>
<p>この <code>ident</code> の定義は一つ上の定義と同じ効果を持つ。</p>
<p>Leanには暗黙の引数を推論するための非常に複雑なメカニズムがあり、それを使うと関数型や述語、さらには証明を推論できることを見ていく。このような「穴」または「プレースホルダー」を埋めるプロセスは、<em>elaboration</em>としてよく知られている。暗黙の引数の存在により、ある式の意味を正確に確定させるための情報が不十分である状況が起こりうる。<code>id</code> や <code>List.nil</code> のような表現は、文脈によって異なる意味を持つことがあるため、<em>polymorphic</em>(多相的)であると言われる。</p>
<p>式 <code>e</code> の型 <code>T</code> は、<code>(e : T)</code> と書くことで指定できる。これはLeanのelaboratorに、暗黙の引数の解決を試みるとき、<code>e</code> の型として <code>T</code> を使うように指示する。以下の4行目と5行目では、<code>id</code> と <code>List.nil</code> の型を思い通りに指定するために、このメカニズムが使われている:</p>
<pre><code class="language-lean">#check List.nil               -- List ?m
#check id                     -- ?m → ?m

#check (List.nil : List Nat)  -- List Nat
#check (id : Nat → Nat)       -- Nat → Nat
</code></pre>
<p>Leanでは数字はオーバーロードされる。しかし数字の型が推論できない場合、Leanはデフォルトでその数字の型は自然数であると仮定する。次の例の1行目にはその機能の実例が示されている。3行目では数字の型が指定されているため、1行目と2行目とは異なり <code>2</code> の型が <code>Int</code> であると推論されている。</p>
<pre><code class="language-lean">#check 2            -- Nat
#check (2 : Nat)    -- Nat
#check (2 : Int)    -- Int
</code></pre>
<p>しかし、ある関数の引数を暗黙の引数として宣言しておきながら、その引数を明示的に与えたいという状況に陥ることがある。<code>foo</code> がそのような関数である場合、<code>@foo</code> という表記は、すべての引数を明示的にした同じ関数を表す。</p>
<pre><code class="language-lean">#check @id        -- {α : Sort u_1} → α → α
#check @id Nat    -- Nat → Nat
#check @id Bool   -- Bool → Bool

#check @id Nat 1     -- Nat
#check @id Bool true -- Bool
</code></pre>
<p>最初の <code>#check</code> コマンドは、何のプレースホルダーも与えていない状態での恒等関数 <code>id</code> そのものの型を表していることに注意してほしい。さらに、<code>#check</code> コマンドの表示は、第1引数が暗黙の引数であること波括弧を用いて示している。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="propositions-and-proofs-命題と証明"><a class="header" href="#propositions-and-proofs-命題と証明">Propositions and Proofs (命題と証明)</a></h1>
<p>第2章で、Leanにおいて項と関数を定義する方法を見てきた。この章では、依存型理論の言語を用いて数学的な主張と証明を書く方法を学ぶ。</p>
<h2 id="propositions-as-types-型としての命題"><a class="header" href="#propositions-as-types-型としての命題">Propositions as Types (型としての命題)</a></h2>
<p>依存型理論の言語で定義された項に関する命題を証明するための戦略の一つは、定義に用いる言語の上に命題に用いる言語と証明に用いる言語を重ねることである。しかし、複数の言語を使う必要はない。
依存型理論は、命題と証明を同じ一般的な枠組みで表現するのに十分な柔軟さと表現力を兼ね備えている。</p>
<p>例えば、命題を表す新しい型 <code>Prop</code> を導入することができる。さらに、他の命題から新しい命題を構築するコンストラクタを導入することができる。</p>
<pre><code class="language-lean"><span class="boring">def Implies (p q : Prop) : Prop := p → q
</span>#check And     -- Prop → Prop → Prop
#check Or      -- Prop → Prop → Prop
#check Not     -- Prop → Prop
#check Implies -- Prop → Prop → Prop

variable (p q r : Prop)
#check And p q                      -- Prop
#check Or (And p q) r               -- Prop
#check Implies (And p q) (And q p)  -- Prop
</code></pre>
<p>それから、各要素 <code>p : Prop</code> に対して、<code>p</code> の証明の型 <code>Proof p</code> を導入できる。
「公理」とは、<code>Proof p</code> のような命題の証明の型を持った定数である。</p>
<pre><code class="language-lean"><span class="boring">def Implies (p q : Prop) : Prop := p → q
</span><span class="boring">structure Proof (p : Prop) : Type where
</span><span class="boring">  proof : p
</span>#check Proof   -- Proof (p : Prop) : Type

axiom and_comm (p q : Prop) : Proof (Implies (And p q) (And q p))

variable (p q : Prop)
#check and_comm p q     -- and_comm p q : Proof (Implies (p ∧ q) (q ∧ p))
#check and_comm q p     -- and_comm q p : Proof (Implies (q ∧ p) (p ∧ q))
</code></pre>
<p>公理だけでなく、既存の証明から新しい証明を作るためのルールも必要である。例えば、命題論理の証明系の多くには、&quot;modus ponens(モーダス・ポネンス)&quot;という推論規則がある。</p>
<blockquote>
<p>modus ponens : <code>Implies p q</code> の証明と <code>p</code> の証明があれば、そこから <code>q</code> の証明が得られる。</p>
</blockquote>
<p>Leanではモーダス・ポネンスを次のように表現できる。</p>
<pre><code class="language-lean"><span class="boring">def Implies (p q : Prop) : Prop := p → q
</span><span class="boring">structure Proof (p : Prop) : Type where
</span><span class="boring">  proof : p
</span>axiom modus_ponens : (p q : Prop) → Proof (Implies p q) → Proof p → Proof q
</code></pre>
<p>一般的に、命題論理のための自然演繹のシステムは次の推論規則も採用している:</p>
<blockquote>
<p>含意導入 : <code>p</code> を仮定すると <code>q</code> の証明が得られるとする。このとき、<code>Implies p q</code> の証明が得られる。</p>
</blockquote>
<p>含意導入はLean上で次のように表現できる。</p>
<pre><code class="language-lean"><span class="boring">def Implies (p q : Prop) : Prop := p → q
</span><span class="boring">structure Proof (p : Prop) : Type where
</span><span class="boring">  proof : p
</span>axiom implies_intro : (p q : Prop) → (Proof p → Proof q) → Proof (Implies p q)
</code></pre>
<p>以上の手法は、命題と証明の合理的な構築方法を提供する。この手法において、ある式 <code>t</code> が命題 <code>p : Prop</code> の正しい証明であることを確定させるには、<code>t</code> が <code>Proof p</code> という型を持つことをチェックすればよい。</p>
<p>いくつかの簡略化が可能である。まず、命題 <code>p : Prop</code> があるとき、<code>p</code> 自体を型として解釈することができる。さらに、型 <code>p</code> を <code>p</code> の証明の型と解釈する。つまり、型 <code>p</code> と型 <code>Proof p</code> を同一視する。すると、「<code>t</code> は <code>p</code> の証明である」という主張をシンプルに <code>t : p</code> と書くことができる。
この簡略化により、毎回 <code>Proof</code> と書く手間が省ける。</p>
<p>さらにこの手法を発展させる。命題 <code>p</code> と <code>q</code> の間の含意 <code>Implies p q</code> は、<code>p</code> の任意の要素に<code>q</code> の要素を一つ割り当てる関数 <code>p → q</code> と同一視できる。結果として、<code>Implies</code> という結合子の導入は不要である。含意の型 <code>Implies p q</code> の代わりに、依存型理論の関数の型 <code>p → q</code> を使えばよいのである。</p>
<p>これが<em>Calculus of Constructions</em>のアプローチであり、Leanはこのアプローチを採用している。自然演繹の証明系における含意に関する規則が、関数のラムダ抽象と適用に関する規則と正確に対応しているという事実は、<em>Curry-Howard isomorphism</em>(カリー=ハワード同型)の一例であり、<em>proposition-as-types</em>(型としての命題)パラダイムとして知られている。実は、型 <code>Prop</code> は前章で説明した型階層の最下層である型 <code>Sort 0</code> の糖衣構文である(<code>Prop</code> と <code>Sort 0</code> は全く同じ意味である)。さらに言えば、型 <code>Type u</code> は型 <code>Sort (u+1)</code> の糖衣構文に過ぎない。<code>Prop</code> はいくつか特別な特徴を持っているが、他の型宇宙と同様に、アローコンストラクタの下で閉じている。つまり、<code>p q : Prop</code> ならば <code>p → q : Prop</code> である(<code>α β : Type</code> ならば <code>α → β : Type</code> であるのと同様である)。</p>
<p>「型としての命題」について考えるには、少なくとも2通りの方法がある。論理学や数学について構成主義的な立場をとる人にとっては、「型としての命題」は「命題とはどういうものか」を忠実に表現している。命題 <code>p</code> は <code>p</code> の証明を構成するデータの型を表している。<code>p</code> の証明とは、単に正しく型付けされた項 <code>t : p</code> である。</p>
<p>このような主義に傾倒していない人にとって、「型としての命題」はむしろ単純なコーディング・トリックだと考えることができる。各命題 <code>p</code> に対して、 <code>p</code> が偽なら <code>p</code> に空の型を関連付ける。<code>p</code> が真なら <code>p</code> にただ一つの項 <code>*</code> を持つ型を関連付ける。後者のとき、<code>p</code> (に関連付けられた型)を <em>inhabited</em>(有項) と呼び、型 <code>p</code> が持つ項 <code>*</code> を<em>inhabitant</em>(住人) と呼ぶ。このとき、たまたま、関数の適用と抽象化の規則が、<code>Prop</code> のどの要素が有項かを追跡するのに便利だったのである。つまり、項 <code>t : p</code> を構築することが、<code>p</code> が真であることを保証してくれるのである。
このとき、<code>p</code> の住人 <code>t</code> とは「<code>p</code> が真であるという事実」のことだと考えることができる。そうすると、<code>p → q</code> の証明とは「<code>p</code> が真であるという事実」を受け取って「<code>q</code> が真であるという事実」を返す関数のことだと考えることができる。</p>
<p>実際、Leanのカーネルは <code>(fun x =&gt; t) s</code> と <code>t[s/x]</code>(項 <code>t</code> の中の全ての <code>x</code> を <code>s</code> で置き換えた項) をdefinitionally equalとみなすのと同様に、任意の <code>p : Prop</code> に対して任意の2つの項 <code>t1 t2 : p</code> をdefinitionally equalとみなす。<code>t1 t2 : p</code> をdefinitionally equalとみなすことは<em>proof irrelevance</em>(証明無関係)と呼ばれ、前段落の解釈と矛盾しない。つまり、証明 <code>t : p</code> は依存型理論の言語の中で普通の項として扱うことができるが、<code>t</code> は <code>p</code> が真であるという事実以上の情報は持っていないということである。</p>
<p>以上で提案した「型としての命題」パラダイムについて考えるための2つの方法は、根本的なところで異なっている。構成主義的な観点からすると、証明は抽象的な数学的対象であり、依存型理論において適切な項で「表現」される。対照的に、前述のコーディング・トリックの観点からすると、項 <code>t : p</code> そのものは何も面白いものを示さない。むしろ、項を書き下し、その項がきちんと型付けされていることを確認することで、問題の命題が真であることを保証するのである。つまり、項「そのもの」が証明なのである。</p>
<p>以下の説明では、ある項がある命題の証明を「構築する」「生成する」「返す」と表現したり、単にある項がある命題の証明「である」と表現したり、この両方の表現を使うことにする。これは、計算機科学者が、あるプログラムがある関数を「計算する」と言いながら、時にはそのプログラムがその関数「である」と言うことで、構文論と意味論の区別を曖昧にすることがあるのと似たようなものである。</p>
<p>いずれにせよ、本当に重要なのは次のことである: 依存型理論の言語で数学的な命題 <code>p</code> を形式的に表現するには、項 <code>p : Prop</code> を構築する必要がある。命題 <code>p</code> を「証明」するには、項 <code>t : p</code> を構築する必要がある。証明支援系Leanの仕事は、このような項 <code>t</code> を構築する手助けをし、そして <code>t</code> が適切な形をとっていて正しい型を持つことを検証することである。</p>
<h2 id="working-with-propositions-as-types-型としての命題を実践する"><a class="header" href="#working-with-propositions-as-types-型としての命題を実践する">Working with Propositions as Types (「型としての命題」を実践する)</a></h2>
<p>「型としての命題」パラダイムにおいては、<code>→</code> と命題だけを含む定理はラムダ抽象と関数適用を使って証明することができる。Leanでは、<code>theorem</code> コマンドを使うと新しい定理を導入できる。</p>
<pre><code class="language-lean">variable {p : Prop}
variable {q : Prop}

theorem t1 : p → q → p := fun hp : p =&gt; fun hq : q =&gt; hp
</code></pre>
<p>この証明を、型 <code>α → β → α</code> (<code>α</code> と <code>β</code> は型 <code>Type</code> の項) の項 <code>fun x : α =&gt; fun y : β =&gt; x</code> と比較してほしい。<code>fun x : α =&gt; fun y : β =&gt; x</code> は引数 <code>x : α</code> と引数 <code>y : β</code> をとり、<code>x</code> を返す。
<code>p → q → p</code> の証明は同じ形をとる。唯一の違いは <code>p</code> と <code>q</code> が <code>Type</code> ではなく <code>Prop</code> の項であることだけである。
直観的には、我々の <code>p → q → p</code> の証明は命題 <code>p : Prop</code> と命題 <code>q : Prop</code> が正しいことを前提とし、最初の前提から <code>p</code> が正しいことを(自明に)結論づける。</p>
<p><code>theorem</code> コマンドは <code>def</code> コマンドと全く同じである。つまり、命題と型の対応の下で、定理 <code>p → q → p</code> を証明することは、型 <code>p → q → p</code> の要素を定義することと全く同じである。実際、Leanのカーネルの型チェッカーにとって、<code>theorem</code> コマンドと <code>def</code> コマンドの間に違いはない。</p>
<p>しかしながら、定義と定理の間にはいくつかの実用的な違いがある。通常、定理の「定義」を展開する必要はない。証明無関係の原則により、ある定理の任意の2つの証明はdefinitionally equalである。一度定理の証明が完成したら、通常はその定理の証明が存在することだけが分かればよく、その証明が何であるかは重要ではない。この事実をふまえ、Leanは証明に<em>irreducible</em>とタグ付けする。ファイルを処理するとき、このタグはパーサー(より正確には<em>elaborator</em>)に対して、「このタグが付いたものを展開する必要はない」というヒントとして機能する。実際、Leanは一般的に証明の処理とチェックを平行して行うことができる。これは、ある証明の正しさを検証する際に、他の証明の詳細を知る必要がないからできることである。</p>
<p>定義と同様に、<code>#print</code> コマンドは定理の証明を表示する。</p>
<pre><code class="language-lean">variable {p : Prop}
variable {q : Prop}
theorem t1 : p → q → p := fun hp : p =&gt; fun hq : q =&gt; hp

#print t1    -- ∀ {p q : Prop}, p → q → p := fun {p q} hp hq =&gt; hp
</code></pre>
<p>ラムダ抽象 <code>hp : p</code> と <code>hq : q</code> は <code>p → q → p</code> の証明における一時的な前提と見なせることに注意してほしい。また、Leanでは、最後の項 <code>hp</code> の型を、<code>show</code> 文で明示的に指定することができる。</p>
<pre><code class="language-lean"><span class="boring">variable {p : Prop}
</span><span class="boring">variable {q : Prop}
</span>theorem t1 : p → q → p :=
  fun hp : p =&gt;
  fun hq : q =&gt;
  show p from hp      -- show &lt;型&gt; from &lt;項&gt;
</code></pre>
<p>このような情報を追加することで、証明の分かりやすさを向上させ、証明を書く際の誤りを発見しやすくすることができる。<code>show</code> コマンドは型に注釈をつける以上のことはしない。内部的には、これまで見てきた <code>t1</code> の表現は全て同じ項を生成している。</p>
<p>通常の定義と同様に、<code>theorem</code> コマンドにおいても、ラムダ抽象された変数をコロンの左側に持ってくることができる。</p>
<pre><code class="language-lean"><span class="boring">variable {p : Prop}
</span><span class="boring">variable {q : Prop}
</span>theorem t1 (hp : p) (hq : q) : p := hp

#print t1    -- p → q → p
</code></pre>
<p>定理 <code>t1</code> は関数適用と同様に他の項に適用することができる。</p>
<pre><code class="language-lean"><span class="boring">variable {p : Prop}
</span><span class="boring">variable {q : Prop}
</span>theorem t1 (hp : p) (hq : q) : p := hp

axiom hp : p

theorem t2 : q → p := t1 hp
</code></pre>
<p>ここで、<code>axiom</code> 宣言は与えられた型の項の存在を無条件に認めるため、<code>axiom</code> コマンドの使い方によっては論理的整合性を損なう可能性がある。例えば、<code>axiom</code> コマンドにより空の型 <code>False</code> が項を持つことを認めることさえ可能である。</p>
<pre><code class="language-lean">axiom unsound : False
-- `False`(偽)からは任意の命題を示すことができる
theorem ex : 1 = 0 :=    -- 本来は偽の命題
  False.elim unsound
</code></pre>
<p>「公理」<code>hp : p</code> を宣言することは、<code>hp</code> の存在を無条件に認め、<code>hp</code> により <code>p</code> が真であると宣言することと等価である。<code>p</code> が真だと主張する公理 <code>hp : p</code> に定理 <code>t1 : p → q → p</code> を適用すると、定理 <code>t1 hp : q → p</code> が得られる。</p>
<p>定理 <code>t1</code> は次のように書けることを思い出そう。</p>
<pre><code class="language-lean">theorem t1 {p q : Prop} (hp : p) (hq : q) : p := hp

#print t1    -- ∀ {p q : Prop}, p → q → p := fun {p q} hp hq =&gt; hp
</code></pre>
<p><code>t1</code> の型は <code>∀ {p q : Prop}, p → q → p</code> だと表示される。これは、「任意の命題のペア <code>p q</code> について、<code>p → q → p</code> が成立する」と読める。
この結果を用いると、<code>t1</code> の全ての引数をコロンの右側に持っていくことができる。</p>
<pre><code class="language-lean">theorem t1 : ∀ {p q : Prop}, p → q → p :=
  fun {p q : Prop} (hp : p) (hq : q) =&gt; hp
</code></pre>
<p><code>p</code> と <code>q</code> が <code>variable</code> コマンドを使って宣言されているなら、Leanは自動的に <code>p</code> と <code>q</code> を全称化する。</p>
<pre><code class="language-lean">variable {p q : Prop}

theorem t1 : p → q → p := fun (hp : p) (hq : q) =&gt; hp

#print t1    -- ∀ {p q : Prop}, p → q → p := fun {p q} hp hq =&gt; hp
</code></pre>
<p>「型としての命題」対応に従って、<code>p</code> は正しいという前提 <code>hp</code> を別の変数として宣言することができる。</p>
<pre><code class="language-lean">variable {p q : Prop}
variable (hp : p)

theorem t1 : q → p := fun (hq : q) =&gt; hp

#print t1    -- ∀ {p q : Prop}, p → q → p := fun {p q} hp hq =&gt; hp
</code></pre>
<p>Leanはこの証明が <code>hp</code> を使っていることを検出し、自動的に <code>hp : p</code> を前提に追加する。どの例でも <code>#print t1</code> は <code>∀ p q : Prop, p → q → p</code> を表示する。この型は <code>∀ (p q : Prop) (hp : p) (hq : q), p</code> とも書けることに注意してほしい。</p>
<p><code>t1</code> を全称化すれば、<code>t1</code> を様々な命題のペアに適用させることで、一般的な定理 <code>t1</code> の様々な例を得ることができる。</p>
<pre><code class="language-lean">theorem t1 (p q : Prop) (hp : p) (hq : q) : p := hp

variable (p q r s : Prop)

#check t1 p q                -- p → q → p
#check t1 r s                -- r → s → r
#check t1 (r → s) (s → r)    -- (r → s) → (s → r) → r → s

variable (h : r → s)
#check t1 (r → s) (s → r) h  -- (s → r) → r → s
</code></pre>
<p>再び、「型としての命題」対応を利用すると、<code>r → s</code> 型の変数 <code>h</code> を「<code>r → s</code> は真である」という前提とみなすことができる。</p>
<p>別の例として、前章で説明した合成関数を、今度は型の代わりに命題を使って考えてみよう。</p>
<pre><code class="language-lean">variable (p q r s : Prop)

theorem t2 (h₁ : q → r) (h₂ : p → q) : p → r :=
  fun h₃ : p =&gt;
  show r from h₁ (h₂ h₃)
</code></pre>
<p>命題論理の定理として見ると、<code>t2</code> は何を表現しているだろうか？</p>
<p>この例で使ったように、前提として使える証明項の名前にはUnicode数字添字を使うのが便利である。これらは<code>\0</code>、<code>\1</code>、<code>\2</code>、...と打つと入力できる。</p>
<h2 id="propositional-logic-命題論理"><a class="header" href="#propositional-logic-命題論理">Propositional Logic (命題論理)</a></h2>
<p>Leanでは標準的な論理的結合子と記法の全てが定義されている。命題論理の結合子は次のように表す:</p>
<table><thead><tr><th>Ascii</th><th>Unicode</th><th>エディターでの入力方法</th><th>定義</th></tr></thead><tbody>
<tr><td>True</td><td></td><td></td><td>True</td></tr>
<tr><td>False</td><td></td><td></td><td>False</td></tr>
<tr><td>Not</td><td>¬</td><td><code>\not</code>, <code>\neg</code></td><td>Not</td></tr>
<tr><td>/\</td><td>∧</td><td><code>\and</code></td><td>And</td></tr>
<tr><td>\/</td><td>∨</td><td><code>\or</code></td><td>Or</td></tr>
<tr><td>-&gt;</td><td>→</td><td><code>\to</code>, <code>\r</code>, <code>\imp</code></td><td></td></tr>
<tr><td>&lt;-&gt;</td><td>↔</td><td><code>\iff</code>, <code>\lr</code></td><td>Iff</td></tr>
</tbody></table>
<p>これらは <code>Prop</code> 型の項(命題)を取り、<code>Prop</code> 型の新しい項(命題)を返す。</p>
<pre><code class="language-lean">variable (p q : Prop)

#check p → q → p ∧ q
#check ¬p → p ↔ False
#check p ∨ q → q ∨ p
</code></pre>
<p>演算の順序は次の通り: 単項否定 <code>¬</code> が一番最初に結合し、次に <code>∧</code>、<code>∨</code>、<code>→</code>、最後に <code>↔</code> が結合する。例えば、<code>a ∧ b → c ∨ d ∧ e</code> と書かれていたら、それは <code>(a ∧ b) → (c ∨ (d ∧ e))</code> のことである。
引数の型が <code>Prop</code> であっても他の型であっても、<code>→</code> は右から順に結合していくことを忘れないでほしい。つまり、<code>p q r : Prop</code> とすると、<code>p → q → r</code> という式は <code>p → (q → r)</code> と同じである。これは、「カリー化」された <code>p ∧ q → r</code> である。</p>
<p>前節ではラムダ抽象を <code>→</code> の「導入則」とみなすことができることを説明した。ラムダ抽象が含意命題を「導入」あるいは構築する方法だとすると、関数適用は「含意の除去則」だとみなせる。つまり、関数適用は証明の中で含意を「除去する」あるいは使う方法である。他の命題論理の結合子はLeanのライブラリのファイル <code>Init/Prelude.lean</code> (ライブラリの階層構造については<a href="./interacting_with_lean.html#importing-files-%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%AE%E3%82%A4%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%88">Importing Files (ファイルのインポート)</a>を参照のこと)で定義されている。それぞれの結合子には正規化された導入則と除去則が存在する。</p>
<h3 id="conjunction-連言"><a class="header" href="#conjunction-連言">Conjunction (連言)</a></h3>
<p>式 <code>And.intro h1 h2</code> は証明 <code>h1 : p</code> と証明 <code>h2 : q</code> を使って <code>p ∧ q</code> の証明を構築する。<code>And.intro</code> は一般的に「連言の導入則」と表現される。次の例では、<code>And.intro</code> を使って <code>p → q → p ∧ q</code> の証明を作る。</p>
<pre><code class="language-lean">variable (p q : Prop)

example (hp : p) (hq : q) : p ∧ q := And.intro hp hq

#check fun (hp : p) (hq : q) =&gt; And.intro hp hq
</code></pre>
<p><code>example</code> コマンドは、定理に名前を付けたり、永続する文脈に定理を保存したりすることなく、定理を記述するのに使う。基本的には、<code>example</code> コマンドは与えられた項が与えられた型を持っているかどうかをチェックするだけである。実例を示すのに便利で、よく使うコマンドである。</p>
<p>式 <code>And.left h</code> は証明 <code>h : p ∧ q</code> から <code>p</code> の証明を作る。同様に、<code>And.right h</code> は証明 <code>h : p ∧ q</code> から <code>q</code> の証明を作る。これらは一般的に「左連言除去則」と「右連言除去則」として知られている。</p>
<pre><code class="language-lean">variable (p q : Prop)

example (h : p ∧ q) : p := And.left h
example (h : p ∧ q) : q := And.right h
</code></pre>
<p>ここまでの知識を使って、次のように <code>p ∧ q → q ∧ p</code> を証明することができる。</p>
<pre><code class="language-lean">variable (p q : Prop)

example (h : p ∧ q) : q ∧ p :=
  And.intro (And.right h) (And.left h)
</code></pre>
<p>連言導入と連言除去は直積ペアの構築と射影の操作に似ていることに注意してほしい。<code>p : Prop</code>、<code>q : Prop</code>、<code>hp : p</code>、<code>hq : q</code> のとき、<code>And.intro hp hq</code> は型 <code>p ∧ q : Prop</code> を持つ。一方、<code>p : Type</code>、<code>q : Type</code>、<code>hp : p</code>、<code>hq : q</code> のとき、<code>Prod hp hq</code> は型 <code>p × q : Type</code> を持つ。
この類似性は「カリー=ハワード同型対応」の別の例である。この類似性によると、今作った証明は直積ペアの要素を入れ替える関数に似ていることになる。しかし、含意と関数型コンストラクタとは対照的に、Leanでは <code>∧</code> と <code>×</code> は別々に扱われている。</p>
<p><a href="./structures_and_records.html">9章 Structures and Records (構造体とレコード)</a>で、Leanには<em>structures</em>(構造体)と呼ばれる型があることを学ぶ。構造体 <code>S</code> は適切な引数の列から <code>S</code> の要素を構築する単一で正規の<em>constructor</em>(コンストラクタ)によって定義される。任意の <code>p q : Prop</code> に対して、<code>p ∧ q</code> は構造体の一例である。構造体 <code>p ∧ q</code> の要素を構築する正規の方法は、適切な引数 <code>hp : p</code> と <code>hq : q</code> に <code>And.intro</code> を適用することである。
Leanでは、関連する型が帰納型であり、文脈から型推論できる場合、<em>anonymous constructor</em>(無名コンストラクタ)表記 <code>⟨arg1, arg2, ...⟩</code> を使うことができる。特に、<code>And.intro hp hq</code> の代わりに <code>⟨hp, hq⟩</code> と書くことがよくある。</p>
<pre><code class="language-lean">variable (p q : Prop)
variable (hp : p) (hq : q)

#check (⟨hp, hq⟩ : p ∧ q)
</code></pre>
<p>角括弧 <code>⟨ ⟩</code> は <code>\&lt;</code> <code>\&gt;</code> と打つことで入力できる。</p>
<p>他にもLeanには便利な構文機能がある。項 <code>e</code> が(パラメータをとる可能性のある)帰納型 <code>Foo</code> を持つとき、<code>e.bar</code> は <code>Foo.bar e</code> の略記である。この記法は名前空間を開くことなく関数にアクセスする便利な方法を提供する。例えば、次の2つの項は全く同じである:</p>
<pre><code class="language-lean">variable (xs : List Nat)

#check List.length xs
#check xs.length
</code></pre>
<p>結果として、<code>h : p ∧ q</code> があるとき、<code>And.left h</code> の代わりに <code>h.left</code> と書け、<code>And.right h</code> の代わりに <code>h.right</code> と書ける。従って、上記の例は次のように簡潔に書ける:</p>
<pre><code class="language-lean">variable (p q : Prop)

example (h : p ∧ q) : q ∧ p :=
  ⟨h.right, h.left⟩
</code></pre>
<p>簡潔さと難解さは紙一重であり、このように情報を省略することは時として証明を読みにくくする。しかし、上のような簡単な例で、<code>h</code> の型と構築したい型がはっきりしている場合、この記法は簡潔で効果的である。</p>
<p><code>And.</code> のような構築を繰り返すことは普通である。Leanはネストされた角括弧を外すことができる。このとき、各引数は右から結合する。したがって、次の2つの証明は等価である:</p>
<pre><code class="language-lean">variable (p q : Prop)

example (h : p ∧ q) : q ∧ p ∧ q :=
  ⟨h.right, ⟨h.left, h.right⟩⟩

example (h : p ∧ q) : q ∧ p ∧ q :=
  ⟨h.right, h.left, h.right⟩
</code></pre>
<p>これも便利である。</p>
<h3 id="disjunction-選言"><a class="header" href="#disjunction-選言">Disjunction (選言)</a></h3>
<p>式 <code>Or.intro_left q hp</code> は 証明 <code>hp : p</code> から <code>p ∨ q</code> の証明を作る。同様に、<code>Or.intro_right p hq</code> は証明 <code>hq : q</code> から <code>p ∨ q</code> の証明を作る。これらは「左選言導入則」と「右選言導入則」に相当する。</p>
<pre><code class="language-lean">variable (p q : Prop)
example (hp : p) : p ∨ q := Or.intro_left q hp
example (hq : q) : p ∨ q := Or.intro_right p hq
</code></pre>
<p>「選言除去則」は少し複雑である。<code>p</code> から <code>r</code> が導かれることと、 <code>q</code> から <code>r</code> が導かれることの両方を示せば、<code>p ∨ q</code> から <code>r</code> を証明できるという考えを使う。つまり、これは場合分けによる証明である。式 <code>Or.elim hpq hpr hqr</code> の中で、<code>Or.elim</code> は3つの引数 <code>hpq : p ∨ q</code>、<code>hpr : p → r</code>、
<code>hqr : q → r</code> を取り、<code>r</code> の証明を作る。次の例の中で、<code>p ∨ q → q ∨ p</code> を証明するのに <code>Or.elim</code> を使う。</p>
<pre><code class="language-lean">variable (p q r : Prop)

example (h : p ∨ q) : q ∨ p :=
  Or.elim h
    (fun hp : p =&gt;
      show q ∨ p from Or.intro_right q hp)
    (fun hq : q =&gt;
      show q ∨ p from Or.intro_left p hq)
</code></pre>
<p>ほとんどの場合、<code>Or.intro_right</code> の第1引数と <code>Or.intro_left</code> の第1引数はLeanによって自動的に推論される。Leanは <code>Or.intro_right _</code> の略記として <code>Or.inr</code> を、<code>Or.intro_left _</code> の略記として <code>Or.inl</code> を提供する。したがって、上記の証明はより簡潔に書ける:</p>
<pre><code class="language-lean">variable (p q r : Prop)

example (h : p ∨ q) : q ∨ p :=
  Or.elim h (fun hp =&gt; Or.inr hp) (fun hq =&gt; Or.inl hq)
</code></pre>
<p>この簡潔な式の中に、Leanが <code>hp</code> と <code>hq</code> の型を推論するのに十分な情報が含まれていることに注意してほしい。しかし、型注釈を用いた長い記述を用いることは、証明を読みやすくし、エラーを発見してデバッグするのに役立つ。</p>
<p><code>Or</code> は2つのコンストラクタを持つ、つまり単一で正規のコンストラクタを持たないため、<code>Or</code> の構築のために無名コンストラクタを使うことはできない。しかし、<code>Or.elim h</code> の代わりに <code>h.elim</code> と書くことはできる:</p>
<pre><code class="language-lean">variable (p q r : Prop)

example (h : p ∨ q) : q ∨ p :=
  h.elim (fun hp =&gt; Or.inr hp) (fun hq =&gt; Or.inl hq)
</code></pre>
<p>繰り返しになるが、このような略記が読みやすさを向上させるか低下させるか、書き手が判断する必要がある。</p>
<h3 id="negation-and-falsity-否定と恒偽"><a class="header" href="#negation-and-falsity-否定と恒偽">Negation and Falsity (否定と恒偽)</a></h3>
<p>否定 <code>¬p</code> は <code>p → False</code> と定義される。したがって、<code>¬p</code> の証明は <code>p</code> から矛盾を導くことで得られる。同様に、式 <code>hnp hp</code> は <code>hp : p</code> と <code>hnp : ¬p</code> から <code>False</code> の証明を作る。
次の例ではこれらの規則の両方を使って <code>(p → q) → ¬q → ¬p</code> の証明を作る(記号 <code>¬</code> は <code>\not</code> あるいは <code>\neg</code> と打つことで入力できる)。</p>
<pre><code class="language-lean">variable (p q : Prop)

example (hpq : p → q) (hnq : ¬q) : ¬p :=
  fun hp : p =&gt;
  show False from hnq (hpq hp)
</code></pre>
<p>結合子 <code>False</code> は単一の除去則 <code>False.elim</code> を持つ。<code>False.elim</code> は矛盾からは任意の命題が導かれるという事実を表現している。この規則は<em>ex falso</em> (<em>ex falso sequitur quodlibet</em>の略記)あるいは<em>principle of explosion</em>(爆発律)と呼ばれる。</p>
<pre><code class="language-lean">variable (p q : Prop)

example (hp : p) (hnp : ¬p) : q := False.elim (hnp hp)
</code></pre>
<p>恒偽から導かれる任意の命題 <code>q</code> は暗黙の引数であり、自動的に型推論される。矛盾する前提から任意の命題を導くパターンは非常によく見られ、<code>absurd</code> で表現される。</p>
<pre><code class="language-lean">variable (p q : Prop)

example (hp : p) (hnp : ¬p) : q := absurd hp hnp
</code></pre>
<p>次は <code>¬p → q → (q → p) → r</code> の証明である:</p>
<pre><code class="language-lean">variable (p q r : Prop)

example (hnp : ¬p) (hq : q) (hqp : q → p) : r :=
  absurd (hqp hq) hnp
</code></pre>
<p>ちなみに、<code>False</code> が除去則しか持たないように、<code>True</code> は導入則である <code>True.intro : True</code> しか持たない。つまり、<code>True</code> は単に真であり、<code>True.intro</code> という正規の証明を持っている。</p>
<h3 id="logical-equivalence-論理的同値"><a class="header" href="#logical-equivalence-論理的同値">Logical Equivalence (論理的同値)</a></h3>
<p>式 <code>Iff.intro h1 h2</code> は <code>h1 : p → q</code> と <code>h2 : q → p</code> から <code>p ↔ q</code> の証明を作る。 式 <code>Iff.mp h</code> は <code>h : p ↔ q</code> から <code>p → q</code> の証明を作る。同様に、<code>Iff.mpr h</code> は <code>h : p ↔ q</code> から <code>q → p</code> の証明を作る。以下は <code>p ∧ q ↔ q ∧ p</code> の証明である。</p>
<pre><code class="language-lean">variable (p q : Prop)

theorem and_swap : p ∧ q ↔ q ∧ p :=
  Iff.intro
    (fun h : p ∧ q =&gt;
     show q ∧ p from And.intro (And.right h) (And.left h))
    (fun h : q ∧ p =&gt;
     show p ∧ q from And.intro (And.right h) (And.left h))

#check and_swap p q    -- p ∧ q ↔ q ∧ p

variable (h : p ∧ q)
example : q ∧ p := Iff.mp (and_swap p q) h
</code></pre>
<p>無名コンストラクタ記法を使って、<code>p → q</code> の証明と　<code>q → p</code> の証明から <code>p ↔ q</code> の証明を構築することができる。また、<code>mp</code> と <code>mpr</code> について <code>.</code> に関する記法が使える。これらを使うと、上記の例は次のように簡潔に書くことができる:</p>
<pre><code class="language-lean">variable (p q : Prop)

theorem and_swap : p ∧ q ↔ q ∧ p :=
  ⟨ fun h =&gt; ⟨h.right, h.left⟩, fun h =&gt; ⟨h.right, h.left⟩ ⟩

example (h : p ∧ q) : q ∧ p := (and_swap p q).mp h
</code></pre>
<h2 id="introducing-auxiliary-subgoals-補助的なサブゴールの導入"><a class="header" href="#introducing-auxiliary-subgoals-補助的なサブゴールの導入">Introducing Auxiliary Subgoals (補助的なサブゴールの導入)</a></h2>
<p>そろそろ長い証明を書く際に役に立つ機能 <code>have</code> の紹介をする頃合いだろう。<code>have</code> は証明の中で補助的なサブゴールを導入する。次は前節から抜粋した短い例である。</p>
<pre><code class="language-lean">variable (p q : Prop)

example (h : p ∧ q) : q ∧ p :=
  have hp : p := h.left
  have hq : q := h.right
  show q ∧ p from And.intro hq hp
</code></pre>
<p>内部的には、式 <code>have h : p := s; t</code> は項 <code>(fun (h : p) =&gt; t) s</code> を作る。つまり、<code>s</code> は <code>p</code> の証明であり、<code>t</code> は 前提 <code>h : p</code> の下で欲しい結論の証明であり、<code>s</code> と <code>t</code> はラムダ抽象と関数適用によって組み合わせられる。<code>have</code> は、長い証明を構築する際に、最終的なゴールに至るための踏み台として使えるため、非常に便利である。</p>
<p>Leanは、ゴールから<em>backward reasoning</em>(後ろ向き推論)する構造化された方法もサポートしている。これは通常の数学における「Aを示すにはBを示せば十分である」という証明を模した手法である。次の例は、前の証明の最後の2行を単に並べ替えたものである。</p>
<pre><code class="language-lean">variable (p q : Prop)

example (h : p ∧ q) : q ∧ p :=
  have hp : p := h.left
  suffices hq : q from And.intro hq hp
  show q from And.right h
</code></pre>
<p><code>suffices hq : q</code> を使った後は2つのゴールを示す必要がある。まず、<code>q ∧ p</code> を示すには <code>q</code> を示せば十分であることを実際に示す必要がある。そのためには追加された前提 <code>hq : q</code> を使って元のゴール <code>q ∧ p</code> を証明すればよい。 最後に、<code>q</code> を示す必要がある。</p>
<h2 id="classical-logic-古典論理"><a class="header" href="#classical-logic-古典論理">Classical Logic (古典論理)</a></h2>
<p>これまで見てきた導入則と除去則は全て構成的論理(直観主義論理)のものである。これは「型としての命題」対応に基づいた論理的結合子の計算論的理解を反映したものである。通常の古典論理では、以上の導入則と除去則に加え、排中律 <code>p ∨ ¬p</code> を認める。この原則を使うには、名前空間 <code>Classical</code> を開く必要がある。</p>
<pre><code class="language-lean">open Classical

variable (p : Prop)
#check em p      -- p ∨ ¬p
</code></pre>
<p>直感的には、構成的論理の「Or」は非常に強い主張であり、<code>p ∨ q</code> を主張することは、どちらが正しいかを知っていることに等しい。リーマン予想を <code>RH</code> と表すと、古典論理を採用している数学者は、<code>RH</code> と <code>¬RH</code> のどちらが正しいのか分からないうちに <code>RH ∨ ¬RH</code> を主張することを厭わない。構成的論理を採用すると、このような主張の仕方はできない。</p>
<p>排中律の帰結として、二重否定除去則が得られる。</p>
<pre><code class="language-lean">open Classical

theorem dne {p : Prop} (h : ¬¬p) : p :=
  Or.elim (em p)
    (fun hp : p =&gt; hp)
    (fun hnp : ¬p =&gt; absurd hnp h)
</code></pre>
<p><code>¬p</code> を仮定すると <code>False</code> が導かれるとき、二重否定除去を使うと命題 <code>p</code> を証明することができる。なぜなら、仮定 <code>¬p</code> から <code>False</code> を導いたことは、<code>¬¬p</code> を証明したことと同義だからである。つまり、二重否定消去を使えば、構成的論理では一般には不可能な、矛盾による証明を行うことができる。練習として、逆を、つまり <code>dne</code> から <code>em</code> が証明できることを示してみよう。</p>
<p>古典論理の公理はまた、<code>em</code> により正当化される追加の証明パターンを使えるようにする。例えば、場合分けによる証明を行うことができる:</p>
<pre><code class="language-lean">open Classical
variable (p : Prop)

example (h : ¬¬p) : p :=
  byCases
    (fun h1 : p =&gt; h1)
    (fun h1 : ¬p =&gt; absurd h1 h)
</code></pre>
<p><code>hpq : p → q</code>、<code>hnpq : ¬p → q</code> のとき、<code>byCases hpq hnpq</code> は <code>q</code> の証明を作る。</p>
<p>あるいは、矛盾により証明を行うこともできる:</p>
<pre><code class="language-lean">open Classical
variable (p : Prop)

example (h : ¬¬p) : p :=
  byContradiction
    (fun h1 : ¬p =&gt;
     show False from h h1)
</code></pre>
<p><code>hnpf : ¬p → False</code> のとき、<code>byContradiction hnpf</code> は <code>p</code> の証明を作る。</p>
<p>もし構成的論理の考え方に慣れていないなら、古典論理的な推論がどこで使われているのか感覚を掴むのに時間がかかるかもしれない。次の例は、構成的論理では、 <code>p</code> と <code>q</code> が両立しないと分かってもどちらが偽であるかは必ずしも分からないので、古典論理が必要である:</p>
<pre><code class="language-lean"><span class="boring">open Classical
</span><span class="boring">variable (p q : Prop)
</span>example (h : ¬(p ∧ q)) : ¬p ∨ ¬q :=
  Or.elim (em p)
    (fun hp : p =&gt;
      Or.inr
        (show ¬q from
          fun hq : q =&gt;
          h ⟨hp, hq⟩))
    (fun hp : ¬p =&gt;
      Or.inl hp)
</code></pre>
<p>構成的論理には、排中律や二重否定除去のような原則が許される状況が「ある」ことを後に学ぶ。そのような状況では、Leanは排中律に頼ることなく古典論理的な推論の使用をサポートする。</p>
<p>古典論理的な推論を行うためにLeanで採用されている全ての公理の一覧は<a href="./axioms_and_computation.html">12章 Axioms and Computation (公理と計算)</a>で論じられている。</p>
<h2 id="examples-of-propositional-validities-命題論理における恒真式の例"><a class="header" href="#examples-of-propositional-validities-命題論理における恒真式の例">Examples of Propositional Validities (命題論理における恒真式の例)</a></h2>
<p>Leanの標準ライブラリは命題論理における恒真式の証明をいくつも含んでいる。その全ては読者自身の証明を書く際に自由に用いてよい。命題論理における恒真式のいくつかを以下に示す。</p>
<p>可換性:</p>
<ol>
<li><code>p ∧ q ↔ q ∧ p</code></li>
<li><code>p ∨ q ↔ q ∨ p</code></li>
</ol>
<p>結合性:</p>
<ol start="3">
<li><code>(p ∧ q) ∧ r ↔ p ∧ (q ∧ r)</code></li>
<li><code>(p ∨ q) ∨ r ↔ p ∨ (q ∨ r)</code></li>
</ol>
<p>分配性:</p>
<ol start="5">
<li><code>p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r)</code></li>
<li><code>p ∨ (q ∧ r) ↔ (p ∨ q) ∧ (p ∨ r)</code></li>
</ol>
<p>他の性質:</p>
<ol start="7">
<li><code>(p → (q → r)) ↔ (p ∧ q → r)</code></li>
<li><code>((p ∨ q) → r) ↔ (p → r) ∧ (q → r)</code></li>
<li><code>¬(p ∨ q) ↔ ¬p ∧ ¬q</code></li>
<li><code>¬p ∨ ¬q → ¬(p ∧ q)</code></li>
<li><code>¬(p ∧ ¬p)</code></li>
<li><code>p ∧ ¬q → ¬(p → q)</code></li>
<li><code>¬p → (p → q)</code></li>
<li><code>(¬p ∨ q) → (p → q)</code></li>
<li><code>p ∨ False ↔ p</code></li>
<li><code>p ∧ False ↔ False</code></li>
<li><code>¬(p ↔ ¬p)</code></li>
<li><code>(p → q) → (¬q → ¬p)</code></li>
</ol>
<p>これらは古典論理的な推論を必要とする:</p>
<ol start="19">
<li><code>(p → r ∨ s) → ((p → r) ∨ (p → s))</code></li>
<li><code>¬(p ∧ q) → ¬p ∨ ¬q</code></li>
<li><code>¬(p → q) → p ∧ ¬q</code></li>
<li><code>(p → q) → (¬p ∨ q)</code></li>
<li><code>(¬q → ¬p) → (p → q)</code></li>
<li><code>p ∨ ¬p</code></li>
<li><code>(((p → q) → p) → p)</code></li>
</ol>
<p><code>sorry</code> は魔法のようにあらゆる証明を生成したり任意の型の項を提供したりする。もちろん、<code>sorry</code> は証明方法としては不健全である。例えば、<code>sorry</code> を使って <code>False</code> を証明することができる。Leanは、<code>sorry</code> に依存する定理を使ったり、インポートしたりすると、深刻な警告を発する。しかし、長い証明を段階的に構築する際は便利である。サブ証明を <code>sorry</code> で埋めながら、証明をトップダウンで書いてみよう。<code>sorry</code> だけで構築された項をLeanが受容することを確認してほしい。そうでない場合は、修正する必要があるエラーが存在する。確認と修正が済んだら、実際の証明で <code>sorry</code> を一つ残らず書き換えよう。</p>
<p>もう一つ、便利な技がある。<code>sorry</code> を使う代わりに、アンダースコア <code>_</code> をプレースホルダーとして使うことができる。アンダースコアは引数が暗黙であることをLeanに伝えることを思い出してほしい。そしてアンダースコアはLeanによって自動的に埋められる。もしLeanがアンダースコアを埋めることに失敗したら、エラーメッセージ &quot;don't know how to synthesize placeholder&quot; が返され、続いて項の予想される型とその文脈で使用可能な全ての項と前提が返される。言い換えると、解決できなかったプレースホルダー1つ1つに対して、Leanはその時点で埋める必要のあるサブゴールを報告する。最終的に、プレースホルダーを段階的に埋めていくことで、証明を構築することができる。</p>
<p>参考として、上記のリストから抜粋した恒真式の証明の例を2つ紹介する。</p>
<pre><code class="language-lean">open Classical

-- 分配性
example (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) :=
  Iff.intro
    (fun h : p ∧ (q ∨ r) =&gt;
      have hp : p := h.left
      Or.elim (h.right)
        (fun hq : q =&gt;
          show (p ∧ q) ∨ (p ∧ r) from Or.inl ⟨hp, hq⟩)
        (fun hr : r =&gt;
          show (p ∧ q) ∨ (p ∧ r) from Or.inr ⟨hp, hr⟩))
    (fun h : (p ∧ q) ∨ (p ∧ r) =&gt;
      Or.elim h
        (fun hpq : p ∧ q =&gt;
          have hp : p := hpq.left
          have hq : q := hpq.right
          show p ∧ (q ∨ r) from ⟨hp, Or.inl hq⟩)
        (fun hpr : p ∧ r =&gt;
          have hp : p := hpr.left
          have hr : r := hpr.right
          show p ∧ (q ∨ r) from ⟨hp, Or.inr hr⟩))

-- 古典論理を必要とする例
example (p q : Prop) : ¬(p ∧ ¬q) → (p → q) :=
  fun h : ¬(p ∧ ¬q) =&gt;
  fun hp : p =&gt;
  show q from
    Or.elim (em q)
      (fun hq : q =&gt; hq)
      (fun hnq : ¬q =&gt; absurd (And.intro hp hnq) h)
</code></pre>
<h2 id="exercises-練習問題"><a class="header" href="#exercises-練習問題">Exercises (練習問題)</a></h2>
<p>&quot;sorry&quot; プレースホルダーを実際の証明で置き換えて、以下の恒真式を証明せよ。</p>
<pre><code class="language-lean">variable (p q r : Prop)

-- ∧ と ∨ の可換性
example : p ∧ q ↔ q ∧ p := sorry
example : p ∨ q ↔ q ∨ p := sorry

-- ∧ と ∨ の結合性
example : (p ∧ q) ∧ r ↔ p ∧ (q ∧ r) := sorry
example : (p ∨ q) ∨ r ↔ p ∨ (q ∨ r) := sorry

-- 分配性
example : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := sorry
example : p ∨ (q ∧ r) ↔ (p ∨ q) ∧ (p ∨ r) := sorry

-- 他の性質
example : (p → (q → r)) ↔ (p ∧ q → r) := sorry
example : ((p ∨ q) → r) ↔ (p → r) ∧ (q → r) := sorry
example : ¬(p ∨ q) ↔ ¬p ∧ ¬q := sorry
example : ¬p ∨ ¬q → ¬(p ∧ q) := sorry
example : ¬(p ∧ ¬p) := sorry
example : p ∧ ¬q → ¬(p → q) := sorry
example : ¬p → (p → q) := sorry
example : (¬p ∨ q) → (p → q) := sorry
example : p ∨ False ↔ p := sorry
example : p ∧ False ↔ False := sorry
example : (p → q) → (¬q → ¬p) := sorry
</code></pre>
<p>&quot;sorry&quot; プレースホルダーを実際の証明で置き換えて、以下の恒真式を証明せよ。これらは古典論理を必要とする。</p>
<pre><code class="language-lean">open Classical

variable (p q r : Prop)

example : (p → q ∨ r) → ((p → q) ∨ (p → r)) := sorry
example : ¬(p ∧ q) → ¬p ∨ ¬q := sorry
example : ¬(p → q) → p ∧ ¬q := sorry
example : (p → q) → (¬p ∨ q) := sorry
example : (¬q → ¬p) → (p → q) := sorry
example : p ∨ ¬p := sorry
example : (((p → q) → p) → p) := sorry
</code></pre>
<p>最後に、古典論理を使わずに <code>¬(p ↔ ¬p)</code> を証明せよ。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quantifiers-and-equality-量化子と等号"><a class="header" href="#quantifiers-and-equality-量化子と等号">Quantifiers and Equality (量化子と等号)</a></h1>
<p>第3章では、命題論理の結合子を含む定理の証明を構築する方法を紹介した。この章では、命題論理の結合子に加え、全称量化子、存在量化子、等号関係を用いた定理とその証明を構築する方法を紹介する。</p>
<h2 id="the-universal-quantifier-全称量化子"><a class="header" href="#the-universal-quantifier-全称量化子">The Universal Quantifier (全称量化子)</a></h2>
<p>任意の型 <code>α</code> に対して、<code>α</code> 上の一変数述語 <code>p</code> は、型 <code>α → Prop</code> の項として表現できることに注目してほしい。この場合、<code>x : α</code> が与えられると、<code>p x</code> は <code>x</code> について <code>p</code> が成り立つという主張を表す。同様に、項 <code>r : α → α → Prop</code> は <code>α</code> 上の二項関係を表す。<code>x y : α</code> が与えられると、<code>r x y</code> は <code>x</code> と <code>y</code> の間に二項関係 <code>r</code> が成立するという主張を表す。</p>
<p>全称量化子 <code>∀</code> を用いた主張 <code>∀ x : α, p x</code> は、「全ての <code>x : α</code> に対して、<code>p x</code> が成立する」という主張を表す。命題結合子と同様に、自然演繹の体系においては、全称量化子は導入則と除去則によって統制される。非形式的には、全称量化子の導入則は次のように表される:</p>
<blockquote>
<p><code>x : α</code> が任意に選べる文脈で <code>p x</code> の証明が与えられたとき、<code>∀ x : α, p x</code> の証明を得ることができる。</p>
</blockquote>
<p>全称量化子の除去則は次のように表される:</p>
<blockquote>
<p><code>∀ x : α, p x</code> の証明があるとき、任意の項 <code>t : α</code> に対して、<code>p t</code> の証明を得ることができる。</p>
</blockquote>
<p>含意の場合と同様に、「型としての命題」の考え方が有効である。依存関数型の導入則と除去則を思い出してほしい:</p>
<blockquote>
<p><code>x : α</code> が任意に選べる文脈で型 <code>β x</code> の項 <code>t</code> が作れるとき、項 <code>(fun x : α =&gt; t) : (x : α) → β x</code> が作れる。</p>
</blockquote>
<p>依存関数型の除去則は次のように表される:</p>
<blockquote>
<p>項 <code>s : (x : α) → β x</code> が与えられたとき、型 <code>α</code> の任意の項 <code>t : α</code> に対して、項 <code>s t : β t</code> を得ることができる。</p>
</blockquote>
<p><code>p x</code> が <code>Prop</code> 型を持つとき、型 <code>(x : α) → β x</code> を型 <code>∀ x : α, p x</code> とみなすことで、依存関数型の導入則と除去則を全称量化子の導入則と除去則とみなすことができる。これらの規則に従って、全称量化子を含む証明を構築することができる。</p>
<p>「型としての命題」の考え方に従って、Calculus of Constructionsでは、従属関数型と全称量化子を同一視する。つまり、任意の項 <code>p</code> に対して、<code>∀ x : α, p</code> は <code>(x : α) → p</code> の代替表現に過ぎず、<code>p</code> が命題のときは、前者の表現の方が後者より自然である、と考えるのである。</p>
<p>通常の関数の場合、<code>α → β</code> は <code>β</code> が <code>x : α</code> に依存しない場合の <code>(x : α) → β</code> だと解釈できることを思い出してほしい。同様に、命題間の含意 <code>p → q</code> は命題 <code>q</code> が <code>x : p</code> に依存しない場合の <code>∀ x : p, q</code> だと解釈することができる。</p>
<p>以下は、全称量化子に関する「型としての命題」対応がどのように実践されるかの例である。</p>
<pre><code class="language-lean">example (α : Type) (p q : α → Prop) : (∀ x : α, p x ∧ q x) → ∀ y : α, p y :=
  fun h : ∀ x : α, p x ∧ q x =&gt;
  fun y : α =&gt;
  show p y from (h y).left
</code></pre>
<p>表記上の慣習として、Leanは全称量化子に可能な限り広いスコープを与えるので、上の例では <code>x</code> に対する量化子のスコープを限定するために括弧が必要である。そして、<code>∀ y : α, p y</code> を証明する正規の方法は、<code>y</code> を任意に取り、<code>p y</code> を証明することである。これが全称量化子の導入則の使用例である。次に、型 <code>∀ x : α, p x ∧ q x</code> を持つ項 <code>h</code> が与えられると、項 <code>h y</code> は型 <code>p y ∧ q y</code> を持つ。これが全称量化子の除去則の使用例である。連言命題 <code>h y</code> の左の命題を取ると、所望の結論 <code>p y</code> が得られる。</p>
<p>束縛変数の名前を変えることで同じにできる2つの式は、等価であるとみなされる(α-同値)ことを思い出してほしい。例えば、上記の例について、結論の前件と後件の両方で同じ束縛変数名 <code>x</code> を用いて、証明の中では別の束縛変数名 <code>z</code> を使うこともできる。</p>
<pre><code class="language-lean">example (α : Type) (p q : α → Prop) : (∀ x : α, p x ∧ q x) → ∀ x : α, p x :=
  fun h : ∀ x : α, p x ∧ q x =&gt;
  fun z : α =&gt;
  show p z from And.left (h z)
</code></pre>
<p>もう一つの例として、関係 <code>r</code> が推移的であることはどのように表現されるかを提示しよう:</p>
<pre><code class="language-lean">variable (α : Type) (r : α → α → Prop)
variable (trans_r : ∀ x y z, r x y → r y z → r x z)

variable (a b c : α)
variable (hab : r a b) (hbc : r b c)

#check trans_r                -- ∀ (x y z : α), r x y → r y z → r x z
/- (r : α → α → Prop) と 「r x y → r y z → r x z」により x,y,z の型が推論されている -/
#check trans_r a b c          -- r a b → r b c → r a c
#check trans_r a b c hab      -- r b c → r a c
#check trans_r a b c hab hbc  -- r a c
</code></pre>
<p>この例で何が起こっているのかを考えてみよう。<code>trans_r</code> を値 <code>a b c</code> に適用すると、これは <code>r a b → r b c → r a c</code> の証明になる。これを「前提」<code>hab : r a b</code> に適用すると、含意命題 <code>r b c → r a c</code> の証明が得られる。最後に、これを前提 <code>hbc</code> に適用すると、結論 <code>r a c</code> の証明が得られる。</p>
<p><code>hab</code> と <code>hbc</code> があれば最初の3つの引数が <code>a b c</code> であることは容易に推論できる。このような状況において、引数 <code>a b c</code> を毎回与えるのは面倒かもしれない。そのため、これらを暗黙の引数にするのが一般的である:</p>
<pre><code class="language-lean">variable (α : Type) (r : α → α → Prop)
variable (trans_r : ∀ {x y z}, r x y → r y z → r x z)

variable (a b c : α)
variable (hab : r a b) (hbc : r b c)

#check trans_r          -- r ?m.1 ?m.2 → r ?m.2 ?m.3 → r ?m.1 ?m.3
#check trans_r hab      -- r b ?m.42 → r a ?m.42
#check trans_r hab hbc  -- r a c
</code></pre>
<p><code>x y z</code> を暗黙の引数にする利点は、<code>r a c</code> の証明を <code>trans_r hab hbc</code> と簡単に書けることである。欠点は、項 <code>trans_r</code> と項 <code>trans_r hab</code> の型を推論するのに必要な情報をLeanに与えることができないことである。最初の <code>#check</code> コマンドの出力は <code>r ?m.1 ?m.2 → r ?m.2 ?m.3 → r ?m.1 ?m.3</code> であり、暗黙の引数が特定できなかったことを示している。</p>
<p>次は <code>r</code> が同値関係であるという前提を使って初歩的な推論を行う例である:</p>
<pre><code class="language-lean">variable (α : Type) (r : α → α → Prop)

variable (refl_r : ∀ x, r x x)
variable (symm_r : ∀ {x y}, r x y → r y x)
variable (trans_r : ∀ {x y z}, r x y → r y z → r x z)

example (a b c d : α) (hab : r a b) (hcb : r c b) (hcd : r c d) : r a d :=
  trans_r (trans_r hab (symm_r hcb)) hcd
</code></pre>
<p>全称量化子の使い方に慣れるために、この章の最後にある練習問題をいくつかやってみるとよい。</p>
<p>依存関数型には型付け規則があるが、全称量化子には特殊な型付け規則がある。これが <code>Prop</code> と他の型の違いである。<code>α : Sort i</code> と <code>β : Sort j</code> があり、項 <code>β</code> は <code>x : α</code> に依存するかもしれないとする。このとき、<code>(x : α) → β</code> は型 <code>Sort (imax i j)</code> の項である。ここで、<code>imax i j</code> は <code>j</code> が0でないなら <code>i</code> と <code>j</code> の最大値で、<code>j</code> が0なら0である。</p>
<p><code>imax i j</code> の定義は次のように解釈すればよい。もし <code>j</code> が <code>0</code> でないなら、<code>(x : α) → β</code> は型 <code>Sort (max i j)</code> の項である。言い換えれば、<code>α</code> から <code>β</code> への依存関数型は、インデックスが <code>i</code> と <code>j</code> の最大値である宇宙に「住んで」いる。他方で、<code>β</code> が <code>Sort 0</code>、つまり <code>Prop</code> の項であるとしよう。この場合、<code>α</code> がどの階層的型宇宙に住んでいるかに関わらず、<code>(x : α) → β</code> も <code>Sort 0</code> (<code>Prop</code>) の項となる。言い換えれば、<code>β</code> が <code>α</code> に依存する命題であれば、 <code>∀ x : α, β</code> も命題であるということである。これは、<code>Prop</code> は単なるデータの型ではなく命題の型であるという解釈を反映している。そして以上のことは <code>Prop</code> を<em>impredicative</em>(非可述的)にしている。</p>
<p><em>predicative</em>(可述的)という用語は、20世紀初頭の数学基礎論の発展に由来する。当時、ポアンカレやラッセルといった論理学者が、集合論におけるパラドックスを、性質Aを持つ集合を量化することで性質Aを定義するときに生じる「悪循環」のせいにしたのである。任意の型 <code>α</code> に対して、<code>α</code> 上の全ての(一変数)述語からなる型 <code>α → Prop</code> (<code>α</code> の「べき型」)を作れることに注目してほしい。<code>Prop</code> のimpredicativity(非可述性)とは、<code>α → Prop</code> を量化した命題を作れることを意味する。特に、<code>α</code> 上の述語を全称量化することで、<code>α</code> 上の述語を定義することができ(<code>∀ X : α → Prop, β</code> と書くことで「全ての <code>α</code> 上の述語に対して <code>β</code> が成立する」という <code>α</code> 上の述語を定義することができ)、これはまさにかつて問題視された類の循環である。</p>
<h2 id="equality-等号"><a class="header" href="#equality-等号">Equality (等号)</a></h2>
<p>ここで、Leanのライブラリで定義されている最も基本的な関係の一つである「等号関係」に注目しよう。<a href="./inductive_types.html">7章 Inductive Types (帰納型)</a>では、Leanの<em>logical framework</em>(論理フレームワーク)の根本から「どのように」等号が定義されるかを説明する。その前に、ここでは等号の使い方を説明する。</p>
<p>もちろん、等号の基本的な性質の一つは、「等号は同値関係である」という性質である:</p>
<pre><code class="language-lean">#check Eq.refl    -- Eq.refl.{u_1} (a : α) : a = a
#check Eq.symm    -- Eq.symm.{u} {α : Sort u} {a b : α} (h : a = b) : b = a
#check Eq.trans   -- Eq.trans.{u} {α : Sort u} {a b c : α} (h₁ : a = b) (h₂ : b = c) : a = c
</code></pre>
<p>Leanに暗黙の引数(ここではメタ変数として表示されている)を挿入しないように指示することで、出力を読みやすくすることができる。</p>
<pre><code class="language-lean">universe u

#check @Eq.refl.{u}   -- @Eq.refl : ∀ {α : Sort u} (a : α), a = a
#check @Eq.symm.{u}   -- @Eq.symm : ∀ {α : Sort u} {a b : α}, a = b → b = a
#check @Eq.trans.{u}  -- @Eq.trans : ∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c
</code></pre>
<p><code>.{u}</code> という記法は、宇宙パラメータとして <code>u</code> を使うことをLeanに指示する。</p>
<p>したがって、例えば、前節の例を等号関係に特化させることができる:</p>
<pre><code class="language-lean">variable (α : Type) (a b c d : α)
variable (hab : a = b) (hcb : c = b) (hcd : c = d)

example : a = d :=
  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd
</code></pre>
<p>射影表記(<code>Foo.bar e</code> の <code>e.bar</code> という略記)も使うことができる:</p>
<pre><code class="language-lean"><span class="boring">variable (α : Type) (a b c d : α)
</span><span class="boring">variable (hab : a = b) (hcb : c = b) (hcd : c = d)
</span>example : a = d := (hab.trans hcb.symm).trans hcd
</code></pre>
<p>反射律 <code>Eq.refl</code> は見た目よりも強力である。Calculus of Constructionsにおいて、任意の型は計算可能な解釈を持ち、論理フレームワークは同一の簡約結果を持つ項たちを同じものとして扱うことを思い出してほしい。その結果、いくつかの非自明な恒等式を反射律によって証明することができる:</p>
<pre><code class="language-lean">variable (α β : Type)

example (f : α → β) (a : α) : (fun x =&gt; f x) a = f a := Eq.refl _
example (a : α) (b : β) : (a, b).1 = a := Eq.refl _
example : 2 + 3 = 5 := Eq.refl _
</code></pre>
<p>論理フレームワークのこの機能は非常に重要であるため、Leanのライブラリでは <code>Eq.refl _</code> により <code>rfl</code> という記法を定義している:</p>
<pre><code class="language-lean"><span class="boring">variable (α β : Type)
</span>example (f : α → β) (a : α) : (fun x =&gt; f x) a = f a := rfl
example (a : α) (b : β) : (a, b).1 = a := rfl
example : 2 + 3 = 5 := rfl
</code></pre>
<p>しかし、等号は同値関係以上のものである。等号は、左辺の式を右辺の式に置き換えても、あるいは右辺の式を左辺の式に置き換えても真理値が変わらないという意味で、全ての命題が等号によって主張される同値性を尊重するという重要な性質を持っている。つまり、<code>h1 : a = b</code> と <code>h2 : p a</code> があれば、代入 <code>Eq.subst h1 h2</code> を使って <code>p b</code> の証明を作ることができる。</p>
<pre><code class="language-lean">example (α : Type) (a b : α) (p : α → Prop)
        (h1 : a = b) (h2 : p a) : p b :=
  Eq.subst h1 h2

example (α : Type) (a b : α) (p : α → Prop)  -- h2の型の中に登場するh1の左辺をh1の右辺で書き換える
    (h1 : a = b) (h2 : p a) : p b :=
  h1 ▸ h2

example (α : Type) (a b : α) (p : α → Prop)  -- h2の型の中に登場するh1の右辺をh1の左辺で書き換える
    (h1 : a = b) (h2 : p b) : p a :=
  h1 ▸ h2
</code></pre>
<p>2番目、3番目の例の中の三角形は、<code>Eq.subst</code> と <code>Eq.symm</code> の上に構築されたマクロで、<code>\t</code> と打つことで入力できる。<code>h1 ▸ h2</code> は「<code>h1</code> を使って <code>h2</code> を書き換える」と解釈できる。</p>
<p><code>Eq.subst</code> 規則は、より明示的な置換を行う以下の補助規則を定義するために使われる。これらは関数適用項、つまり <code>s t</code> の形の項を扱うためのものである。具体的には、<code>congrArg</code> は <code>s</code> を固定して <code>t</code> を置換するのに使われ、<code>congrFun</code> は <code>t</code> を固定して <code>s</code> を置換するのに使われ、<code>congr</code> は <code>s</code> と <code>t</code> の両方を一度に置換するのに使われる。</p>
<pre><code class="language-lean">variable (α : Type)
variable (a b : α)
variable (f g : α → Nat)
variable (h₁ : a = b)
variable (h₂ : f = g)

example : f a = f b := congrArg f h₁
example : f a = g a := congrFun h₂ a
example : f a = g b := congr h₂ h₁
</code></pre>
<p>Leanのライブラリには次のような一般的な恒等式が多数収載されている:</p>
<pre><code class="language-lean">variable (a b c : Nat)

example : a + 0 = a := Nat.add_zero a
example : 0 + a = a := Nat.zero_add a
example : a * 1 = a := Nat.mul_one a
example : 1 * a = a := Nat.one_mul a
example : a + b = b + a := Nat.add_comm a b
example : a + b + c = a + (b + c) := Nat.add_assoc a b c
example : a * b = b * a := Nat.mul_comm a b
example : a * b * c = a * (b * c) := Nat.mul_assoc a b c
example : a * (b + c) = a * b + a * c := Nat.mul_add a b c
example : a * (b + c) = a * b + a * c := Nat.left_distrib a b c
example : (a + b) * c = a * c + b * c := Nat.add_mul a b c
example : (a + b) * c = a * c + b * c := Nat.right_distrib a b c
</code></pre>
<p><code>Nat.mul_add</code> と <code>Nat.add_mul</code> はそれぞれ <code>Nat.left_distrib</code> と <code>Nat.right_distrib</code> の別名である。上記の性質は、自然数（<code>Nat</code> 型）に関するものである。</p>
<pre><code class="language-lean">example (x y : Nat) : (x + y) * (x + y) = x * x + y * x + x * y + y * y :=
  have h1 : (x + y) * (x + y) = (x + y) * x + (x + y) * y :=
    Nat.mul_add (x + y) x y
  have h2 : (x + y) * (x + y) = x * x + y * x + (x * y + y * y) :=
    (Nat.add_mul x y x) ▸ (Nat.add_mul x y y) ▸ h1
  h2.trans (Nat.add_assoc (x * x + y * x) (x * y) (y * y)).symm
</code></pre>
<p><code>Eq.subst</code> の2番目の暗黙の引数は、置換が行われる文脈を提供するもので、<code>α → Prop</code> 型を持っていることに注意してほしい。</p>
<pre><code class="language-lean">#check Eq.subst  -- {α : Sort u} {motive : α → Prop} {a b : α} (h₁ : a = b) (h₂ : motive a) : motive b
</code></pre>
<p>したがって、この述語を推論するには、<em>higher-order unification</em>(高階ユニフィケーション)の解(高階単一子)が必要である。一般論として、高階単一子が存在するかを決定する問題は決定不能であり、Leanはせいぜいこの問題に対して不完全で近似的な解を提供することしかできない。そのため、<code>Eq.subst</code> は必ずしも思い通りに動くとは限らない。マクロ <code>h ▸ e</code> はこの暗黙の引数を計算する際により効果的なヒューリスティクスを使う。そのため、<code>Eq.subst</code> の適用が失敗するような状況でも、<code>h ▸ e</code> が成功することがしばしばある。</p>
<p>等式の推論は非常に一般的で重要であるため、Leanはそれをより効率的に実行するためのメカニズムを数多く提供している。次の節では、より自然で簡潔な方法で計算的証明を書くための構文を提供する。しかし、より重要なのは、等式推論が<em>rewriter</em>(項書き換え器)、<em>simplifier</em>(単純化器)、その他の自動化によって成り立っていることである。項書き換え器と単純化器については次の節で簡単に説明し、次の章でさらに詳しく説明する。</p>
<h2 id="calculational-proofs-計算的証明"><a class="header" href="#calculational-proofs-計算的証明">Calculational Proofs (計算的証明)</a></h2>
<p>計算的証明は、等号の推移律などの基本原則によって構成される中間結果の連鎖にすぎない。Leanにおいて、計算的証明はキーワード <code>calc</code> から始まる以下の構文を持つ:</p>
<pre><code>calc
  &lt;expr&gt;_0  'op_1'  &lt;expr&gt;_1  ':='  &lt;proof&gt;_1
  '_'       'op_2'  &lt;expr&gt;_2  ':='  &lt;proof&gt;_2
  ...
  '_'       'op_n'  &lt;expr&gt;_n  ':='  &lt;proof&gt;_n
</code></pre>
<p><code>calc</code> 以降の一連の行は全て同じインデントを持つ必要があることに注意。そうでなければコンパイルエラーになる。各 <code>&lt;proof&gt;_i</code> は <code>&lt;expr&gt;_{i-1} op_i &lt;expr&gt;_i</code> の証明である必要がある。</p>
<p>最初の行に <code>calc &lt;expr&gt;_0</code> と書いた後、その次の行から <code>_</code> を使う事もできる。これは関係命題と証明の組からなる行を揃えるのに便利である。</p>
<pre><code>calc &lt;expr&gt;_0 
    '_' 'op_1' &lt;expr&gt;_1 ':=' &lt;proof&gt;_1
    '_' 'op_2' &lt;expr&gt;_2 ':=' &lt;proof&gt;_2
    ...
    '_' 'op_n' &lt;expr&gt;_n ':=' &lt;proof&gt;_n
</code></pre>
<p>次は計算的証明の一例である:</p>
<pre><code class="language-lean">variable (a b c d e : Nat)
variable (h1 : a = b)
variable (h2 : b = c + 1)
variable (h3 : c = d)
variable (h4 : e = 1 + d)

theorem T : a = e :=
  calc
    a = b      := h1
    _ = c + 1  := h2
    _ = d + 1  := congrArg Nat.succ h3
    _ = 1 + d  := Nat.add_comm d 1
    _ = e      := Eq.symm h4
</code></pre>
<p>この証明の書き方は、次章で詳しく説明する <code>simp</code> タクティクや <code>rewrite</code> タクティクと併用すると最も効果的である。例えば、<code>rewrite</code> の略語 <code>rw</code> を使うと、上記の証明は次のように書ける:</p>
<pre><code class="language-lean"><span class="boring">variable (a b c d e : Nat)
</span><span class="boring">variable (h1 : a = b)
</span><span class="boring">variable (h2 : b = c + 1)
</span><span class="boring">variable (h3 : c = d)
</span><span class="boring">variable (h4 : e = 1 + d)
</span>theorem T : a = e :=
  calc
    a = b      := by rw [h1]
    _ = c + 1  := by rw [h2]
    _ = d + 1  := by rw [h3]
    _ = 1 + d  := by rw [Nat.add_comm]
    _ = e      := by rw [h4]
</code></pre>
<p>基本的に、<code>rw</code> タクティクは <code>[]</code> でくくられた等式(前提、定理名、複合的な項のいずれでもよい)を用いてゴールを「書き換える」。その結果、ゴールが恒等式 <code>t = t</code> になったら、<code>rw</code> タクティクは自動で反射律を使ってゴールを証明する。</p>
<p>段階的な書き換えを一度に実行することもできる。上の証明は次のように短縮できる:</p>
<pre><code class="language-lean"><span class="boring">variable (a b c d e : Nat)
</span><span class="boring">variable (h1 : a = b)
</span><span class="boring">variable (h2 : b = c + 1)
</span><span class="boring">variable (h3 : c = d)
</span><span class="boring">variable (h4 : e = 1 + d)
</span>theorem T : a = e :=
  calc
    a = d + 1  := by rw [h1, h2, h3]
    _ = 1 + d  := by rw [Nat.add_comm]
    _ = e      := by rw [h4]
</code></pre>
<p>ここまで短くしてもよい:</p>
<pre><code class="language-lean"><span class="boring">variable (a b c d e : Nat)
</span><span class="boring">variable (h1 : a = b)
</span><span class="boring">variable (h2 : b = c + 1)
</span><span class="boring">variable (h3 : c = d)
</span><span class="boring">variable (h4 : e = 1 + d)
</span>theorem T : a = e :=
  by rw [h1, h2, h3, Nat.add_comm, h4]
</code></pre>
<p><code>simp</code> タクティクは、ゴールの項の中に与えられた恒等式が適用できる場所がある限り、与えられた恒等式を任意の順番で繰り返し適用し、ゴールを書き換える。また、システム内で宣言された既存のルールも活用し、書き換えのループを避けるため可換性を賢く適用する。上記の証明は <code>simp</code> を使って次のように証明することもできる:</p>
<pre><code class="language-lean"><span class="boring">variable (a b c d e : Nat)
</span><span class="boring">variable (h1 : a = b)
</span><span class="boring">variable (h2 : b = c + 1)
</span><span class="boring">variable (h3 : c = d)
</span><span class="boring">variable (h4 : e = 1 + d)
</span>theorem T : a = e :=
  by simp [h1, h2, h3, Nat.add_comm, h4]
</code></pre>
<p>次の章では <code>rw</code> と <code>simp</code> の派生について説明する。</p>
<p><code>calc</code> コマンドは、何らかの形で推移律を持つあらゆる関係に対して使うことができる。計算的証明の中で異なる関係を組み合わせることもできる。</p>
<pre><code class="language-lean">example (a b c d : Nat) (h1 : a = b) (h2 : b ≤ c) (h3 : c + 1 &lt; d) : a &lt; d :=
  calc
    a = b     := h1
    _ &lt; b + 1 := Nat.lt_succ_self b
    _ ≤ c + 1 := Nat.succ_le_succ h2
    _ &lt; d     := h3
</code></pre>
<p><code>Trans</code> 型クラスの新しいインスタンスを追加することで、<code>calc</code> に新しい推移律の定理を「教える」ことができる。型クラスについては後で紹介するが、ここではとりあえず新しい <code>Trans</code> インスタンスを使って <code>calc</code> 記法を拡張する方法を示す小さな例を以下に挙げる。</p>
<pre><code class="language-lean">def divides (x y : Nat) : Prop :=
  ∃ k, k*x = y

def divides_trans (h₁ : divides x y) (h₂ : divides y z) : divides x z :=
  let ⟨k₁, d₁⟩ := h₁
  let ⟨k₂, d₂⟩ := h₂
  ⟨k₁ * k₂, by rw [Nat.mul_comm k₁ k₂, Nat.mul_assoc, d₁, d₂]⟩

def divides_mul (x : Nat) (k : Nat) : divides x (k*x) :=
  ⟨k, rfl⟩

instance : Trans divides divides divides where
  trans := divides_trans

example (h₁ : divides x y) (h₂ : y = z) : divides x (2*z) :=
  calc
    divides x y     := h₁
    _ = z           := h₂
    divides _ (2*z) := divides_mul ..

infix:50 &quot; ∣ &quot; =&gt; divides

example (h₁ : divides x y) (h₂ : y = z) : divides x (2*z) :=
  calc
    x ∣ y   := h₁
    _ = z   := h₂
    _ ∣ 2*z := divides_mul ..
</code></pre>
<p>上記の例から、ユーザーが定義した関係がinfix表記を持たなくても、その関係について <code>calc</code> が使えることがわかる。最後に、上記の例の縦棒 <code>∣</code> はunicodeのものである。<code>match ... with</code> 式で使われるASCIIの <code>|</code> のオーバーロードを避けるためにunicodeの記号を用いた。</p>
<p><code>calc</code> を用いると、前節の証明をより自然にわかりやすく書くことができる。</p>
<pre><code class="language-lean">example (x y : Nat) : (x + y) * (x + y) = x * x + y * x + x * y + y * y :=
  calc
    (x + y) * (x + y) = (x + y) * x + (x + y) * y  := by rw [Nat.mul_add]
    _ = x * x + y * x + (x + y) * y                := by rw [Nat.add_mul]
    _ = x * x + y * x + (x * y + y * y)            := by rw [Nat.add_mul]
    _ = x * x + y * x + x * y + y * y              := by rw [←Nat.add_assoc]
</code></pre>
<p>ここでは、<code>calc</code> の他の記法を検討する価値がある。最初の式がこれだけ広いスペースをとる場合、最初の関係式に <code>_</code> を使うと、全ての関係式が自然に整列される:</p>
<pre><code class="language-lean">example (x y : Nat) : (x + y) * (x + y) = x * x + y * x + x * y + y * y :=
  calc (x + y) * (x + y)
    _ = (x + y) * x + (x + y) * y       := by rw [Nat.mul_add]
    _ = x * x + y * x + (x + y) * y     := by rw [Nat.add_mul]
    _ = x * x + y * x + (x * y + y * y) := by rw [Nat.add_mul]
    _ = x * x + y * x + x * y + y * y   := by rw [←Nat.add_assoc]
</code></pre>
<p>ここで、<code>Nat.add_assoc</code> の前の左矢印は、書き換えの際に与えられた恒等式を逆向きに使うように <code>rw</code> に指示する(左矢印は <code>\l</code> と打つと入力できる。これと等価なascii文字列 <code>&lt;-</code> を使ってもいい)。簡潔さを求めるなら、次のように単独の <code>rw</code> や <code>simp</code> を使うだけで証明を完結させることもできる。 </p>
<pre><code class="language-lean">example (x y : Nat) : (x + y) * (x + y) = x * x + y * x + x * y + y * y :=
  by rw [Nat.mul_add, Nat.add_mul, Nat.add_mul, ←Nat.add_assoc]

example (x y : Nat) : (x + y) * (x + y) = x * x + y * x + x * y + y * y :=
  by simp [Nat.mul_add, Nat.add_mul, Nat.add_assoc]
</code></pre>
<h2 id="the-existential-quantifier-存在量化子"><a class="header" href="#the-existential-quantifier-存在量化子">The Existential Quantifier (存在量化子)</a></h2>
<p>最後に、存在量化子について考えよう。存在量化子は <code>exists x : α, p x</code> または <code>∃ x : α, p x</code> と書くことができる。どちらの記法も、Leanのライブラリで定義されている <code>Exists (fun x : α =&gt; p x)</code> という長ったらしい表現の便利な省略形である。</p>
<p>もうお分かりのように、Leanのライブラリは存在量化子の導入則と除去則を含んでいる。導入則は簡単である: <code>∃ x : α, p x</code> を証明するには、適切な項 <code>t : α</code> と <code>p t</code> の証明を与えればよい。次はその例である:</p>
<pre><code class="language-lean">example : ∃ x : Nat, x &gt; 0 :=
  have h : 1 &gt; 0 := Nat.zero_lt_succ 0
  Exists.intro 1 h

example (x : Nat) (h : x &gt; 0) : ∃ y, y &lt; x :=
  Exists.intro 0 h

example (x y z : Nat) (hxy : x &lt; y) (hyz : y &lt; z) : ∃ w, x &lt; w ∧ w &lt; z :=
  Exists.intro y (And.intro hxy hyz)

#check @Exists.intro  -- @Exists.intro : ∀ {α : Sort u_1} {p : α → Prop} (w : α), p w → Exists p
</code></pre>
<p>型が文脈から明らかな場合、<code>Exists.intro t h</code> の代わりに、無名コンストラクタ表記 <code>⟨t, h⟩</code> を使うことができる。</p>
<pre><code class="language-lean">example : ∃ x : Nat, x &gt; 0 :=
  have h : 1 &gt; 0 := Nat.zero_lt_succ 0
  ⟨1, h⟩

example (x : Nat) (h : x &gt; 0) : ∃ y, y &lt; x :=
  ⟨0, h⟩

example (x y z : Nat) (hxy : x &lt; y) (hyz : y &lt; z) : ∃ w, x &lt; w ∧ w &lt; z :=
  ⟨y, hxy, hyz⟩  -- ⟨y, hxy, hyz⟩ は ⟨y, ⟨hxy, hyz⟩ ⟩ と同じ
</code></pre>
<p><code>Exists.intro</code> には暗黙の引数があることに注意してほしい: Leanは結論 <code>∃ x, p x</code> から述語 <code>p : α → Prop</code> が何であるかを推論しなければならない。これは簡単なことではない。例えば、<code>hg : g 0 0 = 0</code> とし、<code>Exists.intro 0 hg</code> と書くとする。このとき、述語 <code>p</code> は 定理 <code>∃ x, g x x = x</code>、<code>∃ x, g x x = 0</code>、<code>∃ x, g x 0 = x</code> などに対応する様々な値を取りうる。Leanは文脈からどれが適切かを推論する。次の例では、<code>pp.explicit</code> オプションを <code>true</code> に設定し、<code>#print</code> コマンドに暗黙の引数を表示するように問い合わせている。</p>
<pre><code class="language-lean">variable (g : Nat → Nat → Nat)
variable (hg : g 0 0 = 0)

theorem gex1 : ∃ x, g x x = x := ⟨0, hg⟩
theorem gex2 : ∃ x, g x 0 = x := ⟨0, hg⟩
theorem gex3 : ∃ x, g 0 0 = x := ⟨0, hg⟩
theorem gex4 : ∃ x, g x x = 0 := ⟨0, hg⟩

set_option pp.explicit true  -- 暗黙の引数を表示する
#print gex1
#print gex2
#print gex3
#print gex4
</code></pre>
<p><code>Exists.intro</code> は主張本体の証人(存在量化を受けた主張を満たす項)を隠すため、情報を隠す操作であると解釈することができる。存在量化子の除去則 <code>Exists.elim</code> はその逆の操作を行う。<code>Exists.elim</code> は任意の値 <code>w : α</code> に対して <code>p w</code> ならば <code>q</code> が成立することを示すことで、<code>∃ x : α, p x</code> から命題 <code>q</code> を証明することを可能にする。大雑把に言えば、<code>∃ x : α, p x</code> が成立するなら <code>p x</code> を満たす <code>x</code> が存在することがわかるので、その <code>x</code> に名前、例えば <code>w</code> を与えることができる。もし <code>q</code> が <code>w</code> に言及していなければ、<code>q</code> が <code>p w</code> から導かれることを示すことは、<code>q</code> が <code>p w</code> を満たす <code>x</code> の存在から導かれることを示すことに等しい。次はその例である:</p>
<pre><code class="language-lean">variable (α : Type) (p q : α → Prop)

example (h : ∃ x, p x ∧ q x) : ∃ x, q x ∧ p x :=
  Exists.elim h
    (fun w =&gt;
     fun hw : p w ∧ q w =&gt;
     show ∃ x, q x ∧ p x from ⟨w, hw.right, hw.left⟩)

#check @Exists.elim  -- ∀ {α : Sort u_1} {p : α → Prop} {b : Prop}, (∃ x, p x) → (∀ (a : α), p a → b) → b
</code></pre>
<p>ここで、無名コンストラクタ表記 <code>⟨w, hw.right, hw.left⟩</code> が入れ子になったコンストラクタの適用を省略していることに注意。<code>⟨w, hw.right, hw.left⟩</code> は <code>⟨w, ⟨hw.right, hw.left⟩⟩</code> と書いたのと同じである。</p>
<p>存在量化子除去則と選言除去則を比較することは有用であろう: 主張 <code>∃ x : α, p x</code> は、 <code>a</code> が型 <code>α</code> の全ての項をわたるときの、命題 <code>p a</code> 全てを選言で繋げたものと考えることができる。</p>
<p>存在命題は、2章の従属型の節で説明したシグマ型(依存直積型)に非常に似ていることに注目しよう。<code>a : α</code> と <code>h : p a</code> が与えられたとき、項 <code>Exists.intro a h</code> は型 <code>(∃ x : α, p x) : Prop</code> を持つ一方で、<code>Sigma.mk a h</code> は型 <code>(Σ x : α, p x) : Type</code> を持つ。この <code>∃</code> と <code>Σ</code> の類似性はカリー=ハワード同型のもう一つの例である。</p>
<pre><code class="language-lean">section exist_prop
variable (a : α) (p : α → Prop) (h : p a)

#check Exists.intro a h  -- Exists p
end exist_prop

section sigma_type
variable (a : α) (p : α → Type) (h : p a)

#check Sigma.mk a h      -- Sigma p
end sigma_type
</code></pre>
<p>Leanは、<code>match</code> 式を用いた、存在量化子を除去するためのより便利な方法を提供する:</p>
<pre><code class="language-lean">variable (α : Type) (p q : α → Prop)

example (h : ∃ x, p x ∧ q x) : ∃ x, q x ∧ p x :=
  match h with
  | ⟨w, hw⟩ =&gt; ⟨w, hw.right, hw.left⟩
</code></pre>
<p><code>match</code> 式はLeanの関数定義システムの一部であり、複雑な関数を定義する便利で表現力豊かな方法を提供する。再びカリー=ハワード同型により、この関数定義方法 <code>match</code> を証明の記述にも応用させることができる。<code>match</code> 式は存在量化された主張を <code>w</code> と <code>hw</code> に「分解」する。これらは命題の証明記述内で使うことができる。より明確にするために、マッチで分解されてできた要素に型の注釈を付けることができる:</p>
<pre><code class="language-lean"><span class="boring">variable (α : Type) (p q : α → Prop)
</span>example (h : ∃ x, p x ∧ q x) : ∃ x, q x ∧ p x :=
  match h with
  | ⟨(w : α), (hw : p w ∧ q w)⟩ =&gt; ⟨w, hw.right, hw.left⟩
</code></pre>
<p>match 式を使って、存在量化子と連言を同時に分解することもできる:</p>
<pre><code class="language-lean"><span class="boring">variable (α : Type) (p q : α → Prop)
</span>example (h : ∃ x, p x ∧ q x) : ∃ x, q x ∧ p x :=
  match h with
  | ⟨(w : α), (hpw : p w), (hqw : q w)⟩ =&gt; ⟨w, hqw, hpw⟩
</code></pre>
<p>Leanは <code>let</code> キーワードにもパターンマッチングを提供する:</p>
<pre><code class="language-lean"><span class="boring">variable (α : Type) (p q : α → Prop)
</span>example (h : ∃ x, p x ∧ q x) : ∃ x, q x ∧ p x :=
  let ⟨w, hpw, hqw⟩ := h
  ⟨w, hqw, hpw⟩
</code></pre>
<p>これは、基本的に上記の <code>match</code> 式の代替表記に過ぎない。Leanでは、<code>fun</code> キーワードの中で暗黙の <code>match</code> を使うこともできる:</p>
<pre><code class="language-lean"><span class="boring">variable (α : Type) (p q : α → Prop)
</span>example : (∃ x, p x ∧ q x) → ∃ x, q x ∧ p x :=
  fun ⟨w, hpw, hqw⟩ =&gt; ⟨w, hqw, hpw⟩
</code></pre>
<p><a href="./induction_and_recursion.html">8章 Induction and Recursion (帰納と再帰)</a> では、これらの派生構文は全てより一般的なパターンマッチング構文の特殊例であることを説明する。</p>
<p>次の例では、<code>is_even a</code> を <code>∃ b, a = 2 * b</code> と定義し、2つの偶数の和は偶数であることを示す。</p>
<pre><code class="language-lean">def is_even (a : Nat) : Prop := ∃ b : Nat, a = 2 * b

theorem even_plus_even {a b : Nat} (h1 : is_even a) (h2 : is_even b) : is_even (a + b) :=
  Exists.elim h1 (fun w1 (hw1 : a = 2 * w1) =&gt;
  Exists.elim h2 (fun w2 (hw2 : b = 2 * w2) =&gt;
    Exists.intro (w1 + w2)
      (calc a + b
        _ = 2 * w1 + 2 * w2 := by rw [hw1, hw2]
        _ = 2 * (w1 + w2)   := by rw [Nat.mul_add])))

theorem even_plus_even2 : ∀ a b : Nat, is_even a → is_even b → is_even (a + b) :=
  fun a : Nat =&gt;
  fun b : Nat =&gt; 
  fun ⟨(w1 : Nat), (hw1 : a = 2 * w1)⟩ =&gt;
  fun ⟨(w2 : Nat), (hw2 : b = 2 * w2)⟩ =&gt;
    have hw3 : a + b = 2 * (w1 + w2) :=
      calc a + b
        _ = 2 * w1 + 2 * w2 := by rw [hw1, hw2]
        _ = 2 * (w1 + w2)   := by rw [Nat.mul_add]
    ⟨(w1 + w2 : Nat), (hw3 : a + b = 2 * (w1 + w2))⟩
</code></pre>
<p>マッチ式、無名コンストラクタ、<code>rewrite</code> タクティク……、この章で説明した様々な小道具を使ってこの証明を簡潔に書くと次のようになる:</p>
<pre><code class="language-lean"><span class="boring">def is_even (a : Nat) := ∃ b, a = 2 * b
</span>theorem even_plus_even (h1 : is_even a) (h2 : is_even b) : is_even (a + b) :=
  match h1, h2 with
  | ⟨w1, hw1⟩, ⟨w2, hw2⟩ =&gt; ⟨w1 + w2, by rw [hw1, hw2, Nat.mul_add]⟩
</code></pre>
<p>構成的(構成的論理の)「または」が古典的「または」よりも強いように、構成的「存在する」も古典的「存在する」より強い。次の例に挙げるような含意命題を証明するためには、古典論理的な推論を必要とする。なぜなら、構成的論理では、「全ての <code>x</code> が <code>¬ p</code> を満たす」の否定が真であることと、「<code>p</code> を満たす <code>x</code> が存在する」が真であることは同じではないからである。</p>
<pre><code class="language-lean">open Classical
universe u
variable (α : Sort u) (p : α → Prop)

example (h : ¬ ∀ x, ¬ p x) : ∃ x, p x :=
  byContradiction
    (fun h1 : ¬ ∃ x, p x =&gt;
      have h2 : ∀ x, ¬ p x :=
        fun x =&gt;
        fun h3 : p x =&gt;
        have h4 : ∃ x, p x := ⟨x, h3⟩
        show False from h1 h4
      show False from h h2)
</code></pre>
<p>以下に、練習問題として存在量化子を含む一般的な恒等式を挙げる。ここでは、できる限り多くの命題を証明することを勧める。また、どの命題が非構成的で、古典論理的な推論を必要とするかは、読者の判断に委ねる。</p>
<pre><code class="language-lean">open Classical

variable (α : Type) (p q : α → Prop)
variable (r : Prop)

example : (∃ x : α, r) → r := sorry
example (a : α) : r → (∃ x : α, r) := sorry
example : (∃ x, p x ∧ r) ↔ (∃ x, p x) ∧ r := sorry
example : (∃ x, p x ∨ q x) ↔ (∃ x, p x) ∨ (∃ x, q x) := sorry

example : (∀ x, p x) ↔ ¬ (∃ x, ¬ p x) := sorry
example : (∃ x, p x) ↔ ¬ (∀ x, ¬ p x) := sorry
example : (¬ ∃ x, p x) ↔ (∀ x, ¬ p x) := sorry
example : (¬ ∀ x, p x) ↔ (∃ x, ¬ p x) := sorry

example : (∀ x, p x → r) ↔ (∃ x, p x) → r := sorry
example (a : α) : (∃ x, p x → r) ↔ (∀ x, p x) → r := sorry
example (a : α) : (∃ x, r → p x) ↔ (r → ∃ x, p x) := sorry
</code></pre>
<p>2番目の例と最後の2つの例は、型 <code>α</code> には少なくとも1つの要素 <code>a</code> が存在するという前提を必要とすることに注意してほしい。</p>
<p>以下は2つの難しい問題への解答である:</p>
<pre><code class="language-lean">open Classical

variable (α : Type) (p q : α → Prop)
variable (a : α)
variable (r : Prop)

example : (∃ x, p x ∨ q x) ↔ (∃ x, p x) ∨ (∃ x, q x) :=
  Iff.intro
    (fun ⟨a, (h1 : p a ∨ q a)⟩ =&gt;
      Or.elim h1
        (fun hpa : p a =&gt; Or.inl ⟨a, hpa⟩)
        (fun hqa : q a =&gt; Or.inr ⟨a, hqa⟩))
    (fun h : (∃ x, p x) ∨ (∃ x, q x) =&gt;
      Or.elim h
        (fun ⟨a, hpa⟩ =&gt; ⟨a, (Or.inl hpa)⟩)
        (fun ⟨a, hqa⟩ =&gt; ⟨a, (Or.inr hqa)⟩))

example : (∃ x, p x → r) ↔ (∀ x, p x) → r :=
  Iff.intro
    (fun ⟨b, (hb : p b → r)⟩ =&gt;
     fun h2 : ∀ x, p x =&gt;
     show r from hb (h2 b))
    (fun h1 : (∀ x, p x) → r =&gt;
     show ∃ x, p x → r from
       byCases
         (fun hap : ∀ x, p x =&gt; ⟨a, fun h' : p a =&gt; h1 hap⟩)
         (fun hnap : ¬ ∀ x, p x =&gt;
          byContradiction
            (fun hnex : ¬ ∃ x, p x → r =&gt;
              have hap : ∀ x, p x :=
                fun x =&gt;
                byContradiction
                  (fun hnp : ¬ p x =&gt;
                    have hex : ∃ x, p x → r := ⟨x, (fun hp : p x =&gt; absurd hp hnp)⟩
                    show False from hnex hex)
              show False from hnap hap)))
</code></pre>
<h2 id="more-on-the-proof-language-証明言語の詳細"><a class="header" href="#more-on-the-proof-language-証明言語の詳細">More on the Proof Language (証明言語の詳細)</a></h2>
<p><code>fun</code>、<code>have</code>、<code>show</code> などのキーワードにより、非形式的な数学的証明の構造を反映した形式的証明項を書くことができることを見てきた。この節では、証明言語の他の便利な機能について説明する。</p>
<p>まず、ラベルを付けることなく補助ゴールを導入するために、無名の「have」式を使うことができる。<code>this</code> キーワードを用いると、無名の「have」式を使って導入された最後の項を参照することができる:</p>
<pre><code class="language-lean">variable (f : Nat → Nat)
variable (h : ∀ x : Nat, f x ≤ f (x + 1))

example : f 0 ≤ f 3 :=
  have : f 0 ≤ f 1 := h 0
  have : f 0 ≤ f 2 := Nat.le_trans this (h 1)
  show f 0 ≤ f 3 from Nat.le_trans this (h 2)
</code></pre>
<p>証明の中ではいくつもの事実を使い捨てることが多いので、ラベルの付いた項が増えすぎてごちゃごちゃするのを防ぐには無名の「have」式が有効である。</p>
<p>ゴール(今ここで使いたい項の型)が推論できる場合は、<code>by assumption</code> と書くことでLeanに証明を埋めるよう頼むこともできる:</p>
<pre><code class="language-lean"><span class="boring">variable (f : Nat → Nat)
</span><span class="boring">variable (h : ∀ x : Nat, f x ≤ f (x + 1))
</span>example : f 0 ≤ f 3 :=
  have : f 0 ≤ f 1 := h 0
  have : f 0 ≤ f 2 := Nat.le_trans (by assumption) (h 1)
  show f 0 ≤ f 3 from Nat.le_trans (by assumption) (h 2)
</code></pre>
<p><code>by assumption</code> はLeanに <code>assumption</code> タクティクを使うように指示し、<code>assumption</code> タクティクはローカルなコンテキストで適切な前提命題(の証明項)を見つけることでゴールを証明する。<code>assumption</code> タクティクについては次の章で詳しく説明する。</p>
<p><code>‹p›</code> と書くことで、Leanに証明を埋めるよう頼むこともできる。ここで、<code>‹p›</code> はLeanにコンテキストから証明を見つけてもらいたい命題である。この角ばった括弧はそれぞれ <code>\f&lt;</code> と <code>\f&gt;</code> と打つと入力できる。&quot;f&quot; は &quot;フランス語&quot; を意味する。なぜならこのunicode記号はフランス語における引用符としても使われるからである。この表記はLeanにおいて次のように定義されている:</p>
<pre><code class="language-lean">notation &quot;‹&quot; p &quot;›&quot; =&gt; show p by assumption
</code></pre>
<p>このアプローチは、推論してほしい前提の型が明示的に与えられるため、<code>by assumption</code> を用いるよりもロバストである。また、証明も読みやすくなる。以下は、より詳細な例である:</p>
<pre><code class="language-lean">variable (f : Nat → Nat)
variable (h : ∀ x : Nat, f x ≤ f (x + 1))

example : f 0 ≥ f 1 → f 1 ≥ f 2 → f 0 = f 2 :=
  fun _ : f 0 ≥ f 1 =&gt;
  fun _ : f 1 ≥ f 2 =&gt;
  have : f 0 ≥ f 2 := Nat.le_trans ‹f 1 ≥ f 2› ‹f 0 ≥ f 1›
  have : f 0 ≤ f 2 := Nat.le_trans (h 0) (h 1)
  show f 0 = f 2 from Nat.le_antisymm this ‹f 0 ≥ f 2›
</code></pre>
<p>フランス語の引用符は、名無しで導入されたものだけでなくコンテキスト中の「あらゆるもの」を参照できることを覚えておこう。フランス語の引用符の適用範囲は命題だけにとどまらないが、これをデータに対して使うのはやや奇妙である:</p>
<pre><code class="language-lean">example (n : Nat) : Nat := ‹Nat›
</code></pre>
<p>以降の章で、Leanのマクロシステムを使って証明言語を拡張する方法を紹介する。</p>
<h2 id="exercises-練習問題-1"><a class="header" href="#exercises-練習問題-1">Exercises (練習問題)</a></h2>
<ol>
<li>以下の命題を証明せよ:</li>
</ol>
<pre><code class="language-lean">variable (α : Type) (p q : α → Prop)

example : (∀ x, p x ∧ q x) ↔ (∀ x, p x) ∧ (∀ x, q x) := sorry
example : (∀ x, p x → q x) → (∀ x, p x) → (∀ x, q x) := sorry
example : (∀ x, p x) ∨ (∀ x, q x) → ∀ x, p x ∨ q x := sorry
</code></pre>
<p>最後の例について、逆の命題が導出できないのはなぜかを理解してみよう。</p>
<ol start="2">
<li>式の一部が全称量化された変数に依存しない場合、それを全称量化子の外側に持ってくることはしばしば可能である。以下の命題を証明してみよう(このうち2つ目の命題の1方向は古典論理を必要とする):</li>
</ol>
<pre><code class="language-lean">variable (α : Type) (p q : α → Prop)
variable (r : Prop)

example : α → ((∀ x : α, r) ↔ r) := sorry
example : (∀ x, p x ∨ r) ↔ (∀ x, p x) ∨ r := sorry
example : (∀ x, r → p x) ↔ (r → ∀ x, p x) := sorry
</code></pre>
<ol start="3">
<li>「理髪師のパラドックス」について考えてみよう。これは、ある町において、「自分で髭を剃らない男性全員の髭を剃り、自分で髭を剃る男性の髭は一切剃らない男性の理髪師がいる」という主張である。この主張が矛盾することを示せ:</li>
</ol>
<pre><code class="language-lean">variable (men : Type) (barber : men)
variable (shaves : men → men → Prop)

example (h : ∀ x : men, shaves barber x ↔ ¬ shaves x x) : False := sorry
</code></pre>
<ol start="4">
<li>パラメータを持たない <code>Prop</code> 型の項は(それが真か偽かを問わない)単なる主張である。まず以下の <code>prime</code> と <code>Fermat_prime</code> の定義を埋め、それらを使って他の定義を構築せよ。例えば、任意の自然数 <code>n</code> に対して、<code>n</code> より大きな素数が存在すると主張することで、素数は無限に存在すると言うことができる。弱いゴールドバッハ予想は、5より大きい任意の奇数は3つの素数の和で表されることを主張している。必要であれば、フェルマー素数や他の記述の定義を調べてみよう。</li>
</ol>
<pre><code class="language-lean">def even (n : Nat) : Prop := sorry

def prime (n : Nat) : Prop := sorry

def infinitely_many_primes : Prop := sorry

def Fermat_prime (n : Nat) : Prop := sorry

def infinitely_many_Fermat_primes : Prop := sorry

def goldbach_conjecture : Prop := sorry

def Goldbach's_weak_conjecture : Prop := sorry

def Fermat's_last_theorem : Prop := sorry
</code></pre>
<ol start="5">
<li>存在量化子の節で列挙した恒真式をできるだけ多く証明せよ。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tactics-タクティク"><a class="header" href="#tactics-タクティク">Tactics (タクティク)</a></h1>
<p>この章では、<em>tactics</em>(タクティク)を使って証明を構築する方法について説明する。証明項とは数学的証明の表現であり、タクティクは数学的証明を構築する手順を記述するコマンド(指示)である。定理 A ↔ B を証明する際に、非形式的に、「まず A → B を証明する。最初に定義を展開し、次に既存の補題を適用し、それから式を単純化する」という導入から数学の証明を始めることがあるかもしれない。これらの言明が証明を見つける方法を読者に伝える指示であるのと同様に、タクティクは証明項を構築する方法をLeanに伝える指示である。タクティクは、証明を分解し、一歩ずつゴールに向かうという段階的な証明の書き方を自然にサポートする。</p>
<p>タクティクの連続からなる証明を「タクティクスタイル」の証明と呼び、これまで見てきた証明項の構築の仕方を「項スタイル」の証明と呼ぶ。それぞれのスタイルには長所と短所がある。例えば、タクティクスタイルの証明は、各タクティクの結果を予測・推測することを読者に要求するため、項スタイルの証明より読みにくいという短所がある。しかし、短くて書きやすいという長所もある。さらに、タクティクはLeanの自動証明を利用するための入り口になる。なぜなら、Leanに自動証明を指示するコマンド自体がタクティクだからである。</p>
<h2 id="用語に関する注意"><a class="header" href="#用語に関する注意">用語に関する注意</a></h2>
<p>この節は翻訳に際して追加した節である。</p>
<p>この章では、含意命題 <code>p → q</code> あるいはより一般的に依存関数型 <code>(x : α) → β</code> の中に登場する型 <code>p</code> や型 <code>(x : α)</code> を「前件(antecedent)」、型 <code>q</code> や型 <code>β</code> を「後件(consequent)」と呼び、一方で「ゴール(Goal)」 <code>A ⊢ B</code> の中に登場する項の集まり A を「コンテキスト(Context)」または「前提(Premise)」、ゴールにおいて項構築の目標となる型 B を「ターゲット(Target)」または「結論(Conclusion)」と呼び明確に区別する。特に、ゴールが閉じられていない(open)／未達成(not accomplished)／未証明(not proved)／未解決(not solved)のときは「コンテキスト(Context)」「ターゲット(Target)」という用語を使い、ゴールが閉じられている(closed)／達成済み(accomplished)／証明済み(proved)／解決済(solved)のときは「前提(Premise)」「結論(Conclusion)」という用語を使う。</p>
<p>コンテキスト(あるいは前提)に含まれる各項を「仮説(Hypothesis)」と呼ぶ。</p>
<p>ここでいう「ターゲット」を「ゴール」と呼ぶこともあるが、混乱を避けるため本訳ではこのような用語の使い方はしない。</p>
<p><code>intro</code> タクティクや <code>revert</code> タクティクの働きを理解する際に、この用語の区別が重要となる。</p>
<h3 id="参考記事"><a class="header" href="#参考記事">参考記事</a></h3>
<ul>
<li><a href="https://m-hiyama-memo.hatenablog.com/entry/2023/01/30/130823">コンテキストと組織化原理 - (新) 檜山正幸のキマイラ飼育記 メモ編</a></li>
<li><a href="https://m-hiyama-memo.hatenablog.com/entry/2023/01/22/130943">証明とリーズニング - (新) 檜山正幸のキマイラ飼育記 メモ編</a></li>
</ul>
<h2 id="entering-tactic-mode-タクティクモードへの入り方"><a class="header" href="#entering-tactic-mode-タクティクモードへの入り方">Entering Tactic Mode (タクティクモードへの入り方)</a></h2>
<p>定理を述べたり、have文を使うと、ゴール、すなわち期待された型を持つ項を構築するという目標が生成される。例えば、仮説 <code>p q : Prop</code>、<code>hp : p</code>、<code>hq : q</code> を持つコンテキストでは、次のような記述は <code>p ∧ q ∧ p</code> という型の項を構築するというゴールを作成する:</p>
<pre><code class="language-lean">theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p :=
  sorry
</code></pre>
<p>このゴールは次のように記述できる:</p>
<pre><code>    p : Prop, q : Prop, hp : p, hq : q ⊢ p ∧ q ∧ p
</code></pre>
<p>実際、上記の例で &quot;sorry&quot; をアンダースコアに置き換えると、Leanはまさにこのゴールが未解決であることを報告する。</p>
<p>通常は、明示的に証明項を記述することでこのようなゴールを達成する。しかし、Leanでは、項が記述されることが期待される任意の場所に、項の記述の代わりに <code>by &lt;tactics&gt;</code> ブロックを挿入することができる。ここで、<code>&lt;tactics&gt;</code> はセミコロンまたは改行で区切られたコマンドの列である。<code>by &lt;tactics&gt;</code> ブロックを使って上記の定理を証明することができる:</p>
<pre><code class="language-lean">theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p :=
  by apply And.intro
     exact hp
     apply And.intro
     exact hq
     exact hp
</code></pre>
<p>つまり、<code>by</code> キーワードを書くことでタクティクモードに入れるのである。しばしば <code>by</code> キーワードは前の行に書き、上記の例はこのように書かれる:</p>
<pre><code class="language-lean">theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p := by
  apply And.intro
  exact hp
  apply And.intro
  exact hq
  exact hp
</code></pre>
<p><code>apply</code> タクティクは、0個以上の引数をとる関数を表現する項 <code>t</code> を現在のゴールに適用する。<code>apply</code> タクティクは現在のゴールのターゲット(<code>⊢</code> の後に書かれる型)と関数 <code>t</code> の出力の型を同一視し、引数(関数 <code>t</code> の入力の型を持つ項)を構築するという新しいゴールを作る。ただし、後続の引数の型が先行の引数に依存しない場合に限る。上記の例では、コマンド <code>apply And.intro</code> は2つのサブゴールを生成する:</p>
<pre><code>    case left
    p q : Prop
    hp : p
    hq : q
    ⊢ p

    case right
    p q : Prop
    hp : p
    hq : q
    ⊢ q ∧ p
</code></pre>
<p>最初のゴールはコマンド <code>exact hp</code> で達成される。<code>exact</code> コマンドは <code>apply</code> コマンドの一種で、「与えられた項がターゲットと同じ型を持つことを確認し、確認できたらゴールを閉じよ」とLeanに指示する。<code>exact</code> コマンドをタクティク証明で使うのは良いことである。なぜなら、<code>exact</code> コマンドの失敗は何かが間違っていることを示すからである。また <code>exact</code> は <code>apply</code> よりもロバストである。なぜなら、elaboratorは、与えられた項を処理する際に、今期待されている型(ゴールのターゲット)が何であるかを考慮に入れるからである。しかしながら、上記の例では <code>apply</code> も同様に機能する。</p>
<p><code>#print</code> コマンドを使って最終的に得られた証明項を確認することができる:</p>
<pre><code class="language-lean"><span class="boring">theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p := by
</span><span class="boring"> apply And.intro
</span><span class="boring"> exact hp
</span><span class="boring"> apply And.intro
</span><span class="boring"> exact hq
</span><span class="boring"> exact hp
</span>#print test
/-
theorem test : ∀ (p q : Prop), p → q → p ∧ q ∧ p :=
fun p q hp hq =&gt; { left := hp, right := { left := hq, right := hp } }
-/
</code></pre>
<p>タクティク証明は段階的に書くことができる。VS Codeでは、<code>Ctrl-Shift-Enter</code> を押すことでメッセージウィンドウを開くことができる。カーソルがタクティクブロック内にあるときはいつでも、このウィンドウは現在のゴールを表示する。Emacsでは、タクティクブロック内の任意の行末で <code>C-c C-g</code> を押すことで現在のゴールを見ることができる。また、カーソルを最後のタクティクの1文字目に置くことで、不完全な証明内の残りのゴールを見ることができる。証明が不完全な場合、キーワード <code>by</code> に赤い波線が引かれ、エラーメッセージには残りのゴールが表示される。</p>
<p>タクティクコマンドは単一の項名だけでなく、複合式を受け取ることもできる。以下は、前述の証明の短縮版である:</p>
<pre><code class="language-lean">theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p := by
  apply And.intro hp
  exact And.intro hq hp
</code></pre>
<p>当然のことながら、この証明記述は全く同じ証明項を生成する。</p>
<pre><code class="language-lean"><span class="boring">theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p := by
</span><span class="boring"> apply And.intro hp
</span><span class="boring"> exact And.intro hq hp
</span>#print test
</code></pre>
<p>複数のタクティク適用をセミコロンで連結して1行で書くことができる。</p>
<pre><code class="language-lean">theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p := by
  apply And.intro hp; exact And.intro hq hp
</code></pre>
<p>複数のサブゴールを生成する可能性のあるタクティクは、自動的に各サブゴールにタグを付けることが多い。例えば、タクティク <code>apply And.intro</code> は最初のサブゴールにタグ <code>left</code> を、2つ目のサブゴールにタグ <code>right</code> を付ける。この場合において、タグ名は <code>And.intro</code> の宣言の中で使われた引数の名前から推測される。<code>case &lt;tag&gt; =&gt; &lt;tactics&gt;</code> という表記を使うことで、タクティクを構造化することができる。つまり、<code>&lt;tactics&gt;</code> をどのタグ付けされたサブゴールに適用するかを明示することができる。以下は、この章の最初のタクティク証明の構造化されたバージョンである:</p>
<pre><code class="language-lean">theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p := by
  apply And.intro
  case left =&gt; exact hp
  case right =&gt;
    apply And.intro
    case left =&gt; exact hq
    case right =&gt; exact hp
</code></pre>
<p><code>case</code> 記法を使うと、サブゴール <code>right</code> を <code>left</code> よりも先に解くことができる:</p>
<pre><code class="language-lean">theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p := by
  apply And.intro
  case right =&gt;
    apply And.intro
    case left =&gt; exact hq
    case right =&gt; exact hp
  case left =&gt; exact hp
</code></pre>
<p><code>case</code> ブロック内で、Leanが他のゴールを隠していることに注意してほしい。言わば、Leanは選択されたゴールに「集中」しているのである。さらに、<code>case</code> ブロックの終了時に選択されたゴールが完全には解かれていない場合、Leanはエラーフラグを建てる。</p>
<p>サブゴールが単純である場合、タグを使ってサブゴールを選択する価値はないかもしれないが、その場合でも証明を構造化したい場合は <code>case</code> が有用である。また、Leanは証明を構造化するための「箇条書き」記法 <code>. &lt;tactics&gt;</code> (あるいは <code>· &lt;tactics&gt;</code>) を提供する。<code>. &lt;tactics&gt;</code> 記法を使うと、Leanは一番上のゴールに「集中」する。</p>
<pre><code class="language-lean">theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p := by
  apply And.intro
  . exact hp
  . apply And.intro
    . exact hq
    . exact hp
</code></pre>
<h2 id="basic-tactics-基本的なタクティク"><a class="header" href="#basic-tactics-基本的なタクティク">Basic Tactics (基本的なタクティク)</a></h2>
<p><code>apply</code> と <code>exact</code> に加えて、もう一つの便利なタクティクが <code>intro</code> である。<code>intro</code> タクティクはゴールのターゲットの前件(ゴールのターゲットの <code>→</code> の前にある命題)をゴールのコンテキスト(ゴールの <code>⊢</code> の前)に移動させる。以降、この <code>intro</code> タクティクの機能を「ターゲットの前件をコンテキストに導入する」または単に「導入する」と表現する。以下は、3章で証明した命題論理の恒真式を今一度タクティクを使って証明した例である。</p>
<pre><code class="language-lean">example (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := by
  apply Iff.intro
  . intro h
    apply Or.elim (And.right h)
    . intro hq
      apply Or.inl
      apply And.intro
      . exact And.left h
      . exact hq
    . intro hr
      apply Or.inr
      apply And.intro
      . exact And.left h
      . exact hr
  . intro h
    apply Or.elim h
    . intro hpq
      apply And.intro
      . exact And.left hpq
      . apply Or.inl
        exact And.right hpq
    . intro hpr
      apply And.intro
      . exact And.left hpr
      . apply Or.inr
        exact And.right hpr
</code></pre>
<p><code>intro</code> タクティクはより一般的に任意の型の項をコンテキストに導入できる:</p>
<pre><code class="language-lean">example (α : Type) : α → α := by
  intro a
  exact a

example (α : Type) : ∀ x : α, x = x := by
  intro x
  exact Eq.refl x
</code></pre>
<p><code>intro</code> タクティクは複数の項を一度に導入できる:</p>
<pre><code class="language-lean">example : ∀ a b c : Nat, a = b → a = c → c = b := by
  intro a b c h₁ h₂
  exact Eq.trans (Eq.symm h₂) h₁
</code></pre>
<p><code>apply</code> タクティクが対話的に関数適用を構築するためのコマンドであるように、<code>intro</code> タクティクは対話的に関数抽象(つまり <code>fun x =&gt; e</code> の形の項)を構築するためのコマンドである。ラムダ抽象記法と同様に、<code>intro</code> タクティクでは暗黙の <code>match</code> を使うことができる。</p>
<pre><code class="language-lean">example (α : Type) (p q : α → Prop) : (∃ x, p x ∧ q x) → ∃ x, q x ∧ p x := by
  intro ⟨w, hpw, hqw⟩
  exact ⟨w, hqw, hpw⟩
</code></pre>
<p>また、<code>intro</code> タクティクは <code>match</code> 式のようにコンテキストに導入した項を場合分けすることもできる(詳しくは<a href="./induction_and_recursion.html">8章 Induction and Recursion (帰納と再帰)</a>を参照のこと)。</p>
<pre><code class="language-lean">example (α : Type) (p q : α → Prop) : (∃ x, p x ∨ q x) → ∃ x, q x ∨ p x := by
  intro
  | ⟨w, Or.inl h⟩ =&gt; exact ⟨w, Or.inr h⟩
  | ⟨w, Or.inr h⟩ =&gt; exact ⟨w, Or.inl h⟩

example (α : Type) (p q : α → Prop) : (∃ x, p x ∨ q x) → ∃ x, q x ∨ p x := by
  intro h
  let ⟨w, hpq⟩ := h
  exact Or.elim hpq (fun hp : p w =&gt; ⟨w, Or.inr hp⟩) (fun hq : q w =&gt; ⟨w, Or.inl hq⟩)
</code></pre>
<p><code>intros</code> タクティクは引数を与えずに使うことができる。その場合、<code>intros</code> タクティクはできる限り多くの項を一度に導入し、導入した各項に自動で名前を付ける。その例はすぐ後に紹介する。</p>
<p><code>assumption</code> タクティクは現在のゴールの仮説たちに目を通し、それらの中にゴールのターゲットと合致するものがあればそれを適用する。</p>
<pre><code class="language-lean">example (x y z w : Nat) (h₁ : x = y) (h₂ : y = z) (h₃ : z = w) : x = w := by
  apply Eq.trans h₁
  apply Eq.trans h₂
  assumption   -- applied h₃
</code></pre>
<p><code>assumption</code> タクティクは、必要に応じてゴールのターゲット内のメタ変数( <code>?b</code> など、どんな項が代入されるかが未決定の変数)を解決する(メタ変数に具体的な項を代入する):</p>
<pre><code class="language-lean">example (x y z w : Nat) (h₁ : x = y) (h₂ : y = z) (h₃ : z = w) : x = w := by
  apply Eq.trans
  assumption      -- solves x = ?b with h₁
  apply Eq.trans
  assumption      -- solves y = ?h₂.b with h₂
  assumption      -- solves z = w with h₃
</code></pre>
<p>次の例では、<code>intros</code> タクティクを用いて3つの変数と2つの命題の証明を自動的にコンテキストに導入している:</p>
<pre><code class="language-lean">example : ∀ a b c : Nat, a = b → a = c → c = b := by
  intros
  apply Eq.trans
  apply Eq.symm
  assumption
  assumption
</code></pre>
<p>デフォルトでは、Leanが自動生成した名前( <code>a✝</code> など)にはアクセスできないことに注意してほしい。この仕様はタクティク証明の成否が自動生成された名前に依存しないようにするためにあり、この仕様があるおかげで証明はよりロバストになる。ただし、キーワード <code>unhygienic</code> を <code>by</code> の後に書くことでこの制限を無効にすることができる(証明のロバスト性は低下する)。</p>
<pre><code class="language-lean">example : ∀ a b c : Nat, a = b → a = c → c = b := by unhygienic
  intros
  apply Eq.trans
  apply Eq.symm
  exact a_2
  exact a_1
</code></pre>
<p>また、<code>rename_i</code> タクティクを用いて、現在のゴール内の最も直近のアクセス不能な名前を変更することができる。次の例では、タクティク <code>rename_i h1 _ h2</code> がゴール内の最後の3つの仮説のうち2つの名前を変更している。</p>
<pre><code class="language-lean">example : ∀ a b c d : Nat, a = b → a = d → a = c → c = b := by
  intros
  rename_i h1 _ h2
  apply Eq.trans
  apply Eq.symm
  exact h2
  exact h1
</code></pre>
<p><code>rfl</code> タクティクは <code>exact rfl</code> の、つまり <code>exact Eq.refl _</code> の糖衣構文である。</p>
<pre><code class="language-lean">example (y : Nat) : (fun x : Nat =&gt; 0) y = 0 := by
  rfl

example (y : Nat) : (fun x : Nat =&gt; 0) y = 0 := by
  exact Eq.refl _
</code></pre>
<p>タクティクの前に <code>repeat</code> キーワードを書くと、そのタクティクは何度か繰り返し適用される。</p>
<pre><code class="language-lean">example : ∀ a b c : Nat, a = b → a = c → c = b := by
  intros
  apply Eq.trans
  apply Eq.symm
  repeat assumption
</code></pre>
<p><code>revert</code> タクティクは時々有用である。これは <code>intro</code> タクティクの逆の機能を持つ。つまり、指定した項をゴールのコンテキストからゴールのターゲットの前件に移動させる。以降、<code>revert</code> タクティクの機能を「コンテキストの一部をターゲットに戻す」または単に「戻す」と表現する。</p>
<pre><code class="language-lean">example (x : Nat) : x = x := by
  revert x
  -- goal is ⊢ ∀ (x : Nat), x = x
  intro y
  -- goal is y : Nat ⊢ y = y
  rfl
</code></pre>
<p>(この章の最初に書いたように用語の区別をしていれば明らかなことだが、)コンテキスト(の一部)をターゲットに移すと含意命題が得られる:</p>
<pre><code class="language-lean">example (x y : Nat) (h : x = y) : y = x := by
  revert h
  -- goal is x y : Nat ⊢ x = y → y = x
  intro h₁
  -- goal is x y : Nat, h₁ : x = y ⊢ y = x
  apply Eq.symm
  assumption
</code></pre>
<p>しかし、<code>revert</code> はさらに賢く、指定した項だけでなく、指定した項に依存する型を持つ要素も全てゴールのターゲットに移動させる。例えば、上の例で <code>x</code> を戻すと、<code>h</code> も一緒に戻される:</p>
<pre><code class="language-lean">example (x y : Nat) (h : x = y) : y = x := by
  revert x
  -- goal is y : Nat ⊢ ∀ (x : Nat), x = y → y = x
  intros
  apply Eq.symm
  assumption
</code></pre>
<p>また、コンテキスト内の複数の仮説を一度に戻すこともできる:</p>
<pre><code class="language-lean">example (x y : Nat) (h : x = y) : y = x := by
  revert x y
  -- goal is ⊢ ∀ (x y : Nat), x = y → y = x
  intros
  apply Eq.symm
  assumption
</code></pre>
<p><code>revert</code> で戻せるのは現在のゴールのコンテキスト内の項(仮説)だけである。しかし、タクティク <code>generalize e = x</code> を使えば、ゴールのターゲットに登場する任意の式 <code>e</code> を新しい変数 <code>x</code> に置き換えることができる。また、タクティク <code>generalize e = x at h₁</code> を使えば、ゴールの仮説 <code>h₁</code> に登場する任意の式 <code>e</code> を新しい変数 <code>x</code> に置き換えることができる。</p>
<pre><code class="language-lean">example : 3 = 3 := by
  generalize 3 = x
  -- goal is x : Nat ⊢ x = x
  revert x
  -- goal is ⊢ ∀ (x : Nat), x = x
  intro y
  -- goal is y : Nat ⊢ y = y
  rfl
</code></pre>
<p>上記の例において、<code>generalize 3 = x</code> は <code>3</code> に任意の変数 <code>x</code> を割り当てることでゴールのターゲットを一般化している。全ての一般化がゴールの証明可能性を保存するわけではないことに注意してほしい。次の例では、<code>generalize</code> が <code>rfl</code> を使うだけで証明できるゴールを決して証明できないゴールに置き換えている:</p>
<pre><code class="language-lean">example : 2 + 3 = 5 := by
  generalize 3 = x
  -- goal is x : Nat ⊢ 2 + x = 5
  admit
</code></pre>
<p><code>admit</code> タクティクは <code>exact sorry</code> の糖衣構文である。これは現在のゴールを閉じ、<code>sorry</code> が使われたという警告を出す。一般化以前のゴールの証明可能性を保存するために、<code>generalize</code> タクティクを使う際に <code>3</code> が <code>x</code> に置き換えられたという事実を記録することができる。そのためには、置き換えの事実を保存するためのラベルを <code>generalize</code> に与えるだけでよい:</p>
<pre><code class="language-lean">example : 2 + 3 = 5 := by
  generalize h : 3 = x
  -- goal is x : Nat, h : 3 = x ⊢ 2 + x = 5
  rw [← h]
</code></pre>
<p>ここでは、<code>rewrite</code> タクティク(略称は <code>rw</code>)が <code>h</code> を用いて <code>x</code> を <code>3</code> で再び置き換えている。<code>rewrite</code> タクティクについては後述する。</p>
<h2 id="more-tactics-他のタクティク"><a class="header" href="#more-tactics-他のタクティク">More Tactics (他のタクティク)</a></h2>
<p>命題やデータを構築したり分解したりするには、他のいくつかのタクティクが有用である。例えば、<code>p ∨ q</code> の形のターゲットに対して <code>apply</code> タクティクを使う場合は、タクティク <code>apply Or.inl</code> や <code>apply Or.inr</code> を使うだろう。逆に、<code>cases</code> タクティクは選言命題型(など)の仮説を分解する。</p>
<pre><code class="language-lean">example (p q : Prop) : p ∨ q → q ∨ p := by
  intro h
  cases h with
  | inl hp =&gt; apply Or.inr; exact hp
  | inr hq =&gt; apply Or.inl; exact hq
</code></pre>
<p><code>cases</code> タクティクの構文は <code>match</code> 式の構文と似ていることに注意。新しいサブゴールは好きな順番で解くことができる。</p>
<pre><code class="language-lean">example (p q : Prop) : p ∨ q → q ∨ p := by
  intro h
  cases h with
  | inr hq =&gt; apply Or.inl; exact hq
  | inl hp =&gt; apply Or.inr; exact hp
</code></pre>
<p><code>with</code> と後続のタクティクを書かずに(構造化されていない) <code>cases</code> を使うこともできる。この場合、複数のサブゴールが生成される。</p>
<pre><code class="language-lean">example (p q : Prop) : p ∨ q → q ∨ p := by
  intro h
  cases h
  apply Or.inr
  assumption
  apply Or.inl
  assumption
</code></pre>
<p>(構造化されていない) <code>cases</code> は、同じタクティクを使って複数のサブゴールを閉じられる場合に特に便利である。</p>
<pre><code class="language-lean">example (p : Prop) : p ∨ p → p := by
  intro h
  cases h
  repeat assumption
</code></pre>
<p><code>tac1 &lt;;&gt; tac2</code> という結合子を使えば、タクティク <code>tac1</code> により生成された各サブゴールに <code>tac2</code> を適用することもできる。</p>
<pre><code class="language-lean">example (p : Prop) : p ∨ p → p := by
  intro h
  cases h &lt;;&gt; assumption
</code></pre>
<p>構造化されていない <code>cases</code> タクティクと <code>case</code> 記法や <code>.</code> 記法を組み合わせることができる。</p>
<pre><code class="language-lean">example (p q : Prop) : p ∨ q → q ∨ p := by
  intro h
  cases h
  . apply Or.inr
    assumption
  . apply Or.inl
    assumption

example (p q : Prop) : p ∨ q → q ∨ p := by
  intro h
  cases h
  case inr h =&gt;
    apply Or.inl
    assumption
  case inl h =&gt;
    apply Or.inr
    assumption

example (p q : Prop) : p ∨ q → q ∨ p := by
  intro h
  cases h
  case inr h =&gt;
    apply Or.inl
    assumption
  . apply Or.inr
    assumption
</code></pre>
<p><code>cases</code> タクティクは連言命題を分解することもできる。</p>
<pre><code class="language-lean">example (p q : Prop) : p ∧ q → q ∧ p := by
  intro h
  cases h with
  | intro hp hq =&gt; constructor; exact hq; exact hp

example (p q : Prop) : p ∧ q → q ∧ p := by
  intro h
  cases h with
  | intro hp hq =&gt; apply And.intro; exact hq; exact hp
</code></pre>
<p>この例では、<code>cases</code> タクティクにより <code>h : p ∧ q</code> が一対の項 <code>hp : p</code> と <code>hq : q</code> に置き換えられた。<code>constructor</code> タクティクは、連言のための唯一のコンストラクタ <code>And.intro</code> をターゲットに適用する。これらのタクティクにより、前節の例は以下のように書き換えられる:</p>
<pre><code class="language-lean">example (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := by
  apply Iff.intro
  . intro h
    cases h with
    | intro hp hqr =&gt;
      cases hqr
      . apply Or.inl; constructor &lt;;&gt; assumption
      . apply Or.inr; constructor &lt;;&gt; assumption
  . intro h
    cases h with
    | inl hpq =&gt;
      cases hpq with
      | intro hp hq =&gt; constructor; exact hp; apply Or.inl; exact hq
    | inr hpr =&gt;
      cases hpr with
      | intro hp hr =&gt; constructor; exact hp; apply Or.inr; exact hr
</code></pre>
<p>これらのタクティクを非常に一般的に用いることができることは、<a href="./inductive_types.html">7章 Inductive Types (帰納型)</a>で説明する。端的に説明すると、<code>cases</code> タクティクは帰納的に定義された型の任意の項を分解することができる。<code>constructor</code> タクティクは常に、帰納的に定義された型の適用可能な最初のコンストラクタを適用する。例えば、<code>cases</code> と <code>constructor</code> は存在量化子に対して使うことができる:</p>
<pre><code class="language-lean">example (p q : Nat → Prop) : (∃ x, p x) → ∃ x, p x ∨ q x := by
  intro h
  cases h with
  | intro x px =&gt; constructor; apply Or.inl; exact px

example (p q : Nat → Prop) : (∃ x, p x) → ∃ x, p x ∨ q x := by
  intro h
  cases h with
  | intro x px =&gt; apply Exists.intro; apply Or.inl; exact px
</code></pre>
<p>ここでは、<code>constructor</code> タクティクは <code>Exists.intro</code> の最初の引数である <code>x</code> の値を暗黙のままにしている。これは一旦メタ変数で表され、そのメタ変数の値は後で決定される。前の例では、メタ変数の適切な値はタクティク <code>exact px</code> が使われた時点で決定される。なぜなら、<code>px</code> は型 <code>p x</code> を持つからである。存在量化子に対する証人を明示的に指定したい場合は、代わりに <code>exists</code> タクティクを使うことができる:</p>
<pre><code class="language-lean">example (p q : Nat → Prop) : (∃ x, p x) → ∃ x, p x ∨ q x := by
  intro h
  cases h with
  | intro x px =&gt; exists x; apply Or.inl; exact px
</code></pre>
<p>これは他の例である:</p>
<pre><code class="language-lean">example (p q : Nat → Prop) : (∃ x, p x ∧ q x) → ∃ x, q x ∧ p x := by
  intro h
  cases h with
  | intro x hpq =&gt;
    cases hpq with
    | intro hp hq =&gt;
      exists x
</code></pre>
<p><code>cases</code> タクティクや<code>constructor</code> タクティクは命題だけでなくデータにも使える。次の例では、直積型の項の成分を入れ替える関数と直和型の項の成分を入れ替える関数を定義するためにこれらのタクティクが使われている:</p>
<pre><code class="language-lean">def swap_pair : α × β → β × α := by
  intro p
  cases p
  constructor &lt;;&gt; assumption

def swap_sum : Sum α β → Sum β α := by
  intro p
  cases p
  . apply Sum.inr; assumption
  . apply Sum.inl; assumption

theorem swap_and : a ∧ b → b ∧ a := by
  intro p
  cases p
  constructor &lt;;&gt; assumption

theorem swap_or : a ∨ b → b ∨ a := by
  intro p
  cases p
  . apply Or.inr; assumption
  . apply Or.inl; assumption
</code></pre>
<p>上2つの関数定義の記述と、下2つの定理の証明が、わずかな差を除いて同じであることに注意してほしい。</p>
<p><code>cases</code> タクティクは自然数を「場合分け」することもできる:</p>
<pre><code class="language-lean">open Nat
example (P : Nat → Prop) (h₀ : P 0) (h₁ : ∀ n, P (succ n)) (m : Nat) : P m := by
  cases m with
  | zero    =&gt; exact h₀
  | succ m' =&gt; exact h₁ m'
</code></pre>
<p><code>cases</code> タクティクとその仲間である <code>induction</code> タクティクについては、<a href="./inductive_types.html#tactics-for-inductive-types-%E5%B8%B0%E7%B4%8D%E5%9E%8B%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AE%E3%82%BF%E3%82%AF%E3%83%86%E3%82%A3%E3%82%AF">Tactics for Inductive Types (帰納型のためのタクティク)</a>節で詳しく説明する。</p>
<p><code>contradiction</code> タクティクは現在のゴールのコンテキストの中から矛盾を探す:</p>
<pre><code class="language-lean">example (p q : Prop) : p ∧ ¬ p → q := by
  intro h
  cases h
  contradiction
</code></pre>
<p><code>match</code> はタクティクブロック内でも使うことができる。</p>
<pre><code class="language-lean">example (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := by
  apply Iff.intro
  . intro h
    match h with
    | ⟨_, Or.inl _⟩ =&gt; apply Or.inl; constructor &lt;;&gt; assumption
    | ⟨_, Or.inr _⟩ =&gt; apply Or.inr; constructor &lt;;&gt; assumption
  . intro h
    match h with
    | Or.inl ⟨hp, hq⟩ =&gt; constructor; exact hp; apply Or.inl; exact hq
    | Or.inr ⟨hp, hr⟩ =&gt; constructor; exact hp; apply Or.inr; exact hr
</code></pre>
<p><code>intro h</code> を <code>match h ...</code> と「組み合わせる」と、上記の例は次のように書ける:</p>
<pre><code class="language-lean">example (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := by
  apply Iff.intro
  . intro
    | ⟨hp, Or.inl hq⟩ =&gt; apply Or.inl; constructor &lt;;&gt; assumption
    | ⟨hp, Or.inr hr⟩ =&gt; apply Or.inr; constructor &lt;;&gt; assumption
  . intro
    | Or.inl ⟨hp, hq⟩ =&gt; constructor; assumption; apply Or.inl; assumption
    | Or.inr ⟨hp, hr⟩ =&gt; constructor; assumption; apply Or.inr; assumption
</code></pre>
<h2 id="structuring-tactic-proofs-タクティク証明の構造化"><a class="header" href="#structuring-tactic-proofs-タクティク証明の構造化">Structuring Tactic Proofs (タクティク証明の構造化)</a></h2>
<p>タクティクはしばしば証明を構築する効率的な方法を提供するが、長いタクティクの列は証明の構造を不明瞭にすることがある。このセクションでは、タクティクスタイルの証明をより読みやすくよりロバストにするために、タクティクスタイルの証明を構造化する方法を説明する。</p>
<p>Leanの証明記述構文の優れている点のひとつは、項スタイルの証明とタクティクスタイルの証明をミックスさせて、その間を自由に行き来できることだ。例えば、<code>apply</code> タクティクや <code>exact</code> タクティクは <code>have</code> や <code>show</code> などを使って書かれた任意の型の項を受け取ることができる。逆に、Leanで任意の項を書くときは、<code>by</code> キーワードを挿入することで、いつでもタクティクモードを呼び出すことができる。以下はその例である:</p>
<pre><code class="language-lean">example (p q r : Prop) : p ∧ (q ∨ r) → (p ∧ q) ∨ (p ∧ r) := by
  intro h
  exact
    have hp : p := h.left
    have hqr : q ∨ r := h.right
    show (p ∧ q) ∨ (p ∧ r) by
      cases hqr with
      | inl hq =&gt; exact Or.inl ⟨hp, hq⟩
      | inr hr =&gt; exact Or.inr ⟨hp, hr⟩
</code></pre>
<p>次はより自然な例である:</p>
<pre><code class="language-lean">example (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := by
  apply Iff.intro
  . intro h
    cases h.right with
    | inl hq =&gt; exact Or.inl ⟨h.left, hq⟩
    | inr hr =&gt; exact Or.inr ⟨h.left, hr⟩
  . intro h
    cases h with
    | inl hpq =&gt; exact ⟨hpq.left, Or.inl hpq.right⟩
    | inr hpr =&gt; exact ⟨hpr.left, Or.inr hpr.right⟩
</code></pre>
<p>実際、<code>show</code> タクティクというものがあり、これは項スタイルの証明の <code>show</code> 式に似ている。これは、タクティクモードの中で、解こうとしているゴールのターゲットの型を宣言するだけのタクティクである。</p>
<pre><code class="language-lean">example (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := by
  apply Iff.intro
  . intro h
    cases h.right with
    | inl hq =&gt;
      show (p ∧ q) ∨ (p ∧ r)
      exact Or.inl ⟨h.left, hq⟩
    | inr hr =&gt;
      show (p ∧ q) ∨ (p ∧ r)
      exact Or.inr ⟨h.left, hr⟩
  . intro h
    cases h with
    | inl hpq =&gt;
      show p ∧ (q ∨ r)
      exact ⟨hpq.left, Or.inl hpq.right⟩
    | inr hpr =&gt;
      show p ∧ (q ∨ r)
      exact ⟨hpr.left, Or.inr hpr.right⟩
</code></pre>
<p>実は、<code>show</code> タクティクは、ゴールのターゲットをdefinitionally equalな他の表現に書き換えるために使うことができる:</p>
<pre><code class="language-lean">example (n : Nat) : n + 1 = Nat.succ n := by
  -- goal is n: Nat ⊢ n + 1 = Nat.succ n
  show Nat.succ n = Nat.succ n
  -- goal is n: Nat ⊢ Nat.succ n = Nat.succ n
  rfl

example (n : Nat) : n + 1 = Nat.succ n := by
  -- goal is n: Nat ⊢ n + 1 = Nat.succ n
  rfl
</code></pre>
<p>項スタイルの証明のときと同様に、<code>have</code> タクティクは、宣言した型の項を作るというサブゴールを導入する:</p>
<pre><code class="language-lean">example (p q r : Prop) : p ∧ (q ∨ r) → (p ∧ q) ∨ (p ∧ r) := by
  intro ⟨hp, hqr⟩
  show (p ∧ q) ∨ (p ∧ r)
  cases hqr with
  | inl hq =&gt;
    have hpq : p ∧ q := And.intro hp hq
    apply Or.inl
    exact hpq
  | inr hr =&gt;
    have hpr : p ∧ r := And.intro hp hr
    apply Or.inr
    exact hpr
</code></pre>
<p>項スタイルの証明のときと同様に、<code>have</code> タクティクでは項に付けるラベルを省略することもできる。その場合、デフォルトのラベル <code>this</code> が使われる:</p>
<pre><code class="language-lean">example (p q r : Prop) : p ∧ (q ∨ r) → (p ∧ q) ∨ (p ∧ r) := by
  intro ⟨hp, hqr⟩
  show (p ∧ q) ∨ (p ∧ r)
  cases hqr with
  | inl hq =&gt;
    have : p ∧ q := And.intro hp hq
    apply Or.inl
    exact this
  | inr hr =&gt;
    have : p ∧ r := And.intro hp hr
    apply Or.inr
    exact this
</code></pre>
<p><code>have</code> タクティクでは型も省略することができる。したがって、<code>have hp := h.left</code> や <code>have hqr := h.right</code> と書くことができる。これらの省略記法を用いると、<code>have</code> タクティクにおいて型とラベルの両方を省略することさえできる。その場合、新しい項にはデフォルトのラベル <code>this</code> が使われる。</p>
<pre><code class="language-lean">example (p q r : Prop) : p ∧ (q ∨ r) → (p ∧ q) ∨ (p ∧ r) := by
  intro ⟨hp, hqr⟩
  cases hqr with
  | inl hq =&gt;
    have := And.intro hp hq
    apply Or.inl; exact this
  | inr hr =&gt;
    have := And.intro hp hr
    apply Or.inr; exact this
</code></pre>
<p>Leanには <code>let</code> タクティクもある。これは <code>have</code> タクティクに似ているが、<code>have</code> タクティクが補助的な事実を導入するのに対して、<code>let</code> タクティクは局所的な定義を導入する。これは項スタイルの証明における <code>let</code> に類似したタクティクである。</p>
<pre><code class="language-lean">example : ∃ x, x + 2 = 8 := by
  let a : Nat := 3 * 2
  exists a
</code></pre>
<p><code>have</code> と同様に、<code>let a := 3 * 2</code> と書くことで、型を暗黙のままにすることができる。<code>let</code> と <code>have</code> の違いは、<code>let</code> はコンテキストの中でローカルな定義を導入することである。ローカルに宣言された定義はその証明の中で展開することができる。</p>
<p>先ほど、<code>.</code> を使って入れ子のタクティクブロックを作成した。入れ子のブロックの中では、Leanは最初のゴールに注目し、そのブロックの最後でそのゴールが完全に解決されていなければエラーを生成する。これは、タクティクによって導入された複数のサブゴールを一つ一つ証明するのに便利である。<code>.</code> 記法はインデントに敏感である。なぜなら、インデントを見て各タクティクブロックが終了したかどうかを検知するからである。あるいは、波括弧とセミコロンを使ってタクティクブロックを表すこともできる。</p>
<pre><code class="language-lean">example (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := by
  apply Iff.intro
  { intro h;
    cases h.right;
    { show (p ∧ q) ∨ (p ∧ r);
      exact Or.inl ⟨h.left, ‹q›⟩ }
    { show (p ∧ q) ∨ (p ∧ r);
      exact Or.inr ⟨h.left, ‹r›⟩ } }
  { intro h;
    cases h;
    { show p ∧ (q ∨ r);
      rename_i hpq;
      exact ⟨hpq.left, Or.inl hpq.right⟩ }
    { show p ∧ (q ∨ r);
      rename_i hpr;
      exact ⟨hpr.left, Or.inr hpr.right⟩ } }
</code></pre>
<p>証明を構造化するためにインデントを使うと便利である: タクティクが2つ以上のサブゴールを残すたびに、残りのサブゴールをブロックで囲んでインデントして分離するとよい。もし定理 <code>foo</code> の適用が1つのゴールから4つのサブゴールを生成するなら、証明の見た目は次のようになるだろう:</p>
<pre><code>  apply foo
  . &lt;proof of first goal&gt;
  . &lt;proof of second goal&gt;
  . &lt;proof of third goal&gt;
  . &lt;proof of final goal&gt;
</code></pre>
<p>あるいは</p>
<pre><code>  apply foo
  case &lt;tag of first goal&gt;  =&gt; &lt;proof of first goal&gt;
  case &lt;tag of second goal&gt; =&gt; &lt;proof of second goal&gt;
  case &lt;tag of third goal&gt;  =&gt; &lt;proof of third goal&gt;
  case &lt;tag of final goal&gt;  =&gt; &lt;proof of final goal&gt;
</code></pre>
<p>あるいは</p>
<pre><code>  apply foo
  { &lt;proof of first goal&gt;  }
  { &lt;proof of second goal&gt; }
  { &lt;proof of third goal&gt;  }
  { &lt;proof of final goal&gt;  }
</code></pre>
<h2 id="tactic-combinators-タクティク結合子"><a class="header" href="#tactic-combinators-タクティク結合子">Tactic Combinators (タクティク結合子)</a></h2>
<p><em>Tactic combinators</em>(タクティク結合子) は既存のタクティクから新しいタクティクを作る。逐次結合子 <code>;</code> は <code>by</code> ブロックの中で既に暗黙のうちに使われている:</p>
<pre><code class="language-lean">example (p q : Prop) (hp : p) : p ∨ q :=
  by apply Or.inl; assumption
</code></pre>
<p>ここで、<code>apply Or.inl; assumption</code> はまず単一のタクティク <code>apply Or.inl</code> を使ってから <code>assumption</code> を使うのと機能的に同等である。</p>
<p><code>t₁ &lt;;&gt; t₂</code> において、結合子 <code>&lt;;&gt;</code> は逐次結合子の「パラレル」版である: まず <code>t₁</code> が現在のゴールに適用される。それから <code>t₂</code> がサブゴール「全て」に適用される。</p>
<pre><code class="language-lean">example (p q : Prop) (hp : p) (hq : q) : p ∧ q :=
  by constructor &lt;;&gt; assumption
</code></pre>
<p>この方法は、<code>t₁</code> の適用の結果得られるサブゴールが一様の形式を持つ場合、あるいは少なくとも、全てのゴールを一様な方法で進めることができる場合に特に有効である。</p>
<p><code>first | t₁ | t₂ | ... | tₙ</code> はどれか一つが成功するまで各 <code>tᵢ</code> を適用する。その全てが成功しなかったら失敗する:</p>
<pre><code class="language-lean">example (p q : Prop) (hp : p) : p ∨ q := by
  first | apply Or.inl; assumption | apply Or.inr; assumption

example (p q : Prop) (hq : q) : p ∨ q := by
  first | apply Or.inl; assumption | apply Or.inr; assumption
</code></pre>
<p>最初の例では左のタクティクが成功し、2番目の例では右のタクティクが成功している。次の3つの例では、いずれも同じ複合タクティクにより証明が成功している。</p>
<pre><code class="language-lean">example (p q r : Prop) (hp : p) : p ∨ q ∨ r :=
  by repeat (first | apply Or.inl; assumption | apply Or.inr | assumption)

example (p q r : Prop) (hq : q) : p ∨ q ∨ r :=
  by repeat (first | apply Or.inl; assumption | apply Or.inr | assumption)

example (p q r : Prop) (hr : r) : p ∨ q ∨ r :=
  by repeat (first | apply Or.inl; assumption | apply Or.inr | assumption)

/- repeat と first を使わなかった場合 -/

example (p q r : Prop) (hp : p) : p ∨ q ∨ r :=
  by apply Or.inl; assumption

example (p q r : Prop) (hq : q) : p ∨ q ∨ r :=
  by apply Or.inr
     apply Or.inl; assumption

example (p q r : Prop) (hr : r) : p ∨ q ∨ r :=
  by apply Or.inr
     apply Or.inr
     assumption
</code></pre>
<p>このタクティクはまず選言命題の左側をターゲットにし、それを <code>assumption</code> で解こうとする。それが失敗したら、選言命題の右側に注目する。もしそれも失敗したら、<code>assumption</code> タクティクを呼び出す。</p>
<p>もう気付いているだろうが、タクティクは失敗することがある。実際、<code>first</code> 結合子がバックトラックして次のタクティクを試すのは、一番最初のタクティクが「失敗」したときである。<code>try</code> 結合子は、つまらないかもしれない方法によって、常に成功するタクティクを構築する: <code>try t</code> は <code>t</code> を実行し、たとえ <code>t</code> が失敗しても成功したと報告する。<code>try t</code> は <code>first | t | skip</code> と等価である。ここで、<code>skip</code> は何もせず、そして何もしないことで成功するタクティクである。次の例では、2番目の <code>constructor</code> は連言の右側 <code>q ∧ r</code> については成功するが、連言の左側 <code>p</code> については失敗する (連言と選言は右結合的であることを覚えておこう)。<code>try</code> タクティクは逐次結合されたタクティクが成功することを保証する。</p>
<pre><code class="language-lean">example (p q r : Prop) (hp : p) (hq : q) (hr : r) : p ∧ q ∧ r := by
  constructor &lt;;&gt; (try constructor) &lt;;&gt; assumption
</code></pre>
<p><strong>注意</strong>: <code>try t</code> は決して失敗しないため、<code>repeat (try t)</code> は無限にループする。</p>
<p>証明では、複数のゴールが未解決であることがよくある。並列逐次結合子 <code>&lt;;&gt;</code> は1つのタクティクを複数のゴールに適用する1つの方法だが、他にも方法はある。例えば、<code>all_goals t</code> は全ての未解決のゴールに <code>t</code> を適用する:</p>
<pre><code class="language-lean">example (p q r : Prop) (hp : p) (hq : q) (hr : r) : p ∧ q ∧ r := by
  constructor
  all_goals (try constructor)
  all_goals assumption
</code></pre>
<p>この例では、<code>any_goals</code> タクティクはよりロバストな解を提供する。タクティク <code>any_goals t</code>は <code>all_goals t</code> に似ているが、<code>any_goals t</code> は <code>t</code> が少なくとも1つのゴールで成功すれば成功する。</p>
<pre><code class="language-lean">example (p q r : Prop) (hp : p) (hq : q) (hr : r) : p ∧ q ∧ r := by
  constructor
  any_goals constructor
  any_goals assumption
</code></pre>
<p>次の例において、最初のタクティクは連言命題を繰り返し分解する:</p>
<pre><code class="language-lean">example (p q r : Prop) (hp : p) (hq : q) (hr : r) :
      p ∧ ((p ∧ q) ∧ r) ∧ (q ∧ r ∧ p) := by
  repeat (any_goals constructor)
  all_goals assumption
</code></pre>
<p>実際、上記の例の全てのタクティクを一行に詰め込むことができる:</p>
<pre><code class="language-lean">example (p q r : Prop) (hp : p) (hq : q) (hr : r) :
      p ∧ ((p ∧ q) ∧ r) ∧ (q ∧ r ∧ p) := by
  repeat (any_goals (first | constructor | assumption))
</code></pre>
<p>タクティク <code>focus t</code> は、他のゴールを一時的にスコープから隠し、<code>t</code> を現在のゴール(一番上のゴール)だけに作用させる。したがって、通常は <code>t</code> が現在のゴールだけに作用する場合、<code>focus (all_goals t)</code> は <code>all_goals</code> の機能を打ち消して <code>t</code> と同じ作用を持つ。</p>
<h2 id="rewriting-書き換え"><a class="header" href="#rewriting-書き換え">Rewriting (書き換え)</a></h2>
<p><a href="./quantifiers_and_equality.html#calculational-proofs-%E8%A8%88%E7%AE%97%E7%9A%84%E8%A8%BC%E6%98%8E">Calculational Proofs (計算的証明)</a>の節で、<code>rewrite</code> タクティク(省略版: <code>rw</code>)と <code>simp</code> タクティクを簡単に紹介した。本節と次節では、これらについてさらに詳しく説明する。</p>
<p><code>rewrite</code> タクティクはターゲットとコンテキストに置換を適用するための基本的なメカニズムであり、等式を扱う便利で効率的な方法を提供する。このタクティクの最も基本的な構文は <code>rewrite [t]</code> である。ここで、<code>t</code> はある等式が成立することを主張する型である。例えば、仮説 <code>h : x = y</code> を <code>t</code> として採用することができる。<code>t</code> は <code>add_comm : ∀ x y, x + y = y + x</code> のような全称命題でもよい。その場合、<code>rewrite</code> タクティクは <code>x</code> と <code>y</code> に対して適切な項を見つけようとする。あるいは、それが具体的な等式あるいは等式に関する全称命題であれば、<code>t</code> は関数適用などを含む複合的な項であってもよい。次の例では、仮説を用いてターゲットを書き換えるために基本的な構文 <code>rewrite [t]</code> を使う。</p>
<pre><code class="language-lean">example (f : Nat → Nat) (k : Nat) (h₁ : f 0 = 0) (h₂ : k = 0) : f k = 0 := by
  rw [h₂] -- replace k with 0
  rw [h₁] -- replace f 0 with 0
</code></pre>
<p>上記の例では、最初の <code>rw</code> はターゲット <code>f k = 0</code> 内の <code>k</code> を <code>0</code> に置き換え、2番目の <code>rw</code> はターゲット <code>f 0 = 0</code> 内の <code>f 0</code> を <code>0</code> に置き換えている。このタクティクは <code>t = t</code> という形の任意のゴールを(<code>rfl</code> を使うまでもなく)自動的に閉じる。次は複合的な項を使った書き換えの例である:</p>
<pre><code class="language-lean">example (x y : Nat) (p : Nat → Prop) (q : Prop) (h : q → x = y)
        (h' : p y) (hq : q) : p x := by
  rw [h hq]; assumption
</code></pre>
<p>ここで <code>h hq</code> は <code>x = y</code> の証明を構築している。</p>
<p><code>rw [t_1, ..., t_n]</code> という記法を使って、複数回の書き換えを1つにまとめることができる。これは <code>rw [t_1]; ...; rw [t_n]</code> の略記である。この記法を用いると、先ほどの例は次のように書ける:</p>
<pre><code class="language-lean">example (f : Nat → Nat) (k : Nat) (h₁ : f 0 = 0) (h₂ : k = 0) : f k = 0 := by
  rw [h₂, h₁]
</code></pre>
<p>デフォルトでは、<code>rw</code> は等式を順方向に用いる。つまり、書き換え対象の中で <code>t</code> の左辺とマッチした(全ての)部分項を <code>t</code> の右辺で置き換える。記法 <code>←t</code> を使うと、等式 <code>t</code> を逆向きに使うように指示することができる。つまり、書き換え対象の中で <code>t</code> の右辺とマッチした部分項を <code>t</code> の左辺で置き換えることができる。</p>
<pre><code class="language-lean">example (f : Nat → Nat) (a b : Nat) (h₁ : a = b) (h₂ : f a = 0) : f b = 0 := by
  rw [←h₁, h₂]
</code></pre>
<p>この例では、項 <code>←h₁</code> は <code>b</code> を <code>a</code> に置き換えるよう書き換え器に指示する。エディターでは、<code>\l</code> と打つと <code>←</code> を入力することができる。また、これと等価なアスキー文字列 <code>&lt;-</code> を使うこともできる。</p>
<p>用いる等式が全称命題の場合、等式の左辺が書き換え対象内の複数の部分項とマッチすることがある。例えば、書き換え対象が <code>a + b + c = a + c + b</code> であるとき、<code>rw [Nat.add_comm]</code> は <code>a + b</code> とも <code>a + c</code> とも <code>a + b + c</code> とも <code>a + c + b</code> ともマッチしうる。その場合、<code>rw</code> タクティクは書き換え対象を走査したときに最初にマッチした部分項を書き換える。それが希望するものではない場合は、追加の引数を与えることでマッチさせたい部分項を指定することができる。</p>
<pre><code class="language-lean">example (a b c : Nat) : a + b + c = a + c + b := by
  rw [Nat.add_assoc, Nat.add_comm b, ← Nat.add_assoc]

example (a b c : Nat) : a + b + c = a + c + b := by
  rw [Nat.add_assoc, Nat.add_assoc, Nat.add_comm b]

example (a b c : Nat) : a + b + c = a + c + b := by
  rw [Nat.add_assoc, Nat.add_assoc, Nat.add_comm _ b]
</code></pre>
<p>上記の最初の例では、最初のステップで <code>a + b + c</code> を <code>a + (b + c)</code> に書き換えている。次のステップでは、項 <code>b + c</code> に可換性を適用している。ここで、引数 <code>b</code> を指定しなければ、<code>a + (b + c)</code> が <code>(b + c) + a</code> に書き換えられていただろう。最後に、結合性を逆向きに使うことで <code>a + (c + b)</code> を <code>a + c + b</code> に書き換えている。次の2つの例では、まず結合性を2回使って両辺の括弧を右に寄せ、それから <code>b</code> と <code>c</code> を入れ替えている。最後の例では、<code>Nat.add_comm</code> の第2引数を指定することで、左辺ではなく右辺の書き換えを指示していることに注意してほしい。</p>
<p>デフォルトでは、<code>rw</code> タクティクはゴールのターゲットだけに影響する。<code>rw [t] at h</code> という記法は、仮説 <code>h</code> に <code>t</code> による書き換えを適用する。</p>
<pre><code class="language-lean">example (f : Nat → Nat) (a : Nat) (h : a + 0 = 0) : f a = f 0 := by
  rw [Nat.add_zero] at h
  rw [h]
</code></pre>
<p>最初のステップでは、<code>rw [Nat.add_zero] at h</code> が仮説 <code>h</code> の型を <code>a + 0 = 0</code> から <code>a = 0</code> に書き換えている。それからターゲットを <code>f 0 = f 0</code> に書き換えるために <code>h : a = 0</code> が用いられている。</p>
<p><code>rewrite</code> タクティクは命題だけにとどまらず変数の型を書き換えることもできる。次の例では、<code>rw [h] at t</code> が仮説 <code>t : Tuple α n</code> の型を <code>t : Tuple α 0</code> に書き換えている。</p>
<pre><code class="language-lean">def Tuple (α : Type) (n : Nat) :=
  { as : List α // as.length = n }

example (n : Nat) (h : n = 0) (t : Tuple α n) : Tuple α 0 := by
  rw [h] at t
  exact t
</code></pre>
<h2 id="using-the-simplifier-単純化器の使用"><a class="header" href="#using-the-simplifier-単純化器の使用">Using the Simplifier (単純化器の使用)</a></h2>
<p><code>rewrite</code> タクティクがゴールを操作するために特化したツールとして設計されているのに対し、<em>simplifier</em>(単純化器) はより強力な自動化を提供する。Leanのライブラリには、<code>[simp]</code> 属性が付けられた恒等式が多数収載されており、<code>simp</code> タクティクはそれらを使って単純化対象内の部分項を繰り返し書き換える。</p>
<pre><code class="language-lean">example (x y z : Nat) : (x + 0) * (0 + y * 1 + z * 0) = x * y := by
  simp

example (x y z : Nat) (p : Nat → Prop) (h : p (x * y))
        : p ((x + 0) * (0 + y * 1 + z * 0)) := by
  simp; assumption
</code></pre>
<p>最初の例では、ターゲットの等式の左辺は、0と1を含む普通の恒等式を使って単純化され、ターゲットは <code>x * y = x * y</code> となる。この時点で、<code>simp</code> は反射律を用いてゴールを閉じる。2番目の例では、<code>simp</code> がゴールを <code>p (x * y)</code> に簡約し、その時点で <code>h</code> がゴールを閉じる。次はリストに関する例である:</p>
<pre><code class="language-lean">open List

example (xs : List Nat)
        : reverse (xs ++ [1, 2, 3]) = [3, 2, 1] ++ reverse xs := by
  simp

example (xs ys : List α)
        : length (reverse (xs ++ ys)) = length xs + length ys := by
  simp [Nat.add_comm]
</code></pre>
<p>ここで、<code>simp [t]</code> は <code>[simp]</code> 属性が付けられた恒等式に加えて <code>t</code> を用いて単純化対象を書き換える。</p>
<p><code>rw</code> と同様に、キーワード <code>at</code> を使うとコンテキスト内の仮説を単純化することができる:</p>
<pre><code class="language-lean">example (x y z : Nat) (p : Nat → Prop)
        (h : p ((x + 0) * (0 + y * 1 + z * 0))) : p (x * y) := by
  simp at h; assumption
</code></pre>
<p>さらに、「ワイルドカード」<code>*</code> を使うと、コンテキスト内の全ての仮説とターゲットを単純化することができる:</p>
<pre><code class="language-lean">attribute [local simp] Nat.mul_comm Nat.mul_assoc Nat.mul_left_comm
attribute [local simp] Nat.add_assoc Nat.add_comm Nat.add_left_comm

example (w x y z : Nat) (p : Nat → Prop)
        (h : p (x * y + z * w * x)) : p (x * w * z + y * x) := by
  simp at *; assumption

example (x y z : Nat) (p : Nat → Prop)
        (h₁ : p (1 * x + y)) (h₂ : p (x * z * 1))
        : p (y + 0 + x) ∧ p (z * x) := by
  simp at * &lt;;&gt; constructor &lt;;&gt; assumption
</code></pre>
<p>自然数の乗法のような可換性と結合性を満たす演算の場合、単純化器は可換性と結合性に加えて<em>left commutativity</em>(左可換性)を用いて式を書き換える。乗法の場合、左可換性は次のように表される: <code>x * (y * z) = y * (x * z)</code>。<code>local</code> 修飾子は、現在のファイル(あるいはセクションや名前空間)内でこれらの規則を使用するように単純化器に指示する。可換性と左可換性は、どちらか片方を繰り返し適用するとループが生じるという点で問題があるように思えるかもしれない。しかし、単純化器は引数を並べ替える恒等式を検出し、<em>ordered rewriting</em>(順序付き書き換え)として知られるテクニックを使用する。これは、システムが項の内部的な順序を保持し、項の順序が小さくなる場合にのみ恒等式を適用することを意味する。上記の可換性、結合性、左可換性の恒等式は全て、部分項中の括弧を右に寄せるという効果を持つ。そのため、項を(多少恣意的ではあるが)正規化された順序で並べることができる。したがって、結合性と可換性の下で等価な式は、同じ正規形に書き換えられる。</p>
<pre><code class="language-lean">attribute [local simp] Nat.mul_comm Nat.mul_assoc Nat.mul_left_comm
attribute [local simp] Nat.add_assoc Nat.add_comm Nat.add_left_comm
example (w x y z : Nat)
        : x * y + z * w * x = x * w * z + y * x := by
  simp

example (w x y z : Nat) (p : Nat → Prop)
        (h : p (x * y + z * w * x)) : p (x * w * z + y * x) := by
  simp        -- ⊢ p (x * y + w * (x * z))
  simp at h   -- h: p (x * y + w * (x * z))
  assumption
</code></pre>
<p><code>rewrite</code> と同様に、<code>simp [t_1, ..., t_n]</code> と書くことで、単純化の際に使用する恒等式のリストに <code>t_1</code> ... <code>t_n</code> を追加することができる。追加するものは一般的な補題でも仮説でも定義の展開でも複合的な項でもよい。<code>simp</code> タクティクも <code>rewrite</code> と同様に <code>←t</code> 構文を認識する。</p>
<pre><code class="language-lean">def f (m n : Nat) : Nat :=
  m + n + m

example {m n : Nat} (h : n = 1) (h' : 0 = m) : (f m n) = n := by
  simp [h, ←h', f]
</code></pre>
<p>仮説を用いてゴールを単純化するのがよくある使い方である:</p>
<pre><code class="language-lean">example (f : Nat → Nat) (k : Nat) (h₁ : f 0 = 0) (h₂ : k = 0) : f k = 0 := by
  simp [h₁, h₂]
</code></pre>
<p>単純化の際に全ての仮説を使いたい場合は、ワイルドカード記号 <code>*</code> を使う:</p>
<pre><code class="language-lean">example (f : Nat → Nat) (k : Nat) (h₁ : f 0 = 0) (h₂ : k = 0) : f k = 0 := by
  simp [*]
</code></pre>
<p>次は他の例である:</p>
<pre><code class="language-lean">example (u w x y z : Nat) (h₁ : x = y + z) (h₂ : w = u + x)
        : w = z + y + u := by
  simp [*, Nat.add_assoc, Nat.add_comm, Nat.add_left_comm]
</code></pre>
<p>単純化器は命題の書き換えも行う。例えば、仮説 <code>hp : p</code> を用いて、<code>p ∧ q</code> を <code>q</code> に、<code>p v q</code> を <code>True</code> に書き換え、最終的に自明な命題に書き換えられたゴールを閉じる。命題の書き換えを繰り返すことで、非自明な命題推論を行うことができる。</p>
<pre><code class="language-lean">example (p q : Prop) (hp : p) : p ∧ q ↔ q := by
  simp [*]

example (p q : Prop) (hp : p) : p ∨ q := by
  simp [*]

example (p q r : Prop) (hp : p) (hq : q) : p ∧ (q ∨ r) := by
  simp [*]
</code></pre>
<p>次の例では、単純化器はコンテキスト内の全ての仮説を単純化し、それらをターゲットに適用しゴールを閉じている。</p>
<pre><code class="language-lean">example (u w x x' y y' z : Nat) (p : Nat → Prop)
        (h₁ : x + 0 = x') (h₂ : y + 0 = y')
        : x + y + 0 = x' + y' := by
  simp at *
  simp [*]
</code></pre>
<p>単純化器の特に便利なところは、ライブラリが発展するにつれてその機能が成長していくところだ。例えば、リスト <code>xs</code> を受け取ると、<code>xs</code> に反転 <code>xs.reverse</code> を追加して <code>xs</code> を対称化するリスト演算 <code>mk_symm</code> を定義したとしよう:</p>
<pre><code class="language-lean">def mk_symm (xs : List α) :=
  xs ++ xs.reverse
</code></pre>
<p>このとき、任意のリスト <code>xs</code> に対して、<code>List.reverse (mk_symm xs)</code> が <code>mk_symm xs</code> と等しいことが、定義を展開することで容易に証明できる:</p>
<pre><code class="language-lean"><span class="boring">def mk_symm (xs : List α) :=
</span><span class="boring"> xs ++ xs.reverse
</span>theorem reverse_mk_symm (xs : List α)
        : (mk_symm xs).reverse = mk_symm xs := by
  simp [mk_symm]
</code></pre>
<p><code>reverse_mk_symm</code> が証明された今、新しい定理を証明するために <code>reverse_mk_symm</code> を使った単純化を用いることができる:</p>
<pre><code class="language-lean"><span class="boring">def mk_symm (xs : List α) :=
</span><span class="boring"> xs ++ xs.reverse
</span><span class="boring">theorem reverse_mk_symm (xs : List α)
</span><span class="boring">       : (mk_symm xs).reverse = mk_symm xs := by
</span><span class="boring"> simp [mk_symm]
</span>example (xs ys : List Nat)
        : (xs ++ mk_symm ys).reverse = mk_symm ys ++ xs.reverse := by
  simp [reverse_mk_symm]

example (xs ys : List Nat) (p : List Nat → Prop)
        (h : p (xs ++ mk_symm ys).reverse)
        : p (mk_symm ys ++ xs.reverse) := by
  simp [reverse_mk_symm] at h; assumption
</code></pre>
<p><code>simp [reverse_mk_symm]</code> を使うのは一般的に決して悪いことではないが、ユーザーが明示的にこれを呼び出す必要がない方がなおよいだろう。定理を定義する際に、「これは単純化の際に使う定理だ」とマークすることで明示的な呼び出しの省略を実現できる:</p>
<pre><code class="language-lean"><span class="boring">def mk_symm (xs : List α) :=
</span><span class="boring"> xs ++ xs.reverse
</span>@[simp] theorem reverse_mk_symm (xs : List α)
        : (mk_symm xs).reverse = mk_symm xs := by
  simp [mk_symm]

example (xs ys : List Nat)
        : (xs ++ mk_symm ys).reverse = mk_symm ys ++ xs.reverse := by
  simp

example (xs ys : List Nat) (p : List Nat → Prop)
        (h : p (xs ++ mk_symm ys).reverse)
        : p (mk_symm ys ++ xs.reverse) := by
  simp at h; assumption
</code></pre>
<p>記法 <code>@[simp]</code> は <code>reverse_mk_symm</code> が <code>[simp]</code> 属性を持つことを宣言する。この宣言はより明示的に記述することができる:</p>
<pre><code class="language-lean"><span class="boring">def mk_symm (xs : List α) :=
</span><span class="boring"> xs ++ xs.reverse
</span>theorem reverse_mk_symm (xs : List α)
        : (mk_symm xs).reverse = mk_symm xs := by
  simp [mk_symm]

attribute [simp] reverse_mk_symm

example (xs ys : List Nat)
        : (xs ++ mk_symm ys).reverse = mk_symm ys ++ xs.reverse := by
  simp

example (xs ys : List Nat) (p : List Nat → Prop)
        (h : p (xs ++ mk_symm ys).reverse)
        : p (mk_symm ys ++ xs.reverse) := by
  simp at h; assumption
</code></pre>
<p>定理が宣言された後なら、いつでもその定理に属性を付与することができる:</p>
<pre><code class="language-lean"><span class="boring">def mk_symm (xs : List α) :=
</span><span class="boring"> xs ++ xs.reverse
</span>theorem reverse_mk_symm (xs : List α)
        : (mk_symm xs).reverse = mk_symm xs := by
  simp [mk_symm]

example (xs ys : List Nat)
        : (xs ++ mk_symm ys).reverse = mk_symm ys ++ xs.reverse := by
  simp [reverse_mk_symm]

attribute [simp] reverse_mk_symm

example (xs ys : List Nat) (p : List Nat → Prop)
        (h : p (xs ++ mk_symm ys).reverse)
        : p (mk_symm ys ++ xs.reverse) := by
  simp at h; assumption
</code></pre>
<p>しかし、一度属性が付与されると、それを永続的に削除する方法は<strong>ない</strong>。そして、属性は、その属性が割り当てられているファイルをインポートする全てのファイルに適用される。<a href="./interacting_with_lean.html#attributes-%E5%B1%9E%E6%80%A7">Attributes (属性)</a>の節で詳しく説明するが、<code>local</code> 修飾子を使えば、属性の適用範囲を現在のファイルやセクションに限定することができる:</p>
<pre><code class="language-lean"><span class="boring">def mk_symm (xs : List α) :=
</span><span class="boring"> xs ++ xs.reverse
</span>theorem reverse_mk_symm (xs : List α)
        : (mk_symm xs).reverse = mk_symm xs := by
  simp [mk_symm]

section
attribute [local simp] reverse_mk_symm

example (xs ys : List Nat)
        : (xs ++ mk_symm ys).reverse = mk_symm ys ++ xs.reverse := by
  simp

example (xs ys : List Nat) (p : List Nat → Prop)
        (h : p (xs ++ mk_symm ys).reverse)
        : p (mk_symm ys ++ xs.reverse) := by
  simp at h; assumption
end
</code></pre>
<p><code>local</code> を使った場合、そのセクションの外では、単純化器はデフォルトで <code>reverse_mk_symm</code> を使わなくなる。</p>
<p>これまで説明してきた様々な <code>simp</code> のオプション (ルールの明示的なリストを与える、<code>at</code> を使って適用対象を指定するなど) は組み合わせることができるが、オプションを記述する順序は厳格であることに注意してほしい。エディタの中では、<code>simp</code> キーワードにカーソルを合わせて、<code>simp</code> に関連するドキュメントを読むことで、オプションの正しい順序を確認することができる。</p>
<p>さらに2つの便利な修飾子がある。デフォルトでは、<code>simp</code> は属性 <code>[simp]</code> でマークされた全ての定理を利用する。<code>simp only</code> と書くと、デフォルトで使われる定理は全て除外され、より明確に作られた定理のリストを使うことができる。以下の例では、マイナス記号 <code>-</code> と <code>only</code> が <code>reverse_mk_symm</code> の適用をブロックするために使われている。</p>
<pre><code class="language-lean">def mk_symm (xs : List α) :=
  xs ++ xs.reverse
@[simp] theorem reverse_mk_symm (xs : List α)
        : (mk_symm xs).reverse = mk_symm xs := by
  simp [mk_symm]

example (xs ys : List Nat) (p : List Nat → Prop)
        (h : p (xs ++ mk_symm ys).reverse)
        : p (mk_symm ys ++ xs.reverse) := by
  simp at h; assumption

example (xs ys : List Nat) (p : List Nat → Prop)
        (h : p (xs ++ mk_symm ys).reverse)
        : p ((mk_symm ys).reverse ++ xs.reverse) := by
  simp [-reverse_mk_symm] at h; assumption

example (xs ys : List Nat) (p : List Nat → Prop)
        (h : p (xs ++ mk_symm ys).reverse)
        : p ((mk_symm ys).reverse ++ xs.reverse) := by
  simp only [List.reverse_append] at h; assumption
</code></pre>
<p><code>simp</code> タクティクには多くの設定オプションがある。例えば、次のように文脈的な単純化(ターゲットの前件を用いた単純化)を有効にすることができる。</p>
<pre><code class="language-lean">example : if x = 0 then y + x = y else x ≠ 0 := by
  simp (config := { contextual := true })
</code></pre>
<p><code>contextual := true</code> のとき、 <code>simp</code> は <code>y + x = y</code> を単純化する際は <code>x = 0</code> という事実を使い、<code>x ≠ 0</code> を単純化する際には <code>x ≠ 0</code> を用いる。次は他の例である:</p>
<pre><code class="language-lean">example : ∀ (x : Nat) (h : x = 0), y + x = y := by
  simp (config := { contextual := true })
</code></pre>
<p>もうひとつの便利な設定オプションは、算術的な単純化を可能にする <code>arith := true</code> である。これは非常に便利なので、<code>simp_arith</code> は <code>simp (config := { arith := true })</code> の省略形になっている。</p>
<pre><code class="language-lean">example : 0 &lt; 1 + x ∧ x + y + 2 ≥ y + 1 := by
  simp_arith
</code></pre>
<h2 id="split-tactic-splitタクティク"><a class="header" href="#split-tactic-splitタクティク">Split Tactic (Splitタクティク)</a></h2>
<p><code>split</code> タクティクは、入れ子の <code>if-then-else</code> 式や <code>match</code> 式を場合分けするのに便利である。<code>n</code> 個の場合分けを持つ <code>match</code> 式に対して、<code>split</code> タクティクは最大 <code>n</code> 個のサブゴールを生成する。次に例を示す:</p>
<pre><code class="language-lean">def f (x y z : Nat) : Nat :=
  match x, y, z with
  | 5, _, _ =&gt; y
  | _, 5, _ =&gt; y
  | _, _, 5 =&gt; y
  | _, _, _ =&gt; 1

example (x y z : Nat) : x ≠ 5 → y ≠ 5 → z ≠ 5 → z = w → f x y w = 1 := by
  intros
  simp [f]
  split
  . contradiction
  . contradiction
  . contradiction
  . rfl
</code></pre>
<p>上記の例のタクティク証明は次のように短縮することができる。</p>
<pre><code class="language-lean"><span class="boring">def f (x y z : Nat) : Nat :=
</span><span class="boring"> match x, y, z with
</span><span class="boring"> | 5, _, _ =&gt; y
</span><span class="boring"> | _, 5, _ =&gt; y
</span><span class="boring"> | _, _, 5 =&gt; y
</span><span class="boring"> | _, _, _ =&gt; 1
</span>example (x y z : Nat) : x ≠ 5 → y ≠ 5 → z ≠ 5 → z = w → f x y w = 1 := by
  intros; simp [f]; split &lt;;&gt; first | contradiction | rfl
</code></pre>
<p>タクティク <code>split &lt;;&gt; first | contradiction | rfl</code> は、まず <code>split</code> タクティクを適用し、次に生成された各サブゴールに対して <code>contradiction</code> を試し、それが失敗したら <code>rfl</code> を試す。<code>simp</code> のように、<code>split</code> をコンテキスト内の特定の仮説に適用することもできる。</p>
<pre><code class="language-lean">def g (xs ys : List Nat) : Nat :=
  match xs, ys with
  | [a, b], _ =&gt; a+b+1
  | _, [b, c] =&gt; b+1
  | _, _      =&gt; 1

example (xs ys : List Nat) (h : g xs ys = 0) : False := by
  simp [g] at h; split at h &lt;;&gt; simp_arith at h
</code></pre>
<h2 id="extensible-tactics-拡張可能なタクティク"><a class="header" href="#extensible-tactics-拡張可能なタクティク">Extensible Tactics (拡張可能なタクティク)</a></h2>
<p>次の例では、コマンド <code>syntax</code> を使って <code>triv</code> という記法を定義する。次に、<code>macro_rules</code> コマンドを使って、<code>triv</code> が使われたときの処理を指定する(<code>triv</code> のマクロ展開を指定する)。<code>triv</code> に対して複数のマクロ展開を指定することができ、タクティク解釈器はどれかが成功するまで全てのマクロ展開を試す。</p>
<pre><code class="language-lean">-- 新しい記法を定義する
syntax &quot;triv&quot; : tactic

macro_rules
  | `(tactic| triv) =&gt; `(tactic| assumption)

example (h : p) : p := by
  triv

-- 現時点では、`triv` を使って次の定理を証明することはできない
-- example (x : α) : x = x := by
--  triv

-- `triv` を拡張しよう。タクティク解釈器はどれかが成功するまで
-- `triv` のための全てのマクロ展開を試す
macro_rules
  | `(tactic| triv) =&gt; `(tactic| rfl)

example (x : α) : x = x := by
  triv

example (x : α) (h : p) : x = x ∧ p := by
  apply And.intro &lt;;&gt; triv

-- (再帰的な)マクロ展開を追加する
macro_rules | `(tactic| triv) =&gt; `(tactic| apply And.intro &lt;;&gt; triv)

example (x : α) (h : p) : x = x ∧ p := by
  triv
</code></pre>
<h2 id="exercises-練習問題-2"><a class="header" href="#exercises-練習問題-2">Exercises (練習問題)</a></h2>
<ol>
<li>
<p><a href="./propositions_and_proofs.html">3章 Propositions and Proofs (命題と証明)</a> と <a href="./quantifiers_and_equality.html">4章 Quantifiers and Equality (量化子と等号)</a> に戻り、タクティク証明を用いて出来るだけ多くの練習問題を解き直せ。<code>rw</code> と <code>simp</code> も適切に使うこと。</p>
</li>
<li>
<p>タクティク結合子を使って、次の定理の証明を1行で書け:</p>
</li>
</ol>
<pre><code class="language-lean">example (p q r : Prop) (hp : p)
        : (p ∨ q ∨ r) ∧ (q ∨ p ∨ r) ∧ (q ∨ r ∨ p) := by
  admit
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interacting-with-lean-leanとの対話"><a class="header" href="#interacting-with-lean-leanとの対話">Interacting with Lean (Leanとの対話)</a></h1>
<p>数学的オブジェクトを定義するための言語としての、そして証明を構築するための言語としての依存型理論の基本は理解していただけただろう。読者がまだ手にしていないのは、新しいデータ型を定義する方法である。このギャップを埋めるため、次の章では<em>inductive data type</em>(帰納データ型)の概念を紹介する。その前に、この章では型理論そのものの説明は一旦お休みして、Leanのコードを書く際の実用的な機能について学ぶ。</p>
<p>ここに掲載されている情報の全てが、すぐ役に立つとは限らない。この章は軽く読んでLeanの特徴を掴み、後で必要に応じて戻ってくることをお勧めする。</p>
<h2 id="importing-files-ファイルのインポート"><a class="header" href="#importing-files-ファイルのインポート">Importing Files (ファイルのインポート)</a></h2>
<p>Leanのフロントエンドの目的は、ユーザーの入力を解釈し、形式的な式を構築し、そしてそれらが正しい構文規則に従っており、正しく型付けされることをチェックすることである。Leanは様々なエディタでの使用をサポートしており、ユーザーはエディタ上で継続的なチェックとフィードバックを受けることができる。詳しくはLeanの<a href="http://lean-lang.org/documentation/">documentation pages</a>を参照してほしい。</p>
<p>Leanの標準ライブラリの定義と定理は複数のファイルに散在している。ユーザーは追加のライブラリを使用したり、複数のファイルからなる独自のプロジェクトを開発することができる。Leanが起動すると、ライブラリの <code>Init</code> フォルダの内容が自動的にインポートされる。<code>Init</code> フォルダには基本的な定義や構文が多数含まれている。その結果、ここで紹介する例のほとんどは追加設定なしでそのまま動作する。</p>
<p>しかし、追加ファイルを使いたい場合は、ファイルの先頭に <code>import</code> 文を書いて手動でインポートする必要がある。コマンド</p>
<pre><code>import Bar.Baz.Blah
</code></pre>
<p>は <code>Bar/Baz/Blah.olean</code> ファイルを読み込む(<code>.olean</code> はコンパイル済のLeanファイルの拡張子である)。このコマンドにおいて、<code>Bar.Baz.Blah</code> はLeanの<em>search path</em>(検索パス)からの相対パスとして解釈される。検索パスがどのように決定されるかについては、<a href="http://lean-lang.org/documentation/">documentation pages</a>を参照してほしい。デフォルトでは、標準ライブラリディレクトリと、場合によってはユーザーのローカルプロジェクトのルートが検索パスに含まれる。(Lean4では、カレントディレクトリからの相対パスでインポートファイルを指定することは<strong>できない</strong>。)</p>
<p>インポートは「推移的」である。言い換えれば、<code>Foo</code> をインポートして、<code>Foo</code> が <code>Bar</code> をインポートする場合、<code>Bar</code> の内容にもアクセスできるようになる。したがって、<code>Bar</code> を明示的にインポートする必要はない。</p>
<h2 id="more-on-sections-セクションの詳細"><a class="header" href="#more-on-sections-セクションの詳細">More on Sections (セクションの詳細)</a></h2>
<p>Leanは理論の構造化を手助けするために、様々なセクション分けの仕組みを提供している。<a href="./dependent_type_theory.html#variables-and-sections-%E5%A4%89%E6%95%B0%E3%81%A8%E3%82%BB%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3">Variables and Sections (変数とセクション)</a>の節で、<code>section</code> コマンドを使うことで、理論の要素をグループ化できるだけでなく、必要に応じて定理や定義の引数として挿入される変数のスコープを区切ることができることを説明した。<code>variable</code> コマンドのポイントは、次の例のように、定理で使う変数を宣言できることであることを思い出してほしい:</p>
<pre><code class="language-lean">section
variable (x y : Nat)

def double := x + x

#check double y
#check double (2 * x)

attribute [local simp] Nat.add_assoc Nat.add_comm Nat.add_left_comm

theorem t1 : double (x + y) = double x + double y := by
  simp [double]

#check t1 y
#check t1 (2 * x)

theorem t2 : double (x * y) = double x * y := by
  simp [double, Nat.add_mul]

end
</code></pre>
<p><code>variable (x y : Nat)</code> が書かれていれば、<code>double</code> の定義において <code>x</code> を引数として宣言する必要はない。Leanは <code>double</code> の定義の中で <code>x</code> が使われていることを検出し、<code>(x : Nat)</code> を定義の引数に自動的に挿入する。同様に、Leanは <code>t1</code> と <code>t2</code> の中に <code>x</code> と <code>y</code> が現れることを検出し、 <code>(x : Nat)</code> と <code>(y : Nat)</code> を自動的に挿入する。<code>double</code> の定義の中に <code>y</code> は現れていないため、<code>double</code> は <code>y</code> を引数として持た<strong>ない</strong>ことに注意してほしい。<code>variable</code> コマンドで宣言された変数は、それらが実際に使用される定義宣言にのみ引数として挿入される。</p>
<h2 id="more-on-namespaces-名前空間の詳細"><a class="header" href="#more-on-namespaces-名前空間の詳細">More on Namespaces (名前空間の詳細)</a></h2>
<p>Leanでは、識別子(定義や定理や定数の名前)は <code>Foo.Bar.baz</code> のような<em>hierarchical names</em>(階層名)で与えられる。Leanが階層名を扱うためのメカニズムを提供していることは、<a href="./dependent_type_theory.html#namespaces-%E5%90%8D%E5%89%8D%E7%A9%BA%E9%96%93">Namespaces (名前空間)</a>の節で説明した。コマンド <code>namespace foo</code> は、<code>end foo</code>に行き当たるまで、各定義と定理の名前の前に <code>foo</code> を付加する。コマンド <code>open foo</code> は、接頭辞 <code>foo</code> で始まる各定義と定理に、元の「フルネーム」に加えて接頭辞 <code>foo</code> を除いた一時的な「別名」を与える。</p>
<pre><code class="language-lean">namespace Foo
def bar : Nat := 1
end Foo

open Foo

#check bar
#check Foo.bar
</code></pre>
<p>次のような定義</p>
<pre><code class="language-lean">def Foo.bar : Nat := 1
</code></pre>
<p>はマクロとして扱われ、次のように展開される。</p>
<pre><code class="language-lean">namespace Foo
def bar : Nat := 1
end Foo
</code></pre>
<p>定理や定義の名前は一意でなければならないが、短い「別名」は一意でないことがある。名前空間を開いたとき、識別子の指示対象が曖昧になる可能性がある。Leanは型情報を使って文脈上の意味を曖昧でなくしようとするが、フルネームを記すことで常に曖昧さをなくすことができる。全ての識別子にフルネームを与えるため、空の接頭辞を明示的に記述するための文字列 <code>_root_</code> が存在する。</p>
<pre><code class="language-lean">def String.add (a b : String) : String :=
  a ++ b

def Bool.add (a b : Bool) : Bool :=
  a != b

def add (α β : Type) : Type := Sum α β

open Bool
open String
-- #check add -- これは曖昧である
#check String.add           -- String → String → String
#check Bool.add             -- Bool → Bool → Bool
#check _root_.add           -- Type → Type → Type

#check add &quot;hello&quot; &quot;world&quot;  -- String
#check add true false       -- Bool
#check add Nat Nat          -- Type
</code></pre>
<p><code>protected</code> キーワードを使って定義を宣言することで、短い別名が作られることを防ぐことができる:</p>
<pre><code class="language-lean">protected def Foo.bar : Nat := 1

open Foo

-- #check bar -- error
#check Foo.bar
</code></pre>
<p>一般的な名前のオーバーロードを防ぐため、<code>protected</code> キーワードは <code>Nat.rec</code> や <code>Nat.recOn</code> のような名前にも用いられる。</p>
<p><code>open</code> コマンドにはバリエーションがある。コマンド <code>open Nat (succ zero gcd)</code> は列挙された識別子 <code>succ zero gcd</code> に対してのみ短い別名を生成する:</p>
<pre><code class="language-lean">open Nat (succ zero gcd)
#check zero     -- Nat
#eval gcd 15 6  -- 3
</code></pre>
<p>コマンド <code>open Nat hiding succ gcd</code> は、  <code>Nat</code> 名前空間内の列挙された識別子 <code>succ gcd</code> を<strong>除く</strong>全てに対して短い別名を生成する:</p>
<pre><code class="language-lean">open Nat hiding succ gcd
#check zero     -- Nat
-- #eval gcd 15 6  -- error
#eval Nat.gcd 15 6  -- 3
</code></pre>
<p>コマンド <code>open Nat renaming mul → times, add → plus</code> は、<code>Nat.mul</code> を <code>times</code> に、<code>Nat.add</code> を <code>plus</code> にリネームした上で短い別名を生成する:</p>
<pre><code class="language-lean">open Nat renaming mul → times, add → plus
#eval plus (times 2 2) 3  -- 7
-- #eval mul 1 2          -- error
#eval Nat.mul 1 2         -- 2
</code></pre>
<p>ある名前空間から別の名前空間へ、あるいはルートレベルへ別名を <code>export</code> することは時に便利である。現在の名前空間 <code>Foo</code> の中で、コマンド <code>export Nat (succ add sub)</code> は、<code>Nat.succ</code>、<code>Nat.add</code>、<code>Nat.sub</code> に対して別名 <code>Foo.succ</code>、<code>Foo.add</code>、<code>Foo.sub</code> を生成する。したがって、名前空間が開かれているときは、いつでもこれらの別名を使うことができる。名前空間の外で <code>export</code> コマンドが使われたときは、短い別名がルートレベルにエクスポートされる。</p>
<pre><code class="language-lean">namespace Foo
export And (intro left right)

#check And.intro  -- And.intro {a b : Prop} (left : a) (right : b) : a ∧ b
#check Foo.intro  -- And.intro {a b : Prop} (left : a) (right : b) : a ∧ b
#check intro      -- And.intro {a b : Prop} (left : a) (right : b) : a ∧ b
#check left       -- And.left {a b : Prop} (self : a ∧ b) : a
end Foo

-- #check intro   -- error

export And (intro left right)
#check intro      -- And.intro {a b : Prop} (left : a) (right : b) : a ∧ b
-- #check _root_.intro  -- error
</code></pre>
<p><code>export</code> コマンドが上手く機能しない場合は、<code>protected</code> キーワードや属性によって保護されている可能性を考えよう。</p>
<h2 id="attributes-属性"><a class="header" href="#attributes-属性">Attributes (属性)</a></h2>
<p>Leanの主な機能はユーザーの入力を形式的な式に翻訳することであり、その形式的な式はカーネルによって正しさがチェックされ、後で使用するために環境に保存される。しかし、いくつかのコマンドは、環境内のオブジェクトに属性を割り当てたり、記法を定義したり、<a href="./type_classes.html">10章 Type Classes (型クラス)</a>で説明される型クラスのインスタンスを宣言したりと、環境に別の影響を与える。そのようなコマンドのほとんどはグローバルな効果を持つ、つまり現在のファイル内だけでなく、現在のファイルをインポートした任意のファイル内でその効果が持続する。しかしながら、このようなコマンドは <code>local</code> 修飾子をサポートしていることが多い。<code>local</code> 修飾子を使えば、コマンドの効果を現在のセクションや名前空間が閉じられるまで、あるいは現在のファイルの終わりまでに限定することができる。</p>
<p><a href="./tactics.html#using-the-simplifier-%E5%8D%98%E7%B4%94%E5%8C%96%E5%99%A8%E3%81%AE%E4%BD%BF%E7%94%A8">Using the Simplifier (単純化器の使用)</a>の節では、定理に <code>[simp]</code> 属性を付与することで、単純化器がそれらの定理を使用できるようになることを説明した。次の例では、リストの「接頭辞関係」を定義し、この関係が反射的であることを証明し、その定理に <code>[simp]</code> 属性を割り当てている。</p>
<pre><code class="language-lean">def isPrefix (l₁ : List α) (l₂ : List α) : Prop :=
  ∃ t, l₁ ++ t = l₂

@[simp] theorem List.isPrefix_self (as : List α) : isPrefix as as :=
  ⟨[], by simp⟩

example : isPrefix [1, 2, 3] [1, 2, 3] := by
  simp
</code></pre>
<p>それから、単純化器は <code>isPrefix [1, 2, 3] [1, 2, 3]</code> を <code>True</code> に書き換えることでこれを証明している。</p>
<p>定義がなされた後ならいつでも、その定義に属性を割り当てることができる:</p>
<pre><code class="language-lean"><span class="boring">def isPrefix (l₁ : List α) (l₂ : List α) : Prop :=
</span><span class="boring"> ∃ t, l₁ ++ t = l₂
</span>theorem List.isPrefix_self (as : List α) : isPrefix as as :=
  ⟨[], by simp⟩

attribute [simp] List.isPrefix_self
</code></pre>
<p><code>local</code> 修飾子を付けなかった場合、属性は、属性の宣言が行われたファイルをインポートするどのファイルにおいても有効である。<code>local</code> 修飾子を付加すると、属性のスコープは制限される:</p>
<pre><code class="language-lean"><span class="boring">def isPrefix (l₁ : List α) (l₂ : List α) : Prop :=
</span><span class="boring"> ∃ t, l₁ ++ t = l₂
</span>section

theorem List.isPrefix_self (as : List α) : isPrefix as as :=
  ⟨[], by simp⟩

attribute [local simp] List.isPrefix_self

example : isPrefix [1, 2, 3] [1, 2, 3] := by
  simp

end

-- Error:
-- example : isPrefix [1, 2, 3] [1, 2, 3] := by
--  simp
</code></pre>
<p>他の例として、<code>instance</code> コマンドを使うと <code>isPrefix</code> 関係に <code>≤</code> という表記を割り当てることができる。<a href="./type_classes.html">10章 Type Classes (型クラス)</a>で説明するが、<code>instance</code> コマンドは関連する定義に <code>[instance]</code> 属性を割り当てることで機能する。</p>
<pre><code class="language-lean">def isPrefix (l₁ : List α) (l₂ : List α) : Prop :=
  ∃ t, l₁ ++ t = l₂

instance : LE (List α) where
  le := isPrefix

theorem List.isPrefix_self (as : List α) : as ≤ as :=
  ⟨[], by simp⟩
</code></pre>
<p><code>instance</code> を用いた表記の割り当てもローカルにすることができる:</p>
<pre><code class="language-lean"><span class="boring">def isPrefix (l₁ : List α) (l₂ : List α) : Prop :=
</span><span class="boring">  ∃ t, l₁ ++ t = l₂
</span>def instLe : LE (List α) :=
  { le := isPrefix }

section
attribute [local instance] instLe

example (as : List α) : as ≤ as :=
  ⟨[], by simp⟩

end

-- Error:
-- example (as : List α) : as ≤ as :=
--  ⟨[], by simp⟩
</code></pre>
<p>後述の<a href="interacting_with_lean.html#notation-%E8%A8%98%E6%B3%95">Notation (記法)</a>の節では、Leanの記法を定義するメカニズムについて説明し、このメカニズムが <code>local</code> 修飾子もサポートしていることを確認する。しかし、以下の<a href="interacting_with_lean.html#setting-options-%E3%82%AA%E3%83%97%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AE%E8%A8%AD%E5%AE%9A">Setting Options (オプションの設定)</a>の節でLeanのオプション設定のメカニズムを説明するが、これは今までのパターンに従って<strong>いない</strong>: オプションはローカルに設定すること<strong>しかできない</strong>。つまり、オプション設定のスコープは常に現在のセクションかファイルに限定される。</p>
<h2 id="more-on-implicit-arguments-暗黙の引数の詳細"><a class="header" href="#more-on-implicit-arguments-暗黙の引数の詳細">More on Implicit Arguments (暗黙の引数の詳細)</a></h2>
<p><a href="./dependent_type_theory.html#implicit-arguments-%E6%9A%97%E9%BB%99%E3%81%AE%E5%BC%95%E6%95%B0">Implicit Arguments (暗黙の引数)</a>の節で、Leanにおいて項 <code>t</code> の型を <code>{x : α} → β x</code> と表すとき、波括弧は <code>x</code> が <code>t</code> の暗黙の引数であることを表す、と説明した。これは、<code>t</code> が記述されたときは常にその後にプレースホルダー(穴)が挿入されることを、つまり <code>t</code> が <code>@t _</code> に置換されることを意味する。それを望まない場合は、 <code>t</code> の代わりに <code>@t</code> と書く必要がある。</p>
<p>暗黙の引数は貪欲に、可能な限り挿入されることに注意してほしい。<code>y</code> だけを暗黙の引数にして関数 <code>f (x : Nat) {y : Nat} (z : Nat)</code> を定義したとする。このとき、2番目以降の引数を書かずに <code>f 7</code> と書くと、これは構文解析器(パーサ)により <code>f 7 _</code> とパースされる。Leanは弱い暗黙の引数(より控えめに挿入される暗黙の引数)を指定する記法 <code>{{y : Nat}}</code> を提供している。これは当該引数の後ろに明示的な引数がある場合にのみ、その明示的な引数の<strong>前に</strong>プレースホルダーを追加することを指定する。この記法は <code>⦃y : Nat⦄</code> と書くこともでき、このunicode括弧はそれぞれ <code>\{{</code> と <code>\}}</code> と打つと入力できる。<code>f (x : Nat) ⦃y : Nat⦄ (z : Nat)</code> と書いた場合、<code>f 7</code> はそのままパースされ、<code>f 7 3</code> は <code>f 7 _ 3</code> とパースされる。</p>
<p>この違いを説明するために、反射的ユークリッド関係が対称的かつ推移的であることを示す次の例を考えてみよう。</p>
<pre><code class="language-lean">def reflexive {α : Type u} (r : α → α → Prop) : Prop :=
  ∀ (a : α), r a a

def symmetric {α : Type u} (r : α → α → Prop) : Prop :=
  ∀ {a b : α}, r a b → r b a

def transitive {α : Type u} (r : α → α → Prop) : Prop :=
  ∀ {a b c : α}, r a b → r b c → r a c

def euclidean {α : Type u} (r : α → α → Prop) : Prop :=
  ∀ {a b c : α}, r a b → r a c → r b c

theorem th1 {α : Type u} {r : α → α → Prop}
            (reflr : reflexive r) (euclr : euclidean r)
            : symmetric r :=
  fun {a b : α} =&gt;
  fun (h : r a b) =&gt;
  show r b a from euclr h (reflr a)

theorem th2 {α : Type u} {r : α → α → Prop}
            (symmr : symmetric r) (euclr : euclidean r)
            : transitive r :=
  fun {a b c : α} =&gt;
  fun (rab : r a b) (rbc : r b c) =&gt;
  show r a c from euclr (symmr rab) rbc

theorem th3 {α : Type u} {r : α → α → Prop}
            (reflr : reflexive r) (euclr : euclidean r)
            : transitive r :=
 th2 (th1 reflr @euclr) @euclr

variable (r : α → α → Prop)
variable (euclr : euclidean r)

#check @euclr  -- euclidean r
#check euclr   -- r ?m1 ?m2 → r ?m1 ?m3 → r ?m2 ?m3
</code></pre>
<p>この例は3つの小さなステップからなっている: <code>th1</code> は反射的かつユークリッド的な関係が対称的であることを示す。<code>th2</code> は対称的かつユークリッド的な関係が推移的であることを示す。そして <code>th3</code> は2つの定理を組み合わせ、反射的かつユークリッド的な関係が推移的であることを示している。しかし、<code>th3</code> の証明において、<code>euclr</code> の暗黙の引数を手動で無効にしなければならない。そうしなければ、証明中の <code>euclr</code> に必要以上に多くの暗黙の引数が挿入されてしまうからである。つまり、証明内の <code>@euclr</code> は命題 <code>∀ {a b c : α}, r a b → r a c → r b c</code> の証明項である一方で、証明内の <code>euclr</code> は <code>@euclr</code> を暗黙のメタ引数 <code>?m1 ?m2 ?m3 : α</code> に適用してできた、命題 <code>r ?m1 ?m2 → r ?m1 ?m3 → r ?m2 ?m3</code> の証明項なのである。弱い暗黙の引数を使えばこの問題は解決する:</p>
<pre><code class="language-lean">def reflexive {α : Type u} (r : α → α → Prop) : Prop :=
  ∀ (a : α), r a a

def symmetric {α : Type u} (r : α → α → Prop) : Prop :=
  ∀ {{a b : α}}, r a b → r b a

def transitive {α : Type u} (r : α → α → Prop) : Prop :=
  ∀ {{a b c : α}}, r a b → r b c → r a c

def euclidean {α : Type u} (r : α → α → Prop) : Prop :=
  ∀ {{a b c : α}}, r a b → r a c → r b c

theorem th1 {α : Type u} {r : α → α → Prop}
            (reflr : reflexive r) (euclr : euclidean r)
            : symmetric r :=
  fun {a b : α} =&gt;
  fun (h : r a b) =&gt;
  show r b a from euclr h (reflr a)

theorem th2 {α : Type u} {r : α → α → Prop}
            (symmr : symmetric r) (euclr : euclidean r)
            : transitive r :=
  fun {a b c : α} =&gt;
  fun (rab : r a b) (rbc : r b c) =&gt;
  show r a c from euclr (symmr rab) rbc

theorem th3 {α : Type u} {r : α → α → Prop}
            (reflr : reflexive r) (euclr : euclidean r)
            : transitive r :=
 th2 (th1 reflr euclr) euclr

variable (r : α → α → Prop)
variable (euclr : euclidean r)

#check @euclr  -- euclidean r
#check euclr   -- euclidean r
</code></pre>
<p>角括弧 <code>[</code> と <code>]</code> で表される3種類目の暗黙の引数がある。<a href="./type_classes.html">10章 Type Classes (型クラス)</a>で説明するように、これらは型クラスのために用いられる。</p>
<h2 id="notation-記法"><a class="header" href="#notation-記法">Notation (記法)</a></h2>
<p>Leanの識別子には、ギリシャ文字を含む任意の英数字(依存型理論で特別な意味を持つ∀、Σ、λは除く)を使うことができる。また、<code>\_</code> と打った後に希望の添字を打つことで、添字を入力することもできる。</p>
<p>Leanのパーサは拡張可能である、つまり、ユーザーは新しい記法を定義することができる。</p>
<p>ユーザーは、Leanの構文を、基本的な<em>mixfix</em>記法からユーザーカスタムのelaboratorまで、あらゆるレベルで拡張したりカスタマイズできる。実際、全てのビルトイン構文は、ユーザー向けに提供されているメカニズムやAPIと同じものを使ってパースされ、処理される。この節では、様々な拡張方法について記述し、説明する。</p>
<p>新しい記法を導入することは、プログラミング言語では比較的まれなことであり、コードを不明瞭にする可能性があるため時には嫌われることさえあるが、形式化においては、各分野で確立された慣習や記法をコードで簡潔に表現するための非常に貴重なツールである。基本的な記法にとどまらず、よくある定型的なコードを抽出して(うまく機能する)マクロに落とし込んだり、カスタムされたドメイン固有言語(DSL)全体を組み込んで部分問題を効率的かつ読みやすくテキストにエンコードするLeanの機能は、プログラマーと証明エンジニアの双方にとって大きなベネフィットとなる。</p>
<h3 id="notations-and-precedence-記法と優先順位"><a class="header" href="#notations-and-precedence-記法と優先順位">Notations and Precedence (記法と優先順位)</a></h3>
<p>最も基本的な構文拡張コマンドを使うと、新しい(あるいはオーバーロードされた)前置演算子、中置演算子、後置演算子を導入することができる。</p>
<pre><code class="language-lean">infixl:65   &quot; + &quot; =&gt; HAdd.hAdd  -- 左結合的な中置演算子
infix:50    &quot; = &quot; =&gt; Eq         -- 非結合的な中置演算子
infixr:80   &quot; ^ &quot; =&gt; HPow.hPow  -- 右結合的な中置演算子
prefix:100  &quot;-&quot;   =&gt; Neg.neg    -- 前置演算子
set_option quotPrecheck false
postfix:max &quot;⁻¹&quot;  =&gt; Inv.inv    -- 後置演算子
</code></pre>
<p>演算子の種類(その「固定位置」)を表す最初のコマンド名とコロン <code>:</code> の後に、演算子の<em>parsing precedence</em>(パース優先順位)を与える。次に新規または既存の記号を二重引用符で囲み(空白はコードの見た目を整えるために使われる)、矢印 <code>=&gt;</code> の後にこの演算子の変換先の関数を指定する。</p>
<p>優先順位とは演算子と引数の結びつきの「強さ」を表す自然数で、演算の順序を表す。上記がマクロ展開されてできるコマンドを見ることで、これらをより正確に理解することができる:</p>
<pre><code class="language-lean">notation:65 lhs:65 &quot; + &quot; rhs:66 =&gt; HAdd.hAdd lhs rhs
notation:50 lhs:51 &quot; = &quot; rhs:51 =&gt; Eq lhs rhs
notation:80 lhs:81 &quot; ^ &quot; rhs:80 =&gt; HPow.hPow lhs rhs
notation:100 &quot;-&quot; arg:100 =&gt; Neg.neg arg
set_option quotPrecheck false
notation:1024 arg:1024 &quot;⁻¹&quot; =&gt; Inv.inv arg  -- ``max`` はパース優先順位1024の略記
</code></pre>
<p>最初のコードブロックの全てのコマンドは、実際にはより一般的な <code>notation</code> コマンドに変換するコマンドマクロであることがわかった。このようなマクロの書き方は後の節で学ぶ。<code>notation</code> コマンドは、単一の記号の代わりに、記号と「優先順位を持つ名前付き項プレースホルダー」を組み合わせたシーケンスを受け付ける。このシーケンスは <code>=&gt;</code> の右辺で参照され、右辺にあるプレースホルダーはシーケンス内の位置に基づいてパースされた各項によって置換される。優先順位 <code>p</code> を持つプレースホルダーは、その場所で <code>p</code> 以上の優先順位を持つ表記のみを受け付ける。したがって、文字列 <code>a + b + c</code> を <code>a + (b + c)</code> とパースすることはできない。なぜなら、<code>infixl</code> コマンドの演算子の右辺は、演算子自体よりも優先順位が1大きいからである。対照的に、<code>infixr</code> コマンドの演算子の右辺は、演算子と同じ優先順位を持つ。そのため、<code>a ^ b ^ c</code> は <code>a ^ (b ^ c)</code> とパースされる。優先順位が結合性を明確に決定しない場合、<code>notation</code> コマンドを直接使って次のような中置演算子を導入すると、Leanはこの演算子をデフォルトで右結合的にパースすることに注意してほしい:</p>
<pre><code class="language-lean"><span class="boring">set_option quotPrecheck false
</span>notation:65 lhs:65 &quot; ~ &quot; rhs:65 =&gt; wobble lhs rhs
</code></pre>
<p>より正確には、曖昧な文法が存在する場合、Leanのパーサはローカルな<em>longest parse rule</em>(最長構文解析ルール)に従う: <code>a ~ b ~ c</code> の中の <code>a ~</code> の右辺をパースするとき、パーサは(優先順位が許す限り)最も長くパースを続ける。つまり <code>b</code> をパースした後に停止せず、<code>~ c</code> もパースする。したがって、項 <code>a ~ b ~ c</code> は <code>a ~ (b ~ c)</code> と等価である。(Leanのパーサは、あくまで最も左側に位置する演算子から順にパースを試みることに注意してほしい。)</p>
<p>上記で言及したように、<code>notation</code> コマンドを使うと、記号とプレースホルダーを自由にミックスした任意の<em>mixfix</em>構文を定義することができる。</p>
<pre><code class="language-lean"><span class="boring">set_option quotPrecheck false
</span>notation:max &quot;(&quot; e &quot;)&quot; =&gt; e
notation:10 Γ &quot; ⊢ &quot; e &quot; : &quot; τ =&gt; Typing Γ e τ
</code></pre>
<p>優先順位が明記されていないプレースホルダーの優先順位はデフォルトで <code>0</code> であり、つまりその位置にある任意の項を受け入れる。2つの記法が重なる場合、再び最長構文解析ルールを適用する。</p>
<pre><code class="language-lean">notation:65 a &quot; + &quot; b:66 &quot; + &quot; c:66 =&gt; a + b - c
#eval 1 + 2 + 3  -- 0
</code></pre>
<p>新しい記法は2項記法よりも優先される。なぜなら2項記法はパースが連鎖せず、<code>1 + 2</code> をパースしたところで構文解析をやめてしまうからである。最長のパースを受け入れる記法が複数ある場合、どちらが選択されるかはelaborationまで遅延され、ただ1つのオーバーロード記法が正しい型を持つ場合のみ成功し、それ以外の場合は曖昧さを解決できず失敗する。</p>
<h2 id="coercions-型強制"><a class="header" href="#coercions-型強制">Coercions (型強制)</a></h2>
<p>Leanでは、自然数の型 <code>Nat</code> と整数の型 <code>Int</code> は異なる。しかし、自然数を整数の中に埋め込む <code>Int.ofNat</code> という関数があり、これを使うと必要なときに自然数を整数に変換することができる。Leanはこの種の型変換の必要性を検出して型変換を実行するメカニズムを持っている。このような自動的な型変換を<em>coercions</em>(強制)と呼ぶ。</p>
<pre><code class="language-lean">variable (m n : Nat)
variable (i j : Int)

#check i + m      -- i + Int.ofNat m : Int
#check i + m + j  -- i + Int.ofNat m + j : Int
#check i + m + n  -- i + Int.ofNat m + Int.ofNat n : Int
</code></pre>
<h2 id="displaying-information-情報の表示"><a class="header" href="#displaying-information-情報の表示">Displaying Information (情報の表示)</a></h2>
<p>Leanに現在の状態や、現在のコンテキストで利用可能なオブジェクトや定理に関する情報を問い合わせる方法はいくつもある。最も一般的なコマンド <code>#check</code> と <code>#eval</code> は既に紹介した。<code>#check</code> は <code>@</code> 記号と一緒に使われることが多く、こうすると定理や定義の引数を暗黙の引数を含めて全て明示することができる。さらに、<code>#print</code> コマンドを使うと、任意の識別子に関する情報を得ることができる。識別子が定義や定理を表す場合、<code>#print</code> コマンドはその識別子の型と定義式を表示する。識別子が定数や公理である場合、<code>#print</code> コマンドは「この識別子は定数(または公理)である」という事実を示し、その型を表示する。</p>
<pre><code class="language-lean">-- examples with equality
#check Eq
#check @Eq
#check Eq.symm
#check @Eq.symm

#print Eq.symm

-- examples with And
#check And
#check And.intro
#check @And.intro

-- a user-defined function
def foo {α : Type u} (x : α) : α := x

#check foo
#check @foo
#print foo

-- axiom example
#print propext
</code></pre>
<h2 id="setting-options-オプションの設定"><a class="header" href="#setting-options-オプションの設定">Setting Options (オプションの設定)</a></h2>
<p>Leanは、Leanの動作を制御するためにユーザーが設定することができる内部変数をいくつも保持している。そのための構文は次の通り:</p>
<pre><code>set_option &lt;name&gt; &lt;value&gt;
</code></pre>
<p>非常に便利なオプション群の1つは、Leanの<em>pretty-printer</em>(プリティプリンタ)が項を表示する方法を制御する。以下のオプションはtrueかfalseを入力として受け取る:</p>
<pre><code>pp.explicit  : 暗黙の引数を表示する
pp.universes : 隠れた宇宙パラメータを表示する
pp.notation  : 定義された記法を用いて出力を表示する
</code></pre>
<p>例として、次のように設定すると、かなり長い出力が得られる:</p>
<pre><code class="language-lean">#check 2 + 2 = 4
#reduce (fun x =&gt; x + 2) = (fun x =&gt; x + 3)
#check (fun x =&gt; x + 1) 1

set_option pp.explicit true
set_option pp.universes true
set_option pp.notation false

#check 2 + 2 = 4
#reduce (fun x =&gt; x + 2) = (fun x =&gt; x + 3)
#check (fun x =&gt; x + 1) 1
</code></pre>
<p>コマンド <code>set_option pp.all true</code> はこれらの設定を一度に実行し、<code>set_option pp.all false</code> はこれらのオプションを元の値に戻す。証明をデバッグするときや、不可解なエラーメッセージを理解しようとするときに、付加的な情報を表示させることはしばしば非常に役に立つ。しかし、情報が多すぎると圧倒されるかもしれない。普通にLeanを使う場合はデフォルトの情報表示で一般的には十分である。</p>
<!--
## Elaboration Hints (elaborationのヒント)

Leanに ``λ x y z, f (x + y) z`` のような式の処理を依頼する場合、暗黙の情報を残していることになる。例えば、``x``、``y``、``z`` の型は文脈から推論する必要があり、``+`` という記法はオーバーロードされている可能性があり、``f`` にも埋める必要のある暗黙の引数があるかもしれない。さらに、[10章 Type Classes (型クラス)](./type_classes.md)では、いくつかの暗黙の引数は*type class resolution*(型クラス解決)として知られているプロセスによって合成されていることが分かる。また、項のいくつかの部分がタクティクフレームワークによって構築されうることも、すでに前章で見てきた。

いくつかの暗黙の引数を推論するのは簡単である。例えば、ある関数 ``f`` が ``Π {α : Type*}, α → α → α`` という型を持ち、Leanが ``f n`` という項を構文解析しようとしているとする。ここで、``n`` は ``nat`` 型を持つと推論できるとすると、暗黙の引数 ``α`` が ``nat`` でなければならないことは明らかである。しかしながら、いくつかの推論問題は*higher order*(高階)である。例えば、等号の置換演算 ``Eq.subst`` は以下の型を持っている:

.. code-block:: text

    Eq.subst : ∀ {α : Sort u} {p : α → Prop} {a b : α},
                 a = b → p a → p b

ここで、``a b : ℕ`` かつ ``h₁ : a = b`` かつ ``h₂ : a * b > a`` だとすると、``eq.subst h₁ h₂``において、``p`` は以下のいずれにもなりうる:

-  ``λ x, x * b > x``
-  ``λ x, x * b > a``
-  ``λ x, a * b > x``
-  ``λ x, a * b > a``

言い換えれば、ユーザーの意図は、``h₂`` の1番目か2番目の ``a`` だけを置き換えること、あるいは両方を置き換えること、あるいはどちらも置き換えないことかもしれない。同様の曖昧さは、帰納述語の推論や関数の引数の推論でも生じる。2階のユニフィケーションでさえ決定不可能であることが知られている。したがって、Leanはヒューリスティクスに依存してそのような引数を推論する。そしてLeanが正しい引数を推論できないときは、引数を明示的に与える必要がある。

さらに悪いことに、定義を展開する必要がある場合もあれば、基礎となる論理フレームワークの計算ルールに従って式を簡約化する必要がある場合もある。もう一度言うが、何をいつ展開し、簡約化するかを決めるために、Leanはヒューリスティクスに頼らなければならない。

しかしながら、elaboratorにヒントを提供するために使用できる属性がある。ある属性群は、定義がどの程度熱心に展開されるかを決定する: 定義・定数(定義された項)には ``[reducible]``、``[semireducible]``、``[irreducible]`` という属性を付けることができる。定義はデフォルトで ``[semireducible]`` とマークされる。``[reducible]`` 属性を付けられた定義は熱心に展開される。もしその定義を省略形として考えるのであれば、``[reducible]`` 属性を付けるのが適切だろう。elaborator は ``[irreducible]`` 属性を持つ定義の展開を避ける。定理はデフォルトで ``[irreducible]`` とマークされる。なぜなら、*proof irrelevance*(証明無関係)の原則により、一般的に証明の中身はelaborationのプロセスに関係ないからである。

これらの属性は、elaboratorへのヒントに過ぎないことを強調しておく。elaborateされた項の正しさをチェックするとき、Leanのカーネルは展開する必要のある定義全てを展開する。他の属性と同様に、上記の属性群は ``local`` 修飾子を付けて指定することができる。そうすれば、これらの属性が現在のセクションまたはファイル内だけで有効になる。

Leanはelaborationの戦略をコントロールする属性も持っている。定義や定理には ``[elab_with_expected_type]``、``[elab_simple]``、``[elab_as_eliminator]`` のいずれかの属性を付けることができる。これらの属性を定義 ``f`` に付けると、引数に ``f`` を適用した式 ``f a b c ...`` のelaborationを行うことができる。デフォルトの属性である ``[elab_with_expected_type]`` では、引数 ``a``、``b``、``c``、... は、 ``f`` と前の引数から推論される、期待される型に関する情報を使ってelaborateされる。一方、``[elab_simple]`` では、各引数の型に関する情報を後続の引数に伝搬することなく、単に左から右へと引数をelaborateしていく。最後の属性である ``[elab_as_eliminator]`` は、帰納器や帰納法原理、``eq.subst`` などの簡約器のためによく使われる。これは高階のパラメータを推論するために別のヒューリスティクスを使用する。このような操作については、次の章で詳しく説明する。

繰り返しになるが、これらの属性はオブジェクトが定義された後ならいつでも割り当てや再割り当てが可能であり、``local`` 修飾子を使ってその範囲を制限することができる。さらに、式の中で識別子の前に ``@`` 記号を書くと、Leanは自動でelaboratorに ``[elab_simple]`` 戦略を使うように指示する。これは、トリッキーなパラメータを明示的に提供する場合は、elaboratorにその情報を重視してもらいたいという考え方である。実際、Leanには ``@@`` という代替記号があり、これは最初の高階引数より前の引数を暗黙のままにしておくものである。例えば、``@@Eq.subst`` は等式の型を暗黙のままにするが、代入のコンテキストは明示する。

-->
<h2 id="using-the-library-ライブラリの使用"><a class="header" href="#using-the-library-ライブラリの使用">Using the Library (ライブラリの使用)</a></h2>
<p>Leanを効率的に使おうと思ったら、必然的にライブラリにある定義や定理を利用する必要が出てくるだろう。ファイルの先頭に <code>import</code> コマンドを書くと他のファイルから既にコンパイルされた結果をインポートできることと、インポートは推移的であることを思い出してほしい。現在のファイルが <code>Foo</code> をインポートし、<code>Foo</code> が <code>Bar</code> をインポートしているなら、現在のファイルで <code>Foo</code> のみならず <code>Bar</code> の定義や定理も利用できる。しかし、名前空間を開くという行為(これによりより短い名前が提供される)はインポート先に引き継がれない。各ファイルで、使用したい名前空間を開く必要がある。</p>
<p>一般に、ライブラリとその内容に詳しくなることは重要である。そうすれば、どのような定理、定義、記法、リソースが利用できるかを知ることができる。Leanのエディタモードも必要なものを見つけるのに役に立つが、ライブラリの内容を直接勉強することはしばしば避けられない。Leanの標準ライブラリはGitHubにあり、オンラインで見ることができる:</p>
<ul>
<li>
<p><a href="https://github.com/leanprover/lean4/tree/master/src/Init">https://github.com/leanprover/lean4/tree/master/src/Init</a></p>
</li>
<li>
<p><a href="https://github.com/leanprover/std4/tree/main/Std">https://github.com/leanprover/std4/tree/main/Std</a></p>
</li>
</ul>
<p>GitHubのブラウザインターフェースを使えば、これらのディレクトリやファイルの内容を見ることができる。自分のコンピュータにLeanをインストールした場合は、<code>lean</code> フォルダの中でライブラリ(例えば、<code>.../.elan/toolchains/leanprover--lean4---nightly/src/lean/Lean</code>)を見つけて、ファイルマネージャで探索することができる。各ファイルの先頭にあるコメントヘッダは、ファイルに関する追加情報を提供する。</p>
<p>Leanのライブラリ開発者は一般的な命名ガイドラインに従っている。そのため、ユーザーが必要な定理の名前を推測することや、Leanモードをサポートしているエディタでタブ補完を使って定理を見つけることがより簡単になっている。これらについては次の節で説明する。識別子は通常 <code>camelCase</code> で、型は <code>CamelCase</code> で命名される。定理には、異なる構成要素を <code>_</code> で区切った説明的な名前を宛てている(変数名は省略される)。多くの場合、定理の名前はシンプルに結論だけを表す:</p>
<pre><code class="language-lean">#check Nat.succ_ne_zero
#check Nat.zero_add
#check Nat.mul_one
#check Nat.le_of_succ_le_succ
</code></pre>
<p>Leanにおいて、識別子たちは階層的な名前空間の中で整理できることを覚えてほしい。例えば、名前空間 <code>Nat</code> の中の <code>le_of_succ_le_succ</code> という定理は <code>Nat.le_of_succ_le_succ</code> というフルネームを持っているが、コマンド <code>open Nat</code> を使うことで、(<code>protected</code> とマークされていない名前については)より短い名前が利用可能になる。Leanにおいて、構造体と帰納データ型を定義すると、定義した型に関連する操作が生成され、それらは定義中の型の名前と同じ名前の名前空間に格納されることは、<a href="./inductive_types.html">7章 Inductive Types (帰納型)</a>と<a href="./structures_and_records.html">9章 Structures and Records (構造体とレコード)</a>で説明する。例えば、直積型には以下の操作が付属している:</p>
<pre><code class="language-lean">#check @Prod.mk
#check @Prod.fst
#check @Prod.snd
#check @Prod.rec
</code></pre>
<p><code>Prod.mk</code> はペアを構成するために使われる。一方で、<code>Prod.fst</code> と <code>Prod.snd</code> はそれぞれ直積の1つ目の要素と2つ目の要素を射影する。<code>Prod.rec</code> は直積の2つの構成要素に対する関数から、直積に対する関数を定義するメカニズムを提供する。<code>Prod.rec</code> のような名前は<strong>保護されて</strong>おり、たとえ <code>Prod</code> 名前空間が開いているときでもフルネームを使用しなければならない。</p>
<p>型としての命題対応において、論理的結合子は帰納型の例である。したがって、論理的結合子に対してドット記法を使うことが多い:</p>
<pre><code class="language-lean">#check @And.intro
#check @And.casesOn
#check @And.left
#check @And.right
#check @Or.inl
#check @Or.inr
#check @Or.elim
#check @Exists.intro
#check @Exists.elim
#check @Eq.refl
#check @Eq.subst
</code></pre>
<h2 id="auto-bound-implicit-arguments-自動束縛暗黙引数"><a class="header" href="#auto-bound-implicit-arguments-自動束縛暗黙引数">Auto Bound Implicit Arguments (自動束縛暗黙引数)</a></h2>
<p>以前の節で、暗黙の引数が関数をより便利に使えるようにすることを示した。しかし、<code>compose</code> のような関数はまだ定義が冗長である。宇宙多相的な <code>compose</code> の定義は2章で定義したものよりもさらに冗長であることに注意してほしい。</p>
<pre><code class="language-lean">universe u v w
def compose {α : Type u} {β : Type v} {γ : Type w}
            (g : β → γ) (f : α → β) (x : α) : γ :=
  g (f x)
</code></pre>
<p><code>compose</code> を定義するときに宇宙パラメータ <code>.{u, v, w}</code> を与えることで、<code>universe</code> コマンドを省略することができる。</p>
<pre><code class="language-lean">def compose.{u, v, w}
            {α : Type u} {β : Type v} {γ : Type w}
            (g : β → γ) (f : α → β) (x : α) : γ :=
  g (f x)
</code></pre>
<p>Lean 4は、<em>auto bound implicit arguments</em>(自動束縛暗黙引数)という新機能をサポートしている。この機能により、<code>compose</code> のような関数をより便利に書くことができる。Leanが定義宣言の前提を処理するとき、まだ束縛されていない識別子が<strong>1文字の小文字かギリシャ文字であれば</strong>、それらが暗黙引数として自動的に追加される。この機能を使うと、 <code>compose</code> を次のように書くことができる。</p>
<pre><code class="language-lean">def compose (g : β → γ) (f : α → β) (x : α) : γ :=
  g (f x)

#check @compose
-- {β : Sort u_1} → {γ : Sort u_2} → {α : Sort u_3} → (β → γ) → (α → β) → α → γ
</code></pre>
<p><code>Type</code> の代わりに <code>Sort</code> を用いることで、Leanはより一般的な型を推論したことに注意してほしい。</p>
<p>私たち(原文筆者たち)はこの機能が大好きで、Leanを実装する際に広く使用しているが、一部のユーザーはこの機能を不快に感じるかもしれないことも認識している。そのため、コマンド <code>set_option autoImplicit false</code> を使ってこの機能を無効にすることができる。</p>
<pre><code class="language-lean">set_option autoImplicit false
/- 次の定義は `unknown identifier` エラーを生成する -/
-- def compose (g : β → γ) (f : α → β) (x : α) : γ :=
--   g (f x)
</code></pre>
<h2 id="implicit-lambdas-暗黙ラムダ式"><a class="header" href="#implicit-lambdas-暗黙ラムダ式">Implicit Lambdas (暗黙ラムダ式)</a></h2>
<p>Lean 3の標準ライブラリでは、<code>@</code> と <code>_</code> を多用した怖ろしいイディオム(コードパターン)の<a href="https://github.com/leanprover/lean/blob/master/library/init/category/reader.lean#L39">実例</a>をよく見かける。このイディオムは、期待される型が暗黙引数を持つ関数型で、さらに暗黙引数を取る定数(実例では <code>reader_t.pure</code>)がある場合によく使われる。Lean 4では、elaboratorにより暗黙引数を消費するためのラムダ式が自動的に導入される。私たちはこの機能を探究し、その影響を分析しているところだが、これまでの経験はとてもポジティブなものである。以下は、上記リンクの実例に対してLean 4の暗黙ラムダ式を使った例である。</p>
<pre><code class="language-lean"><span class="boring">variable (ρ : Type) (m : Type → Type) [Monad m]
</span>instance : Monad (ReaderT ρ m) where
  pure := ReaderT.pure
  bind := ReaderT.bind
</code></pre>
<p><code>@</code> を使うか、<code>{}</code> または <code>[]</code> 束縛記法でラムダ式を書くことで、暗黙ラムダ式機能を無効にすることができる。以下はその例である:</p>
<pre><code class="language-lean">namespace ex2
def id1 : {α : Type} → α → α :=
  fun x =&gt; x

def listId : List ({α : Type} → α → α) :=
  (fun x =&gt; x) :: []

-- 次の例において、``fun`` の前に ``@`` があるときは
-- 暗黙ラムダ式導入機能は無効になっている
def id2 : {α : Type} → α → α :=
  @fun α (x : α) =&gt; id1 x

def id3 : {α : Type} → α → α :=
  @fun α x =&gt; id1 x

def id4 : {α : Type} → α → α :=
  fun x =&gt; id1 x

-- 次の例では、束縛記法 ``{...}`` を使っているため、
-- 暗黙ラムダ式導入機能は無効になっている
def id5 : {α : Type} → α → α :=
  fun {α} x =&gt; id1 x
end ex2
</code></pre>
<h2 id="sugar-for-simple-functions-単純な関数のための糖衣構文"><a class="header" href="#sugar-for-simple-functions-単純な関数のための糖衣構文">Sugar for Simple Functions (単純な関数のための糖衣構文)</a></h2>
<p>Lean 3では、括弧を使うことで、中置演算子から簡単な関数を作ることができる。例えば、<code>(+1)</code> は <code>fun x, x + 1</code> の糖衣構文である。Lean 4では、<code>·</code> をプレースホルダーとして使うことでこの表記を一般化する。以下はその例である:</p>
<pre><code class="language-lean"><span class="boring">namespace ex3
</span>#check (· + 1)
-- fun a =&gt; a + 1
#check (2 - ·)
-- fun a =&gt; 2 - a
#eval [1, 2, 3, 4, 5].foldl (·*·) 1
-- 120

def f (x y z : Nat) :=
  x + y + z

#check (f · 1 ·)
-- fun a b =&gt; f a 1 b

#eval [(1, 2), (3, 4), (5, 6)].map (·.1)
-- [1, 3, 5]
<span class="boring">end ex3
</span></code></pre>
<p>Lean 3と同様、この糖衣構文は括弧を使うことでアクティベートされ、ラムダ抽象は括弧で囲まれた <code>·</code> を引数として集めることで作られる。引数の収集は、入れ子になった括弧によって中断される。次の例では、2つの異なるラムダ式が生成されている:</p>
<pre><code class="language-lean">#check (Prod.mk · (· + 1))
-- fun a =&gt; (a, fun b =&gt; b + 1)
</code></pre>
<h2 id="named-arguments-名前付き引数"><a class="header" href="#named-arguments-名前付き引数">Named Arguments (名前付き引数)</a></h2>
<p>名前付き引数を使うと、引数リスト内の位置と引数をマッチさせるだけでなく、関数定義時に指定された引数名と引数をマッチさせることができる。引数の順番は覚えていないが引数の名前は知っている場合、その名前を使えばどんな順番でもその引数を与えることができる。Leanが暗黙引数を推論できなかった場合、名前付き引数を使ってその暗黙引数の値を指定することもできる。名前付き引数は、各引数が何を表しているのかを明確にすることで、コードの読みやすさも向上させる。</p>
<pre><code class="language-lean">def sum (xs : List Nat) :=
  xs.foldl (init := 0) (·+·)

#eval sum [1, 2, 3, 4]
-- 10

example {a b : Nat} {p : Nat → Nat → Nat → Prop} (h₁ : p a b b) (h₂ : b = a)
    : p a a b :=
  Eq.subst (motive := fun x =&gt; p a x b) h₂ h₁
</code></pre>
<p>以下に、名前付き引数とデフォルト引数の相互作用を例示する。</p>
<pre><code class="language-lean">def f (x : Nat) (y : Nat := 1) (w : Nat := 2) (z : Nat) :=
  x + y + w - z
-- ``(y : Nat := 1)`` は ``y`` のデフォルトの値が ``1`` であることを表す

example (x z : Nat) : f (z := z) x = x + 1 + 2 - z := rfl

example (x z : Nat) : f x (z := z) = x + 1 + 2 - z := rfl

example (x y : Nat) : f x y = fun z =&gt; x + y + 2 - z := rfl

example : f = (fun x z =&gt; x + 1 + 2 - z) := rfl

example (x : Nat) : f x = fun z =&gt; x + 1 + 2 - z := rfl

example (y : Nat) : f (y := 5) = fun x z =&gt; x + 5 + 2 - z := rfl

def g {α} [Add α] (a : α) (b? : Option α := none) (c : α) : α :=
  match b? with
  | none   =&gt; a + c
  | some b =&gt; a + b + c

variable {α} [Add α]

example : g = fun (a c : α) =&gt; a + c := rfl

example (x : α) : g (c := x) = fun (a : α) =&gt; a + x := rfl

example (x : α) : g (b? := some x) = fun (a c : α) =&gt; a + x + c := rfl

example (x : α) : g x = fun (c : α) =&gt; x + c := rfl

example (x y : α) : g x y = fun (c : α) =&gt; x + y + c := rfl
</code></pre>
<p><code>..</code> を使えば、足りない明示的引数全てに <code>_</code> を指定することができる。この機能と名前付き引数を組み合わせると、パターンを書くのに便利である。以下はその例である:</p>
<pre><code class="language-lean">inductive Term where
  | var    (name : String)
  | num    (val : Nat)
  | app    (fn : Term) (arg : Term)
  | lambda (name : String) (type : Term) (body : Term)

def getBinderName : Term → Option String
  | Term.lambda (name := n) .. =&gt; some n
  | _ =&gt; none

def getBinderType : Term → Option Term
  | Term.lambda (type := t) .. =&gt; some t
  | _ =&gt; none
</code></pre>
<p>省略記号は、明示的な引数が自動的に推論され、かつ <code>_</code> の連続を避けたい場合にも便利である。</p>
<pre><code class="language-lean">example (f : Nat → Nat) (a b c : Nat) : f (a + b + c) = f (a + (b + c)) :=
  congrArg f (Nat.add_assoc ..)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inductive-types-帰納型"><a class="header" href="#inductive-types-帰納型">Inductive Types (帰納型)</a></h1>
<p>Leanの形式的基礎は <code>Prop, Type 0, Type 1, Type 2, ...</code> という基本的な型を含み、<code>(x : α) → β</code> といった依存関数型の形成を可能にすることが分かった。例の中では、<code>Bool</code>、<code>Nat</code>、<code>Int</code> などの追加的な型や、<code>List</code>、直積型 <code>×</code> などの型コンストラクタも使用した。実際、Leanのライブラリにおいて、宇宙以外の全ての具体的な型と、依存関数型以外の全ての型コンストラクタは、<em>inductive types</em>(帰納型)と呼ばれる型コンストラクタの集まりである(逆に、宇宙と依存関数型は<em>foundational types</em>(基礎型)として知られる)。型宇宙、依存関数型、そして帰納型のみで巨大で頑丈な数学の体系を構築できることは驚くべきことである。それ以外の全てはこの3種類の型から派生する。</p>
<p>直感的には、帰納型は指定されたコンストラクタのリストから構築される。Leanにおいて、帰納型を指定する構文は次の通りである:</p>
<pre><code>inductive Foo where
  | constructor₁ : ... → Foo
  | constructor₂ : ... → Foo
  ...
  | constructorₙ : ... → Foo
</code></pre>
<p>直感的には、各コンストラクタは、以前に構築された項から <code>Foo</code> の新しい項を構築する方法を指定する。<code>Foo</code> 型は各コンストラクタによって構築された項全てからなり、それ以外は何も含まない。帰納的宣言の最初の文字 <code>|</code> は省略可能である。<code>|</code> の代わりにコンマ <code>,</code> を使ってコンストラクタを区切ることもできる。</p>
<p>以下では、コンストラクタの引数に <code>Foo</code> 型の項を含めることができるが、その際に <code>Foo</code> の任意の要素がボトムアップで構築されることを保証する、ある「正の」制約が適用されることを説明する。大雑把に言えば、各コンストラクタの引数は <code>Foo</code> 型と以前に定義された型からなる任意の依存関数型を持つことができる。その依存関数型の中で、<code>Foo</code> は、もし現れるとすれば、「ターゲット」としてのみ現れる。</p>
<p>以下に帰納型の例をいくつか提供する。また、上記のスキームを少し一般化して、相互に定義された帰納型や、いわゆる<em>inductive families</em>(帰納族)についても考える。</p>
<p>論理的結合子と同様、全ての帰納型には導入則と除去則がある。導入則はその型の項の構築方法を示す。除去則は、その型の項を別の項の構築のために「使う」方法を示す。論理的結合子と帰納型の類似性は驚くにはあたらない。なぜなら、後述するように、論理的結合子たちも帰納的な型構築の例だからである。帰納型の導入則とは、すでに見た通りで型の定義で指定されるコンストラクタにすぎない。除去則はその型における再帰の原理を規定するものである。帰納法の原理は再帰の原理の特別な場合である。</p>
<p>次の章では、Leanの関数定義パッケージについて説明する。このパッケージは帰納型上の関数を定義し、帰納的証明を実行するためのさらに便利な方法を提供する。しかし、帰納型の概念は非常に基礎的で重要なため、低レベルで実践的な理解から始めることが重要だと考えている。ここでは、帰納型の基本的な例から始め、より精巧で複雑な例へとステップアップしていく。</p>
<h2 id="enumerated-types-列挙型"><a class="header" href="#enumerated-types-列挙型">Enumerated Types (列挙型)</a></h2>
<p>最も単純な帰納型は、列挙型、すなわち有限個の項を列挙したリストを持つ型である。</p>
<pre><code class="language-lean">inductive Weekday where
  | sunday : Weekday
  | monday : Weekday
  | tuesday : Weekday
  | wednesday : Weekday
  | thursday : Weekday
  | friday : Weekday
  | saturday : Weekday
</code></pre>
<p><code>inductive</code> コマンドは新しい型 <code>Weekday</code> を作成する。全てのコンストラクタは <code>Weekday</code> 名前空間の中に格納される。</p>
<pre><code class="language-lean"><span class="boring">inductive Weekday where
</span><span class="boring"> | sunday : Weekday
</span><span class="boring"> | monday : Weekday
</span><span class="boring"> | tuesday : Weekday
</span><span class="boring"> | wednesday : Weekday
</span><span class="boring"> | thursday : Weekday
</span><span class="boring"> | friday : Weekday
</span><span class="boring"> | saturday : Weekday
</span>#check Weekday.sunday
#check Weekday.monday

open Weekday

#check sunday
#check monday
</code></pre>
<p>帰納型 <code>Weekday</code> を宣言する際は、<code>: Weekday</code> を省略できる。</p>
<pre><code class="language-lean">inductive Weekday where
  | sunday
  | monday
  | tuesday
  | wednesday
  | thursday
  | friday
  | saturday
</code></pre>
<p><code>sunday</code>、<code>monday</code>、...、<code>saturday</code> は <code>Weekday</code> の互いに異なる項であり、それ以外に互いに異なる項はないと考えてほしい。除去則 <code>Weekday.rec</code> は 型 <code>Weekday</code> とそのコンストラクタを用いて定義されている。除去則は<em>recursor</em>(再帰子)とも呼ばれ、この型を<em>inductive</em>(帰納的)にしている: 除去則は、各コンストラクタに対応する値を割り当てることで、<code>Weekday</code> 上の関数を定義することを可能にしている。直感的には、帰納型の項は各コンストラクタによって網羅的に生成され、帰納型はコンストラクタが構築する項以外の項を持たないということである。</p>
<p><code>Weekday</code> から自然数への関数を定義するには、<code>match</code> 式を使うことができる:</p>
<pre><code class="language-lean"><span class="boring">inductive Weekday where
</span><span class="boring"> | sunday : Weekday
</span><span class="boring"> | monday : Weekday
</span><span class="boring"> | tuesday : Weekday
</span><span class="boring"> | wednesday : Weekday
</span><span class="boring"> | thursday : Weekday
</span><span class="boring"> | friday : Weekday
</span><span class="boring"> | saturday : Weekday
</span>open Weekday

def numberOfDay (d : Weekday) : Nat :=
  match d with
  | sunday    =&gt; 1
  | monday    =&gt; 2
  | tuesday   =&gt; 3
  | wednesday =&gt; 4
  | thursday  =&gt; 5
  | friday    =&gt; 6
  | saturday  =&gt; 7

#eval numberOfDay Weekday.sunday  -- 1
#eval numberOfDay Weekday.monday  -- 2
#eval numberOfDay tuesday         -- 3
</code></pre>
<p><code>match</code> 式は帰納型を宣言したときに生成された再帰子 <code>Weekday.rec</code> を使ってコンパイルされることに注意してほしい。</p>
<pre><code class="language-lean"><span class="boring">inductive Weekday where
</span><span class="boring"> | sunday : Weekday
</span><span class="boring"> | monday : Weekday
</span><span class="boring"> | tuesday : Weekday
</span><span class="boring"> | wednesday : Weekday
</span><span class="boring"> | thursday : Weekday
</span><span class="boring"> | friday : Weekday
</span><span class="boring"> | saturday : Weekday
</span>open Weekday

def numberOfDay (d : Weekday) : Nat :=
  match d with
  | sunday    =&gt; 1
  | monday    =&gt; 2
  | tuesday   =&gt; 3
  | wednesday =&gt; 4
  | thursday  =&gt; 5
  | friday    =&gt; 6
  | saturday  =&gt; 7

set_option pp.all true    -- 詳細な情報を表示させるオプション
#print numberOfDay
-- 定義中に``numberOfDay.match_1``というものが現れている
#print numberOfDay.match_1
-- 定義中に``Weekday.casesOn``というものが現れている
#print Weekday.casesOn
-- 定義中に``Weekday.rec``というものが現れている
#check @Weekday.rec
/-
@Weekday.rec.{u}
 : {motive : Weekday → Sort u} →
    motive Weekday.sunday →
    motive Weekday.monday →
    motive Weekday.tuesday →
    motive Weekday.wednesday →
    motive Weekday.thursday →
    motive Weekday.friday →
    motive Weekday.saturday →
    (t : Weekday) → motive t
-/
</code></pre>
<p>帰納データ型を宣言するとき、<code>deriving Repr</code> と書くと、<code>Weekday</code> の項をテキストに変換する関数を生成するようLeanに指示することができる。<code>#eval</code> コマンドはこの関数を使って <code>Weekday</code> の項を表示する。</p>
<pre><code class="language-lean">inductive Weekday where
  | sunday
  | monday
  | tuesday
  | wednesday
  | thursday
  | friday
  | saturday
  deriving Repr

open Weekday

#eval tuesday   -- Weekday.tuesday (``deriving Repr`` を外すとエラーになる)
</code></pre>
<p>ある帰納型に関連する定義や定理を、型と同じ名前の名前空間にまとめると便利なことが多い。例えば、<code>numberOfDay</code> 関数を <code>Weekday</code> 名前空間に置くとよい。そうすると、名前空間 <code>Weekday</code> を開いたときに、コンストラクタにも定義・定理・関数にも短い名前を用いてアクセスすることができる。</p>
<p><code>Weekday</code> から <code>Weekday</code> への関数を定義することができる:</p>
<pre><code class="language-lean"><span class="boring">inductive Weekday where
</span><span class="boring"> | sunday : Weekday
</span><span class="boring"> | monday : Weekday
</span><span class="boring"> | tuesday : Weekday
</span><span class="boring"> | wednesday : Weekday
</span><span class="boring"> | thursday : Weekday
</span><span class="boring"> | friday : Weekday
</span><span class="boring"> | saturday : Weekday
</span><span class="boring"> deriving Repr
</span>namespace Weekday
def next (d : Weekday) : Weekday :=
  match d with
  | sunday    =&gt; monday
  | monday    =&gt; tuesday
  | tuesday   =&gt; wednesday
  | wednesday =&gt; thursday
  | thursday  =&gt; friday
  | friday    =&gt; saturday
  | saturday  =&gt; sunday

def previous (d : Weekday) : Weekday :=
  match d with
  | sunday    =&gt; saturday
  | monday    =&gt; sunday
  | tuesday   =&gt; monday
  | wednesday =&gt; tuesday
  | thursday  =&gt; wednesday
  | friday    =&gt; thursday
  | saturday  =&gt; friday

#eval next (next tuesday)      -- Weekday.thursday
#eval next (previous tuesday)  -- Weekday.tuesday

example : next (previous tuesday) = tuesday :=
  rfl

end Weekday
</code></pre>
<p>どうすればより一般的な定理「任意のWeekday <code>d</code> に対して、<code>next (previous d) = d</code>」が証明できるだろうか。<code>match</code> を使うと各コンストラクタに対して主張の証明を与えることができる:</p>
<pre><code class="language-lean"><span class="boring">inductive Weekday where
</span><span class="boring"> | sunday : Weekday
</span><span class="boring"> | monday : Weekday
</span><span class="boring"> | tuesday : Weekday
</span><span class="boring"> | wednesday : Weekday
</span><span class="boring"> | thursday : Weekday
</span><span class="boring"> | friday : Weekday
</span><span class="boring"> | saturday : Weekday
</span><span class="boring"> deriving Repr
</span><span class="boring">namespace Weekday
</span><span class="boring">def next (d : Weekday) : Weekday :=
</span><span class="boring"> match d with
</span><span class="boring"> | sunday    =&gt; monday
</span><span class="boring"> | monday    =&gt; tuesday
</span><span class="boring"> | tuesday   =&gt; wednesday
</span><span class="boring"> | wednesday =&gt; thursday
</span><span class="boring"> | thursday  =&gt; friday
</span><span class="boring"> | friday    =&gt; saturday
</span><span class="boring"> | saturday  =&gt; sunday
</span><span class="boring">def previous (d : Weekday) : Weekday :=
</span><span class="boring"> match d with
</span><span class="boring"> | sunday    =&gt; saturday
</span><span class="boring"> | monday    =&gt; sunday
</span><span class="boring"> | tuesday   =&gt; monday
</span><span class="boring"> | wednesday =&gt; tuesday
</span><span class="boring"> | thursday  =&gt; wednesday
</span><span class="boring"> | friday    =&gt; thursday
</span><span class="boring"> | saturday  =&gt; friday
</span>theorem next_previous (d : Weekday) : next (previous d) = d :=
  match d with
  | sunday    =&gt; rfl
  | monday    =&gt; rfl
  | tuesday   =&gt; rfl
  | wednesday =&gt; rfl
  | thursday  =&gt; rfl
  | friday    =&gt; rfl
  | saturday  =&gt; rfl
</code></pre>
<p>タクティク証明を使えば、定理 <code>next_previous</code> の証明はより簡潔になる:</p>
<pre><code class="language-lean"><span class="boring">inductive Weekday where
</span><span class="boring"> | sunday : Weekday
</span><span class="boring"> | monday : Weekday
</span><span class="boring"> | tuesday : Weekday
</span><span class="boring"> | wednesday : Weekday
</span><span class="boring"> | thursday : Weekday
</span><span class="boring"> | friday : Weekday
</span><span class="boring"> | saturday : Weekday
</span><span class="boring"> deriving Repr
</span><span class="boring">namespace Weekday
</span><span class="boring">def next (d : Weekday) : Weekday :=
</span><span class="boring"> match d with
</span><span class="boring"> | sunday    =&gt; monday
</span><span class="boring"> | monday    =&gt; tuesday
</span><span class="boring"> | tuesday   =&gt; wednesday
</span><span class="boring"> | wednesday =&gt; thursday
</span><span class="boring"> | thursday  =&gt; friday
</span><span class="boring"> | friday    =&gt; saturday
</span><span class="boring"> | saturday  =&gt; sunday
</span><span class="boring">def previous (d : Weekday) : Weekday :=
</span><span class="boring"> match d with
</span><span class="boring"> | sunday    =&gt; saturday
</span><span class="boring"> | monday    =&gt; sunday
</span><span class="boring"> | tuesday   =&gt; monday
</span><span class="boring"> | wednesday =&gt; tuesday
</span><span class="boring"> | thursday  =&gt; wednesday
</span><span class="boring"> | friday    =&gt; thursday
</span><span class="boring"> | saturday  =&gt; friday
</span>def next_previous (d : Weekday) : next (previous d) = d := by
  cases d &lt;;&gt; rfl
</code></pre>
<p>以下の節 <a href="inductive_types.html#tactics-for-inductive-types-%E5%B8%B0%E7%B4%8D%E5%9E%8B%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AE%E3%82%BF%E3%82%AF%E3%83%86%E3%82%A3%E3%82%AF">Tactics for Inductive Types (帰納型のためのタクティク)</a> では、帰納型を利用するのに特化したタクティクを紹介する。</p>
<p>「型としての命題対応」の下では、定理証明と関数定義の両方に <code>match</code> を使えることに注目してほしい。言い換えれば、「型としての命題対応」の下では、場合分けによる証明は場合分けによる定義の一種なのである。そこには「定義」されるものが「データ型の項」なのか「命題型の証明」なのかの違いしかない。</p>
<p>Leanのライブラリにおいて、<code>Bool</code> 型は列挙型の一例である。</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>inductive Bool where
  | false : Bool
  | true  : Bool
<span class="boring">end Hidden
</span></code></pre>
<p>(この例において、標準ライブラリ内の <code>Bool</code> と今定義する <code>Bool</code> の衝突を防ぐために、今定義する <code>Bool</code> を名前空間 <code>Hidden</code> の中に置いた。この処置は必須である。なぜなら、<code>Bool</code> はLeanの標準ライブラリ内の最初のファイル <code>Init/Prelude.lean</code> の一部であり、Leanが起動したときに自動的にインポートされるからである。)</p>
<p>練習として、「<code>Bool</code> 型の導入則と除去則は何か」を考えるといいだろう。発展問題として、名前空間 <code>Hidden</code> の中で、自分の手で <code>Bool</code> 型と <code>Bool</code> 型上の演算子(ブーリアン演算子) <code>and</code>、<code>or</code>、<code>not</code> を定義し、それらに関する基本的な恒等式を証明してみることをお勧めする。<code>and</code> のような2項演算子は <code>match</code> を使って定義できることに注目してほしい:</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>def and (a b : Bool) : Bool :=
  match a with
  | true  =&gt; b
  | false =&gt; false
<span class="boring">end Hidden
</span></code></pre>
<p>同様に、ほとんどの恒等式は適切に <code>match</code> を使ってから <code>rfl</code> を使うことで証明できる。</p>
<h2 id="constructors-with-arguments-引数を持つコンストラクタ"><a class="header" href="#constructors-with-arguments-引数を持つコンストラクタ">Constructors with Arguments (引数を持つコンストラクタ)</a></h2>
<p>列挙型は、そのコンストラクタが全く引数を取らないという点で帰納型の非常に特殊な例である。一般的に、コンストラクタは入力データ(引数)を使って項を構築することができる。ライブラリ内の直積型と直和型の定義について考えてみよう:</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>inductive Prod (α : Type u) (β : Type v)
  | mk : α → β → Prod α β

inductive Sum (α : Type u) (β : Type v) where
  | inl : α → Sum α β
  | inr : β → Sum α β
<span class="boring">end Hidden
</span></code></pre>
<p>この例の中で何が起きているか考えてみよう。直積型は唯一のコンストラクタ <code>Prod.mk</code> を持ち、これは2つの引数を取る。<code>Prod α β</code> 型の項を引数にとる関数を定義するには、入力が <code>Prod.mk a b</code> の形であると仮定し、<code>a</code> と <code>b</code> を用いて出力を指定する必要がある。この関数定義法は <code>Prod α β</code> 型の項のための2つの射影を定義する際にも使える。標準ライブラリにおいて、記法 <code>α × β</code> は <code>Prod α β</code> を表し、<code>(a, b)</code> は <code>Prod.mk a b</code> を表すことを覚えてほしい。</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span><span class="boring">inductive Prod (α : Type u) (β : Type v)
</span><span class="boring">  | mk : α → β → Prod α β
</span>def fst {α : Type u} {β : Type v} (p : Prod α β) : α :=
  match p with
  | Prod.mk a b =&gt; a

def snd {α : Type u} {β : Type v} (p : Prod α β) : β :=
  match p with
  | Prod.mk a b =&gt; b
<span class="boring">end Hidden
</span></code></pre>
<p>関数 <code>fst</code> はペア <code>p</code> を受け取る。<code>match</code> は <code>p</code> をペア <code>Prod.mk a b</code> として解釈する。<a href="./dependent_type_theory.html">2章 Dependent Type Theory (依存型理論)</a>において、これらの定義に出来るだけ強い普遍性を与えるには、型 <code>α</code> と <code>β</code> がどの型宇宙に属していてもよいように定義を書く必要がある、と学んだことを思い出してほしい。</p>
<p>以下は <code>match</code> の代わりに再帰子 <code>Prod.casesOn</code> を使った例である。</p>
<pre><code class="language-lean">def prod_example (p : Bool × Nat) : Nat :=
  Prod.casesOn (motive := fun _ =&gt; Nat) p (fun b n =&gt; cond b (2 * n) (2 * n + 1))

#eval prod_example (true, 3)
#eval prod_example (false, 3)
</code></pre>
<p>引数 <code>motive</code> は構築したい項の型を指定するために使われる。そして、構築したい項の型は入力データ(この場合はペア)に依存して変わりうるので、<code>motive</code> は関数である。<code>cond</code> 関数はブール値を用いた条件分岐を実現する: <code>cond b t1 t2</code> は <code>b</code> が真なら <code>t1</code> を返し、そうでなければ <code>t2</code> を返す。上記の例で、関数 <code>prod_example</code> はブール値 <code>b</code> と自然数 <code>n</code> を取り、<code>b</code> が真なら <code>2 * n</code> を返し、<code>b</code> が偽なら <code>2 * n + 1</code> を返す。</p>
<p>対照的に、直和型は<strong>2つの</strong>コンストラクタ <code>inl</code> と <code>inr</code> (&quot;insert left&quot;と&quot;insert right&quot;の略) を持ち、それぞれは<strong>1つの</strong>(明示的な)引数を取る。<code>Sum α β</code> 型の項を引数にとる関数を定義するには、2つの場合に対応しなければならない: 入力が <code>inl a</code> の形なら <code>a</code> を使って出力する値を指定する必要がある。入力が <code>inr b</code> の形なら <code>b</code> を使って出力する値を指定する必要がある。</p>
<pre><code class="language-lean">def sum_example (s : Sum Nat Nat) : Nat :=
  Sum.casesOn (motive := fun _ =&gt; Nat) s
    (fun n =&gt; 2 * n)
    (fun n =&gt; 2 * n + 1)

#eval sum_example (Sum.inl 3)
#eval sum_example (Sum.inr 3)

def sum_example2 (s : Sum Nat Nat) : Nat :=
  match s with
  | Sum.inl a =&gt; 2 * a
  | Sum.inr b =&gt; 2 * b + 1

#eval sum_example2 (Sum.inl 3)
#eval sum_example2 (Sum.inr 3)
</code></pre>
<p>この例は1つ前の例に似ている。しかし、この例では <code>sum_example</code> への入力は暗黙的に <code>inl n</code> か <code>inr n</code> のいずれかの形をとる。1つ目の場合なら関数は <code>2 * n</code> を返し、2つ目の場合なら関数は <code>2 * n + 1</code> を返す。</p>
<p>直積型は引数 <code>α β : Type</code> を持つことに注意してほしい。これらは <code>Prod</code> の引数であると同時に、<code>Prod</code> のコンストラクタの引数の型でもある。引数 <code>α β</code> がコンストラクタへの後続の引数や戻り値の型から推論できる場合、Leanは引数 <code>α β</code> が何であるかを特定し、それらを暗黙の引数にする。</p>
<p><a href="inductive_types.html#defining-the-natural-numbers-%E8%87%AA%E7%84%B6%E6%95%B0%E3%82%92%E5%AE%9A%E7%BE%A9%E3%81%99%E3%82%8B">Defining the Natural Numbers (自然数を定義する)</a>の節では、帰納型のコンストラクタがその帰納型自体の項を引数として取るときに何が起こるかを説明する。その節で考える例の特徴は、各コンストラクタが当該型の項として既に特定された項のみを引数として取ることである。</p>
<p>複数のコンストラクタを持つ型は「選言的」であることに注意してほしい: <code>Sum α β</code> の項は <code>inl a</code> <strong>または</strong> <code>inr b</code> の形をしている。複数の引数を取るコンストラクタは「連言的」な情報を提供する: <code>Prod α β</code> の項 <code>Prod.mk a b</code> からは <code>a</code> <strong>と</strong> <code>b</code> を抽出することができる。任意の帰納型は、任意個のコンストラクタを持つことができ、各コンストラクタは任意個の引数を取ることができるので、選言的かつ連言的な特徴を持つ可能性がある。</p>
<p>関数定義と同様に、Leanの帰納型定義構文内では、コンストラクタ名とコロンの間に名前付き引数を与えることができる:</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>inductive Prod (α : Type u) (β : Type v) where
  | mk (fst : α) (snd : β) : Prod α β

inductive Sum (α : Type u) (β : Type v) where
  | inl (a : α) : Sum α β
  | inr (b : β) : Sum α β
<span class="boring">end Hidden
</span></code></pre>
<p>これらの定義は上で与えた定義と本質的に同じである。</p>
<p><code>Prod</code> のように、ただ1つのコンストラクタを持つ型は純粋に連言的である: そのコンストラクタは単に引数のリストを1つのデータにまとめる。このようなデータは後続の要素の型が最初の要素の型に依存することができるタプルと本質的に同じである。このような型は<em>record</em>(レコード)あるいは<em>structure</em>(構造体)と呼ばれる。Leanでは、キーワード <code>structure</code> を使うと、レコードや構造体の定義とその射影の定義を同時に行うことができる。</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>structure Prod (α : Type u) (β : Type v) where
  mk :: (fst : α) (snd : β)
<span class="boring">end Hidden
</span></code></pre>
<p>この例では、帰納型 <code>Prod</code>、そのコンストラクタ <code>mk</code>、通常のエリミネータ(<code>rec</code> と <code>recOn</code>)と射影 <code>fst</code> と <code>snd</code> (上で定義したものと同じ)を同時に定義している。</p>
<p>コンストラクタに名前を付けなかった場合、デフォルトのコンストラクタの名前として <code>mk</code> が使われる。次の例は、RGB値の3つ組として色を保存するレコードを定義する:</p>
<pre><code class="language-lean">structure Color where
  (red : Nat) (green : Nat) (blue : Nat)
  deriving Repr

def yellow := Color.mk 255 255 0

#print Color.red  -- ``structure`` キーワードにより生成された射影関数
#eval Color.red yellow
</code></pre>
<p><code>yellow</code> の定義は3つの値を持ったレコードを形成する。そして射影 <code>Color.red</code> は赤の要素を返す。</p>
<p>各フィールドの間に改行を挟めば、括弧の使用を避けることができる。</p>
<pre><code class="language-lean">structure Color where
  red : Nat
  green : Nat
  blue : Nat
  deriving Repr
</code></pre>
<p><code>structure</code> コマンドは代数的構造を定義するときに特に有用である。Leanは代数的構造を扱うための実質的なインフラを提供している。例えば、以下は半群の定義である:</p>
<pre><code class="language-lean">structure Semigroup where
  carrier : Type u
  mul : carrier → carrier → carrier
  mul_assoc : ∀ a b c, mul (mul a b) c = mul a (mul b c)
</code></pre>
<p><a href="./structures_and_records.html">9章 Structures and Records</a>ではさらに例を見ていく。</p>
<p>依存直積型 <code>Sigma</code> は既に紹介した:</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>inductive Sigma {α : Type u} (β : α → Type v) where
  | mk : (a : α) → β a → Sigma β
<span class="boring">end Hidden
</span></code></pre>
<p>次はライブラリ内にあるさらに2つの帰納型の例である:</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>inductive Option (α : Type u) where
  | none : Option α
  | some : α → Option α

inductive Inhabited (α : Type u) where
  | mk : α → Inhabited α
<span class="boring">end Hidden
</span></code></pre>
<p>依存型理論の意味論では、全ての関数は全域関数である。関数型 <code>α → β</code> または依存関数型 <code>(a : α) → β</code> の各項は、全ての入力に対して一意の値を持つと想定される。したがって、依存型理論の意味論に部分関数の概念は組み込まれていない。しかし、<code>Option</code> 型を使うと(全域関数を使って)部分関数を表現することができる。<code>Option β</code> の項は、<code>none</code> か <code>some b</code>(ここで、<code>b : β</code>) の形をとる。したがって、<code>α → Option β</code> 型の項 <code>f</code> は、<code>α</code> から <code>β</code> への部分関数であると考えることができる: 任意の <code>a : α</code> に対して、<code>f a</code> は <code>none</code> か <code>some b</code> を返す。<code>none</code> は <code>f a</code> が「未定義」であることを表す。</p>
<p><code>Inhabited α</code> の項は、単に <code>α</code> の項が存在することの証人となる。後ほど、Leanにおいて <code>Inhabited</code> が<em>type class</em>(型クラス)の一例であることを説明する: Leanに適切な基底型が<em>inhabited</em>(有項)であると指示することができる。Leanはその指示に基づいて、他の構築された型が有項であることを自動的に推論することができる。</p>
<p>練習として、<code>α</code> から <code>β</code> への部分関数と <code>β</code> から <code>γ</code> への部分関数の合成の概念を定義し、それが期待通りの振る舞いをすることを示すことを勧める。また、<code>Bool</code> と <code>Nat</code> が有項であること、2つの有項な型の直積型が有項であること、有項な型への関数の型は有項であることを示すことも勧める。</p>
<h2 id="inductively-defined-propositions-帰納的に定義された命題"><a class="header" href="#inductively-defined-propositions-帰納的に定義された命題">Inductively Defined Propositions (帰納的に定義された命題)</a></h2>
<p>帰納的に定義された型は、一番下の型である <code>Prop</code> を含め、どの階層の型宇宙にも住むことができる。実際、論理的結合子は次のように定義されている。</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>inductive False : Prop

inductive True : Prop where
  | intro : True

inductive And (a b : Prop) : Prop where
  | intro : a → b → And a b

inductive Or (a b : Prop) : Prop where
  | inl : a → Or a b
  | inr : b → Or a b
<span class="boring">end Hidden
</span></code></pre>
<p>これらの定義が、すでに見た論理的結合子の導入則と除去則をどのように生み出すのかを考える必要がある。帰納型のエリミネータがその型を除去して<strong>何の型を作れるか</strong>を規定するルールがある。つまり、どのような型を再帰子の対象とすることができるかを規定するルールがある。大雑把に言えば、<code>Prop</code> に属する帰納型には、その型を除去することで <code>Prop</code> に属する他の型しか作ることができないというルールがある。これは、「もし <code>p : Prop</code>なら、<code>hp : p</code> は何のデータも持たない」という理解と矛盾しない。しかしながら、<a href="inductive_types.html#inductive-families-%E5%B8%B0%E7%B4%8D%E6%97%8F">Inductive Families (帰納族)</a>の節で説明するように、このルールには小さな例外がある。</p>
<p>存在量化子でさえ帰納的に定義されている:</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>inductive Exists {α : Sort u} (p : α → Prop) : Prop where
  | intro (w : α) (h : p w) : Exists p
<span class="boring">end Hidden
</span></code></pre>
<p>記法 <code>∃ x : α, p</code> は <code>Exists (fun x : α =&gt; p)</code> の糖衣構文であることを思い出してほしい。</p>
<p><code>False</code>、<code>True</code>、<code>And</code>、<code>Or</code> の定義は、<code>Empty</code>、<code>Unit</code>、<code>Prod</code>、<code>Sum</code> の定義と完全に類似している。違いは、最初のグループは <code>Prop</code> の項を生成し、2番目のグループはある宇宙パラメータ <code>u</code> に対して <code>Type u</code> の項を生成することである。同様に、<code>∃ x : α, p</code> と <code>Σ x : α, p</code> は類似しているが、前者は <code>Prop</code> の項で、後者は <code>Type u</code> の項である。</p>
<p>もうひとつの帰納型 <code>{x : α // p}</code> に触れる良い機会だろう。これは、<code>∃ x : α, P</code> と <code>Σ x : α, P</code> のハイブリッドのようなものである。</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>inductive Subtype {α : Type u} (p : α → Prop) where
  | mk : (x : α) → p x → Subtype p
<span class="boring">end Hidden
</span></code></pre>
<p>実際には、Leanでは <code>Subtype</code> は <code>structure</code> コマンドを使って定義されている:</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>structure Subtype {α : Sort u} (p : α → Prop) where
  val : α
  property : p val
<span class="boring">end Hidden
</span></code></pre>
<p>記法 <code>{x : α // p x}</code> は <code>Subtype (fun x : α =&gt; p x)</code> の糖衣構文である。これは集合論における部分集合の内包的表記をモデルにしている: <code>{x : α // p x}</code> は性質 <code>p</code> を持つ <code>α</code> の要素全体からなる集合を表す。</p>
<h2 id="defining-the-natural-numbers-自然数を定義する"><a class="header" href="#defining-the-natural-numbers-自然数を定義する">Defining the Natural Numbers (自然数を定義する)</a></h2>
<p>これまで見てきた帰納型は「フラット」である: コンストラクタはデータ(引数)を包んである型の項を作り、対応する再帰子はその項を展開してそれに作用する。コンストラクタがそのコンストラクタたちによってまさに今帰納的に定義されている型の項を受け取ると、物事はもっと面白くなる。典型的な例が自然数の型 <code>Nat</code> である:</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>inductive Nat where
  | zero : Nat
  | succ : Nat → Nat
<span class="boring">end Hidden
</span></code></pre>
<p><code>Nat</code> のコンストラクタは2つある。まずは <code>zero : Nat</code> から始める。コンストラクタ <code>zero</code> は引数を取らないので、<code>Nat</code> は最初から項 <code>zero</code> を持っている。対照的に、コンストラクタ <code>succ</code> は既に構築された <code>Nat</code> の項に対してのみ適用できる。これを <code>zero</code> に適用すると、<code>succ zero : Nat</code> が得られる。もう一度適用すると <code>succ (succ zero) : Nat</code> が得られる。直感的には、<code>Nat</code> はこのようなコンストラクタを持つ「最小の」型であるといえる。このようなコンストラクタを持つことは、<code>Nat</code> の項は、 <code>zero</code> から始めて <code>succ</code> を繰り返し適用することで網羅的に(そして自由に)生成されることを意味する。</p>
<p>以前と同様に、<code>Nat</code> のための再帰子は、<code>Nat</code> から任意の型への依存関数 <code>f</code>、つまりある <code>motive : Nat → Sort u</code> について <code>(n : Nat) → motive n</code> の項 <code>f</code> を定義するように設計されている。再帰子は、入力が <code>zero</code> の場合と、入力がある <code>n : Nat</code> について <code>succ n</code> の形をとる場合の2種類の場合に対応しなければならない。最初のケースでは、先ほどと同じように、適切な型を持つ出力値を指定するだけでよい。2番目のケースはそうはいかない。しかし、2番目のケースでは、再帰子は <code>n</code> における <code>f</code> の値がすでに計算されていると想定することができる。その結果、再帰子の次の引数は <code>n</code> と <code>f n</code> を用いて <code>f (succ n)</code> の値を指定する。再帰子 <code>Nat.rec</code> の型をチェックしてみると、</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span><span class="boring">inductive Nat where
</span><span class="boring"> | zero : Nat
</span><span class="boring"> | succ : Nat → Nat
</span>#check @Nat.rec
<span class="boring">end Hidden
</span></code></pre>
<p>次のような表示が得られる:</p>
<pre><code>  {motive : Nat → Sort u}
  → motive Nat.zero
  → ((n : Nat) → motive n → motive (Nat.succ n))
  → (t : Nat) → motive t
</code></pre>
<p>暗黙の引数 <code>motive</code> は、定義される関数のコドメインである。型理論では、<code>motive</code> は除去/再帰の<em>motive</em>(動機)であると言うのが一般的である。それは <code>motive t</code> が入力 <code>t</code> に対して構築したい項の型を表しているからである。<code>motive</code> の次の2つの引数は、上述した2つの場合、つまり入力が <code>zero</code> の場合と <code>succ n</code> の形をとる場合の計算方法をそれぞれ指定する。この2つの引数は<em>minor premises</em>(小前提)としても知られている。最後に、<code>t : Nat</code> は定義したい関数への入力である。入力 <code>t</code> は<em>major premise</em>(大前提)としても知られている。 </p>
<p><code>Nat.recOn</code> は <code>Nat.rec</code> とほとんど同じだが、大前提が小前提の前に現れている。</p>
<pre><code>@Nat.recOn :
  {motive : Nat → Sort u}
  → (t : Nat)
  → motive Nat.zero
  → ((n : Nat) → motive n → motive (Nat.succ n))
  → motive t
</code></pre>
<p>例えば、自然数に対する加法関数 <code>add m n</code> を定義することを考えてみよう。<code>m</code> を固定すると、<code>n</code> に関する再帰によって加法を定義することができる。base caseでは、<code>add m zero</code> を <code>m</code> と定義する。successor stepでは、<code>add m n</code> の値が既に決定されていると仮定して、<code>add m (succ n)</code> を <code>succ (add m n)</code> と定義する。</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>inductive Nat where
  | zero : Nat
  | succ : Nat → Nat
  deriving Repr

def add (m n : Nat) : Nat :=
  match n with
  | Nat.zero   =&gt; m
  | Nat.succ n =&gt; Nat.succ (add m n)

open Nat

#eval add (succ (succ zero)) (succ zero)
<span class="boring">end Hidden
</span></code></pre>
<p>このような関数定義は名前空間 <code>Nat</code> に入れておくと便利である。それから、その名前空間の中でお馴染みの記法 <code>+</code> を定義することができる。ここまですると、加法に関する2つの等式が成立することが定義により示せる:</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span><span class="boring">inductive Nat where
</span><span class="boring"> | zero : Nat
</span><span class="boring"> | succ : Nat → Nat
</span><span class="boring"> deriving Repr
</span>namespace Nat

def add (m n : Nat) : Nat :=
  match n with
  | Nat.zero   =&gt; m
  | Nat.succ n =&gt; Nat.succ (add m n)

instance : Add Nat where
  add := add

theorem add_zero (m : Nat) : m + zero = m := rfl
theorem add_succ (m n : Nat) : m + succ n = succ (m + n) := rfl

end Nat
<span class="boring">end Hidden
</span></code></pre>
<p><code>instance</code> コマンドがどのように機能するかは、<a href="./type_classes.html">10章 Type Classes (型クラス)</a>で説明する。以下の例では、Leanの標準ライブラリで定義された自然数を使う。</p>
<p>上記では <code>rfl</code> を使うだけで定理が証明できた。しかし、<code>zero + m = m</code> のような定理は帰納法による証明を必要とする。上述の通り、帰納法の原理は再帰の原理の特殊な場合にすぎない。帰納法において、<code>motive n</code> のコドメインは一般的な型 <code>Sort u</code> ではなく <code>Prop</code> である。これは帰納法による証明のお馴染みのパターンを表現している: <code>∀ n, motive n</code> を証明するために、まず <code>motive 0</code> を証明する。次に任意の <code>n : Nat</code> について <code>ih : motive n</code> を仮定し、その上で <code>motive (succ n)</code> を証明する。</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>open Nat

theorem zero_add (n : Nat) : 0 + n = n :=
  Nat.recOn (motive := fun x =&gt; 0 + x = x)
   n
   (show 0 + 0 = 0 from rfl)
   (fun (n : Nat) (ih : 0 + n = n) =&gt;
    show 0 + succ n = succ n from
    calc 0 + succ n
      _ = succ (0 + n) := rfl
      _ = succ n       := by rw [ih])
<span class="boring">end Hidden
</span></code></pre>
<p>繰り返しになるが、証明内で <code>Nat.recOn</code> を使うことは、証明内で帰納法の原理を使うことを意味することに注意してほしい。このような証明において、<code>rewrite</code> タクティクと <code>simp</code> タクティクは非常に効果的である。今回の場合、<code>simp</code> タクティクを使うと次のように証明を短くすることができる:</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>open Nat

theorem zero_add (n : Nat) : 0 + n = n :=
  Nat.recOn (motive := fun x =&gt; 0 + x = x) n
    rfl
    (fun n ih =&gt; by simp [add_succ, ih])
<span class="boring">end Hidden
</span></code></pre>
<p>もう一つの例として、加法の結合性 <code>∀ m n k, m + n + k = m + (n + k)</code> を証明しよう。ここで、<code>+</code> という記法は左結合的なので、<code>m + n + k</code> とは <code>(m + n) + k</code> のことである。一番難しいのは、どの変数に関して帰納法を行うかの見当をつけることだ。加法は2番目の引数に関する再帰によって定義されるため、<code>k</code> を選ぶのはよい判断である。一度変数を選択すれば、証明はほとんど自ずと導かれる:</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>open Nat
theorem add_assoc (m n k : Nat) : m + n + k = m + (n + k) :=
  Nat.recOn (motive := fun k =&gt; m + n + k = m + (n + k)) k
    (show m + n + 0 = m + (n + 0) from rfl)
    (fun k (ih : m + n + k = m + (n + k)) =&gt;
      show m + n + succ k = m + (n + succ k) from
      calc m + n + succ k
        _ = succ (m + n + k)   := rfl
        _ = succ (m + (n + k)) := by rw [ih]
        _ = m + succ (n + k)   := rfl
        _ = m + (n + succ k)   := rfl)
<span class="boring">end Hidden
</span></code></pre>
<p>再び、<code>simp</code> タクティクを使って証明を短くすることができる:</p>
<pre><code class="language-lean">open Nat
theorem add_assoc (m n k : Nat) : m + n + k = m + (n + k) :=
  Nat.recOn (motive := fun k =&gt; m + n + k = m + (n + k)) k
    rfl
    (fun k ih =&gt; by simp [Nat.add_succ, ih])
</code></pre>
<p>次は加法の可換性を証明してみよう。2番目の引数に関して帰納法を行うことを選択すると、次のように証明を始めることができる:</p>
<pre><code class="language-lean">open Nat
theorem add_comm (m n : Nat) : m + n = n + m :=
  Nat.recOn (motive := fun x =&gt; m + x = x + m) n
   (show m + 0 = 0 + m by rw [Nat.zero_add, Nat.add_zero])
   (fun (n : Nat) (ih : m + n = n + m) =&gt;
    show m + succ n = succ n + m from
    calc m + succ n
      _ = succ (m + n) := rfl
      _ = succ (n + m) := by rw [ih]
      _ = succ n + m   := sorry)
</code></pre>
<p>ここで、もう1つの補題 <code>succ n + m = succ (n + m)</code> が必要であるとわかる。これは <code>m</code> に関する帰納法で証明できる:</p>
<pre><code class="language-lean">open Nat

theorem succ_add (n m : Nat) : succ n + m = succ (n + m) :=
  Nat.recOn (motive := fun x =&gt; succ n + x = succ (n + x)) m
    (show succ n + 0 = succ (n + 0) from rfl)
    (fun (m : Nat) (ih : succ n + m = succ (n + m)) =&gt;
     show succ n + succ m = succ (n + succ m) from
     calc succ n + succ m
       _ = succ (succ n + m)   := rfl
       _ = succ (succ (n + m)) := by rw [ih]
       _ = succ (n + succ m)   := rfl)
</code></pre>
<p>それから、上記の証明の <code>sorry</code> を <code>succ_add</code> に置き換えて、証明を完結させることができる。再び、これらの証明は短くできる:</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>open Nat
theorem succ_add (n m : Nat) : succ n + m = succ (n + m) :=
  Nat.recOn (motive := fun x =&gt; succ n + x = succ (n + x)) m
    rfl
    (fun m ih =&gt; by simp only [add_succ, ih])

theorem add_comm (m n : Nat) : m + n = n + m :=
  Nat.recOn (motive := fun x =&gt; m + x = x + m) n
    (by simp)
    (fun m ih =&gt; by simp [add_succ, succ_add, ih])
<span class="boring">end Hidden
</span></code></pre>
<h2 id="other-recursive-data-types-他の再帰データ型"><a class="header" href="#other-recursive-data-types-他の再帰データ型">Other Recursive Data Types (他の再帰データ型)</a></h2>
<p>帰納的に定義された型の例をもう少し考えてみよう。任意の型 <code>α</code> に対して、いくつかの <code>α</code> の項からなるリストの型 <code>List α</code> がライブラリで定義されている。</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>inductive List (α : Type u) where
  | nil  : List α
  | cons : α → List α → List α

namespace List

def append (as bs : List α) : List α :=
  match as with
  | nil       =&gt; bs
  | cons a as =&gt; cons a (append as bs)

theorem nil_append (as : List α) : append nil as = as :=
  rfl

theorem cons_append (a : α) (as bs : List α)
                    : append (cons a as) bs = cons a (append as bs) :=
  rfl

end List
<span class="boring">end Hidden
</span></code></pre>
<p><code>α</code> 型の項を要素に持つリストは、空リスト <code>nil</code> か <code>cons h t</code> の形をとるかのいずれかである。ここで、<code>cons h t</code> は項 <code>h : α</code> の後にリスト <code>t : List α</code> が続くリストである。最初の要素 <code>h</code> は一般にリストの&quot;head&quot;と呼ばれ、残りの要素 <code>t</code> は&quot;tail&quot;と呼ばれる。</p>
<p>練習問題として、以下の定理を証明せよ:</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span><span class="boring">inductive List (α : Type u) where
</span><span class="boring">| nil  : List α
</span><span class="boring">| cons : α → List α → List α
</span><span class="boring">namespace List
</span><span class="boring">def append (as bs : List α) : List α :=
</span><span class="boring"> match as with
</span><span class="boring"> | nil       =&gt; bs
</span><span class="boring"> | cons a as =&gt; cons a (append as bs)
</span><span class="boring">theorem nil_append (as : List α) : append nil as = as :=
</span><span class="boring"> rfl
</span><span class="boring">theorem cons_append (a : α) (as bs : List α)
</span><span class="boring">                    : append (cons a as) bs = cons a (append as bs) :=
</span><span class="boring"> rfl
</span>theorem append_nil (as : List α) : append as nil = as :=
  sorry

theorem append_assoc (as bs cs : List α)
        : append (append as bs) cs = append as (append bs cs) :=
  sorry
<span class="boring">end List
</span><span class="boring">end Hidden
</span></code></pre>
<p>また、リストの長さを返す関数 <code>length : {α : Type u} → List α → Nat</code> を定義せよ。さらにそれが期待通りに振る舞うことを証明せよ。例えば、<code>length (append as bs) = length as + length bs</code> を証明せよ。</p>
<p>別の例として、binary trees((全)二分木)の型を定義することができる:</p>
<pre><code class="language-lean">/- 1. ただ1つの頂点からなる有向グラフは全二分木である。
   2. 次数0の頂点vと2つの全二分木A,Bを用意し、
   ラベル付き有向辺(左,v,Aの根)と(右,v,Bの根)を追加し、vを根としたものは全二分木である。
   3. 以上の手続きで全二分木だとわかるものだけが全二分木である。 -/
inductive BinaryTree where
  | leaf : BinaryTree
  | root (left : BinaryTree) (right : BinaryTree) : BinaryTree
</code></pre>
<p>countably branching trees((全)可算無限分木)の型を定義することさえできる:</p>
<pre><code class="language-lean">/- 1. ただ1つの頂点からなる有向グラフは全可算無限分木である。
   2. 次数0の頂点vと2つの全可算無限分木T_0,T_1,...を用意し、
   ラベル付き有向辺(0,v,T_0の根),(1,v,T_1の根),...を追加し、vを根としたものは全可算無限分木である。
   3. 以上の手続きで全可算無限分木だとわかるものだけが全可算無限分木である。 -/
inductive CBTree where
  | leaf : CBTree
  | sup : (Nat → CBTree) → CBTree

namespace CBTree

def succ (t : CBTree) : CBTree :=
  sup (fun _ =&gt; t)

def toCBTree : Nat → CBTree
  | 0 =&gt; leaf
  | n+1 =&gt; succ (toCBTree n)

def omega : CBTree :=
  sup toCBTree

end CBTree
</code></pre>
<h2 id="tactics-for-inductive-types-帰納型のためのタクティク"><a class="header" href="#tactics-for-inductive-types-帰納型のためのタクティク">Tactics for Inductive Types (帰納型のためのタクティク)</a></h2>
<p>Leanにおける帰納型の基礎的な重要性を鑑みれば、帰納型を効率的に扱うためにデザインされたタクティクが数多くあることは驚くことではない。ここではそのようなタクティクのいくつかを紹介する。</p>
<p><code>cases</code> タクティクは帰納的に定義された型の項に対して機能し、その名前が示す通りの働きをする: <code>cases</code> タクティクは存在する各コンストラクタに従って項を分解する。最も基本的な形では、<code>cases</code> タクティクは現在のコンテキスト内の項 <code>x</code> に適用される。そして、<code>x</code> を各コンストラクタで置換して、ゴールを場合分けする。</p>
<pre><code class="language-lean">example (p : Nat → Prop) (hz : p 0) (hs : ∀ n, p (Nat.succ n)) : ∀ n, p n := by
  intro n
  cases n
  . exact hz  -- goal is p 0
  . apply hs  -- goal is a : Nat ⊢ p (succ a)
</code></pre>
<p>さらに便利な機能がある。まず、<code>with</code> キーワードを使うと、<code>cases</code> タクティク使用時の各場合分けにおいて変数に名前を付けることができる。次の例では、<code>succ</code> の引数に <code>m</code> という名前を付け、2番目の場合で <code>n</code> を <code>succ m</code> で置換するように指示している。さらに重要なのは、<code>cases</code> タクティクが、現在のコンテキスト内にある、場合分け対象の変数に依存する型を持つ項を検出することである。<code>cases</code> タクティクはこれらの項をゴールのターゲットに戻し、ゴールを場合分けし、再び項をゴールのコンテキストに導入する。次の例では、仮説 <code>h : n ≠ 0</code> が最初の分岐では <code>h : 0 ≠ 0</code> になり、2番目の分岐では <code>h : succ m ≠ 0</code> になることに注目してほしい。</p>
<pre><code class="language-lean">open Nat

example (n : Nat) (h : n ≠ 0) : succ (pred n) = n := by
  cases n with
  | zero =&gt;
    -- goal: h : 0 ≠ 0 ⊢ succ (pred 0) = 0
    apply absurd rfl h
  | succ m =&gt;
    -- second goal: h : succ m ≠ 0 ⊢ succ (pred (succ m)) = succ m
    rfl
</code></pre>
<p><code>cases</code> は命題を証明するだけでなく、データを生成するためにも使用できることに注目してほしい。</p>
<pre><code class="language-lean">def f (n : Nat) : Nat := by
  cases n; exact 3; exact 7

example : f 0 = 3 := rfl
example : f 5 = 7 := rfl
</code></pre>
<p>繰り返しになるが、<code>cases x</code> はコンテキスト内にある <code>x</code> に依存する型を持つ項をターゲットに戻し、ゴールを場合分けし、再び項をコンテキストに導入する。</p>
<pre><code class="language-lean">def Tuple (α : Type) (n : Nat) :=
  { as : List α // as.length = n }

def f {n : Nat} (t : Tuple α n) : Nat := by
  cases n; exact 3; exact 7

def myTuple : Tuple Nat 3 :=
  ⟨[0, 1, 2], rfl⟩

example : f myTuple = 7 :=
  rfl
</code></pre>
<p>次は引数をとる複数のコンストラクタを持つ帰納型における例である。</p>
<pre><code class="language-lean">inductive Foo where
  | bar1 : Nat → Nat → Foo
  | bar2 : Nat → Nat → Nat → Foo

def silly (x : Foo) : Nat := by
  cases x with
  | bar1 a b =&gt; exact b
  | bar2 c d e =&gt; exact e

#eval silly (Foo.bar1 1 2)    -- 2
#eval silly (Foo.bar2 3 4 5)  -- 5
</code></pre>
<p>各コンストラクタによって生成された各ゴールは、帰納型の定義におけるコンストラクタの宣言順に解く必要はない。</p>
<pre><code class="language-lean">inductive Foo where
  | bar1 : Nat → Nat → Foo
  | bar2 : Nat → Nat → Nat → Foo

def silly (x : Foo) : Nat := by
  cases x with
  | bar2 c d e =&gt; exact e
  | bar1 a b =&gt; exact b
</code></pre>
<p><code>with</code> の構文は構造化された証明を書くのに便利である。また、Leanは <code>cases</code> を補完する <code>case</code> タクティクを提供する。これを使うと、各ケースで変数名を割り当てることに集中することができる。</p>
<pre><code class="language-lean"><span class="boring">inductive Foo where
</span><span class="boring">  | bar1 : Nat → Nat → Foo
</span><span class="boring">  | bar2 : Nat → Nat → Nat → Foo
</span>def silly (x : Foo) : Nat := by
  cases x
  case bar1 a b =&gt; exact b
  case bar2 c d e =&gt; exact e
</code></pre>
<p><code>case</code> タクティクは賢く、各コンストラクタを適切なゴールにマッチさせることができる。例えば、上記のゴールを逆順で埋めることができる:</p>
<pre><code class="language-lean"><span class="boring">inductive Foo where
</span><span class="boring">  | bar1 : Nat → Nat → Foo
</span><span class="boring">  | bar2 : Nat → Nat → Nat → Foo
</span>def silly (x : Foo) : Nat := by
  cases x
  case bar2 c d e =&gt; exact e
  case bar1 a b =&gt; exact b
</code></pre>
<p>さらに、任意の式 <code>e</code> に対して <code>cases e</code> を使うこともできる。もしその式がゴールのターゲットに現れるなら、<code>cases</code> タクティクはその式を一般化し、その結果生じる全称量化された変数を導入し、その上でゴールを場合分けする。</p>
<pre><code class="language-lean">open Nat

example (p : Nat → Prop) (hz : p 0) (hs : ∀ n, p (succ n)) (m k : Nat)
        : p (m + 3 * k) := by
  cases m + 3 * k
  . exact hz   -- goal is p 0
  . apply hs   -- goal is a : Nat ⊢ p (succ a)
</code></pre>
<p>これは、「(<code>m + 3 * k</code> は自然数なので、)<code>m + 3 * k</code> が0か、ある数の後者かで場合分けする」と言っているのだと考えてほしい。この結果は機能的には次の例と等価である:</p>
<pre><code class="language-lean">open Nat

example (p : Nat → Prop) (hz : p 0) (hs : ∀ n, p (succ n)) (m k : Nat)
        : p (m + 3 * k) := by
  generalize m + 3 * k = n
  cases n
  . exact hz   -- goal is p 0
  . apply hs   -- goal is a : Nat ⊢ p (succ a)
</code></pre>
<p>式 <code>m + 3 * k</code> は <code>generalize</code> によって消去されることに注意してほしい; 重要なのは、それが <code>0</code> か <code>succ a</code> のどちらの形式を持つかだけである。 この使い方の場合、<code>cases</code> は等式(この場合は <code>m + 3 * k = n</code>)中の項について言及している仮説をゴールのターゲットに戻さ<strong>ない</strong>。そのような仮説がコンテキストの中にあり、それについても一般化したい場合は、明示的にそれを <code>revert</code> で戻す必要がある。</p>
<p>場合分けの対象となる式がゴールのターゲット内にない場合、<code>cases</code> タクティクは <code>have</code> を使い、分解後の式を型として持つ項をコンテキストに導入する。以下はその例である:</p>
<pre><code class="language-lean">example (p : Prop) (m n : Nat)
        (h₁ : m &lt; n → p) (h₂ : m ≥ n → p) : p := by
  cases Nat.lt_or_ge m n
  case inl hlt =&gt; exact h₁ hlt
  case inr hge =&gt; exact h₂ hge
</code></pre>
<p><code>Nat.lt_or_ge m n</code> とは <code>m &lt; n ∨ m ≥ n</code> の証明項であり、上の証明はこの2つの場合に分かれると考えるのが自然である。最初の分岐では仮説 <code>hlt : m &lt; n</code> を持つ。2番目の分岐では仮説 <code>hge : m ≥ n</code> を持つ。上の証明は、機能的には次と等価である:</p>
<pre><code class="language-lean">example (p : Prop) (m n : Nat)
        (h₁ : m &lt; n → p) (h₂ : m ≥ n → p) : p := by
  have h : m &lt; n ∨ m ≥ n := Nat.lt_or_ge m n
  cases h
  case inl hlt =&gt; exact h₁ hlt
  case inr hge =&gt; exact h₂ hge
</code></pre>
<p><code>have</code> タクティクにより仮説 <code>h : m &lt; n ∨ m ≥ n</code> が得られるので、その仮説に対して <code>cases</code> を適用する。</p>
<p>次の例では、自然数における等式の決定可能性を利用して、<code>m = n</code> と <code>m ≠ n</code> の場合に分けて証明する。</p>
<pre><code class="language-lean">#check Nat.sub_self

theorem t1 (m n : Nat) : m - n = 0 ∨ m ≠ n := by
  cases Decidable.em (m = n) with
  | inl heq =&gt; rw [heq]; apply Or.inl; exact Nat.sub_self n
  | inr hne =&gt; apply Or.inr; exact hne

/- ``Decidable.em`` は排中律 ``Classical.em`` を必要としない -/
#print axioms t1  -- 't1' does not depend on any axioms
</code></pre>
<p><code>open Classical</code> を使えば、任意の命題に対して排中律 <code>em</code> が使えることを思い出してほしい。しかし、型クラス推論(<a href="./type_classes.html">10章 Type Classes (型クラス)</a>を参照)を使えば、Leanは排中律に似て非なる決定手続きを見つけることができる。つまり、計算可能関数において場合分け <code>p ∨ ¬p</code> を使うことができるのである。</p>
<p><code>cases</code> タクティクが場合分けによる証明を行うのに使えるように、<code>induction</code> タクティクは帰納法による証明を行うのに使える。<code>induction</code> タクティクの構文は <code>cases</code> タクティクの構文と似ているが、前者は引数が現在のコンテキストの項でなければならない点が異なる。以下はその例である:</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>theorem zero_add (n : Nat) : 0 + n = n := by
  induction n with
  | zero =&gt; rfl
  | succ n ih =&gt; rw [Nat.add_succ, ih]
<span class="boring">end Hidden
</span></code></pre>
<p><code>cases</code> と同様に、<code>induction</code> タクティクでは <code>with</code> キーワードの代わりに <code>case</code> タクティクを使うことができる。</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>theorem zero_add (n : Nat) : 0 + n = n := by
  induction n
  case zero =&gt; rfl
  case succ n ih =&gt; rw [Nat.add_succ, ih]
<span class="boring">end Hidden
</span></code></pre>
<p>以下に例を追加する:</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span><span class="boring">theorem add_zero (n : Nat) : n + 0 = n := Nat.add_zero n
</span>open Nat

theorem zero_add (n : Nat) : 0 + n = n := by
  induction n &lt;;&gt; simp [*, add_zero, add_succ]

theorem succ_add (m n : Nat) : succ m + n = succ (m + n) := by
  induction n &lt;;&gt; simp [*, add_zero, add_succ]

theorem add_comm (m n : Nat) : m + n = n + m := by
  induction n &lt;;&gt; simp [*, add_zero, add_succ, succ_add, zero_add]

theorem add_assoc (m n k : Nat) : m + n + k = m + (n + k) := by
  induction k &lt;;&gt; simp [*, add_zero, add_succ]
<span class="boring">end Hidden
</span></code></pre>
<p><code>induction</code> タクティクは複数の引数(大前提)をとるユーザー定義の帰納法原理もサポートしている。</p>
<pre><code class="language-lean">/-
theorem Nat.mod.inductionOn
      {motive : Nat → Nat → Sort u}
      (x y  : Nat)
      (ind  : ∀ x y, 0 &lt; y ∧ y ≤ x → motive (x - y) y → motive x y)
      (base : ∀ x y, ¬(0 &lt; y ∧ y ≤ x) → motive x y)
      : motive x y :=
-/

example (x : Nat) {y : Nat} (h : y &gt; 0) : x % y &lt; y := by
  induction x, y using Nat.mod.inductionOn with
  | ind x y h₁ ih =&gt;
    rw [Nat.mod_eq_sub_mod h₁.2]
    exact ih h
  | base x y h₁ =&gt;
    have : ¬ 0 &lt; y ∨ ¬ y ≤ x := Iff.mp (Decidable.not_and_iff_or_not ..) h₁
    match this with
    | Or.inl h₁ =&gt; exact absurd h h₁
    | Or.inr h₁ =&gt;
      have hgt : y &gt; x := Nat.gt_of_not_le h₁
      rw [← Nat.mod_eq_of_lt hgt] at hgt
      assumption
</code></pre>
<p>タクティク証明の中で <code>match</code> を使うこともできる:</p>
<pre><code class="language-lean">example : p ∨ q → q ∨ p := by
  intro h
  match h with
  | Or.inl _  =&gt; apply Or.inr; assumption
  | Or.inr h2 =&gt; apply Or.inl; exact h2
</code></pre>
<p>便利なことに、パターンマッチングは <code>intro</code> や <code>funext</code> のようなタクティクに統合されている。</p>
<pre><code class="language-lean">example : s ∧ q ∧ r → p ∧ r → q ∧ p := by
  intro ⟨_, ⟨hq, _⟩⟩ ⟨hp, _⟩
  exact ⟨hq, hp⟩

example :
    (fun (x : Nat × Nat) (y : Nat × Nat) =&gt; x.1 + y.2)
    =
    (fun (x : Nat × Nat) (z : Nat × Nat) =&gt; z.2 + x.1) := by
  funext (a, b) (c, d)
  show a + d = d + a
  rw [Nat.add_comm]
</code></pre>
<p>最後に、<code>injection</code> タクティクを紹介してセクションを閉じる。このタクティクは帰納型を扱いやすくするためにデザインされている。Leanの設計上、帰納型の項は自由に生成される。つまり、各コンストラクタは単射であり、各コンストラクタの値域は互いに交わりを持たない。<code>injection</code> タクティクはこの事実を利用するようにデザインされている:</p>
<pre><code class="language-lean">open Nat

example (m n k : Nat) (h : succ (succ m) = succ (succ n))
        : n + k = m + k := by
  injection h with h'
  injection h' with h''
  rw [h'']
</code></pre>
<p>証明の1行目は仮説 <code>h' : succ m = succ n</code> をコンテキストに追加し、証明の2行目は仮説 <code>h'' : m = n</code> をコンテキストに追加する。</p>
<p>また、<code>injection</code> タクティクは「異なるコンストラクタ(あるいは異なる入力を受けたコンストラクタ)の出力が互いに等しい」としたときに生じる矛盾を検出し、その矛盾を使ってゴールを閉じる。</p>
<pre><code class="language-lean">open Nat

example (m n : Nat) (h : succ m = 0) : n = n + 7 := by
  injection h

example (m n : Nat) (h : succ m = 0) : n = n + 7 := by
  contradiction

example (h : 7 = 4) : False := by
  contradiction
</code></pre>
<p>2番目の例は、<code>contradiction</code> タクティクもこの形の矛盾を検出することを示している。</p>
<h2 id="inductive-families-帰納族"><a class="header" href="#inductive-families-帰納族">Inductive Families (帰納族)</a></h2>
<p>Leanが受け入れる帰納的定義のほとんど全てを説明し終えた。ここまでの説明で、Leanでは任意個の再帰的コンストラクタを持つ帰納型を導入できることが分かった。実際、今までの知識を応用して、これから説明する方法を使うと、ただ1つの帰納的定義を使って帰納型の添字付き<em>family</em>(族)を導入することもできる。</p>
<p>帰納族とは、次のような形の1つの帰納的定義によって同時に定義される、添字を持つ型の族である:</p>
<pre><code>inductive foo : ... → Sort u where
  | constructor₁ : ... → foo ...
  | constructor₂ : ... → foo ...
  ...
  | constructorₙ : ... → foo ...
</code></pre>
<p>ある <code>Sort u</code> の項を構築する通常の帰納的定義に対して、より一般的な帰納的定義は関数 <code>... → Sort u</code> を構築する。ここで、<code>...</code> は<em>indices</em>(添字)とも呼ばれる引数の型の列を表す。そして、各コンストラクタは族のいくつかの要素を構築する。その一例が <code>Vector α n</code> の定義である。これは <code>α</code> の項を要素に持つ長さ <code>n</code> のベクトルの型である:</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>inductive Vector (α : Type u) : Nat → Type u where
  | nil  : Vector α 0
  | cons : α → {n : Nat} → Vector α n → Vector α (n+1)
<span class="boring">end Hidden
</span></code></pre>
<p><code>cons</code> コンストラクタは <code>α</code> と <code>Vector α n</code> の項を取り、<code>Vector α (n+1)</code> の項を返す。これにより、族の1つの要素(型)の項を利用して別の要素(型)の項を構築することができる。</p>
<p>より風変わりな例は、Leanにおける等式型の定義である:</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>inductive Eq {α : Sort u} (a : α) : α → Prop where
  | refl : Eq a a
<span class="boring">end Hidden
</span></code></pre>
<p>固定された各 <code>α : Sort u</code> と各 <code>a : α</code> に対して、この定義は <code>x : α</code> を添字とする型の族 <code>Eq a x</code> を構築する。しかし、注目すべきは、族 <code>Eq a x</code> には <code>Eq a a</code> の項を構築するただ1つのコンストラクタ <code>refl</code> しかないことである。直感的には、<code>Eq a x</code> の証明を構築するには、<code>x</code> が <code>a</code> である場合に反射律を使うしかないと言い換えることができる。<code>Eq a a</code> は型の族 <code>Eq a x</code> の中で唯一の有項型であることに注意してほしい。</p>
<p>Leanにより生成された等号の除去則は次の通り:</p>
<pre><code class="language-lean">universe u v

#check (@Eq.rec : {α : Sort u} → {a : α} → {motive : (x : α) → a = x → Sort v}
                  → motive a rfl → {b : α} → (h : a = b) → motive b h)
</code></pre>
<p>コンストラクタ <code>refl</code> とエリミネータ <code>Eq.rec</code> だけから等式の基本的な公理の全てが導かれるのは驚くべき事実である。ただし、節 <a href="inductive_types.html#axiomatic-details-%E5%85%AC%E7%90%86%E3%81%AE%E8%A9%B3%E7%B4%B0">Axiomatic Details (公理の詳細)</a> で説明するように、等式の定義は非典型的である。</p>
<p>再帰子 <code>Eq.rec</code> は代入の定義にも使われる:</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>theorem subst {α : Type u} {a b : α} {p : α → Prop} (h₁ : Eq a b) (h₂ : p a) : p b :=
  Eq.rec (motive := fun x _ =&gt; p x) h₂ h₁
<span class="boring">end Hidden
</span></code></pre>
<p><code>match</code> を使って <code>subst</code> を定義(証明)することもできる。 </p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>theorem subst {α : Type u} {a b : α} {p : α → Prop} (h₁ : Eq a b) (h₂ : p a) : p b :=
  match h₁ with
  | rfl =&gt; h₂
<span class="boring">end Hidden
</span></code></pre>
<p>実際、Leanは <code>Eq.rec</code> に基づいた定義を用いて <code>match</code> 式をコンパイルする。</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>theorem subst {α : Type u} {a b : α} {p : α → Prop} (h₁ : Eq a b) (h₂ : p a) : p b :=
  match h₁ with
  | rfl =&gt; h₂

set_option pp.all true
#print subst
  -- ... subst.match_1 ...
#print subst.match_1
  -- ... Eq.casesOn ...
#print Eq.casesOn
  -- ... Eq.rec ...
<span class="boring">end Hidden
</span></code></pre>
<p><code>h₁ : a = b</code> に対して再帰子 <code>Eq.rec</code> または <code>match</code> を使うと、<code>a</code> と <code>b</code> が同じだと仮定することができる。その下で、<code>p b</code> と <code>p a</code> は同じである。</p>
<p><code>Eq</code> が対称的かつ推移的であることを証明するのは難しくない。以下の例では、等号の対称性 <code>symm</code> を示す。推移性 <code>trans</code> と<em>congruence</em>(合同性) <code>congr</code> の証明は練習問題として残す。</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>theorem symm {α : Type u} {a b : α} (h : Eq a b) : Eq b a :=
  match h with
  | rfl =&gt; rfl

theorem trans {α : Type u} {a b c : α} (h₁ : Eq a b) (h₂ : Eq b c) : Eq a c :=
  sorry

theorem congr {α β : Type u} {a b : α} (f : α → β) (h : Eq a b) : Eq (f a) (f b) :=
  sorry
<span class="boring">end Hidden
</span></code></pre>
<p>型理論の研究においては、帰納的定義の更なる一般化が存在する。例えば、<em>induction-recursion</em> と <em>induction-induction</em> の原理がある。これらはLeanではサポートされていない。</p>
<h2 id="axiomatic-details-公理の詳細"><a class="header" href="#axiomatic-details-公理の詳細">Axiomatic Details (公理の詳細)</a></h2>
<p>これまで、例を通して帰納型とその構文について説明してきた。この節では、公理的な基礎に興味のある人のために、追加の情報を提供する。</p>
<p>帰納型のコンストラクタは、<em>parameters</em>(パラメータ, 帰納的な構築の間、固定されたままの引数)と<em>indices</em>(添字, 同時進行で構築される型の族をパラメータ化する引数)を取りうることを見てきた。各コンストラクタは、型を持つ必要がある。ここで、コンストラクタの引数の型は既に定義された型、パラメータと添字の型、現在定義中の帰納族の要素だけから構成される必要がある。コンストラクタの引数の型に現在定義中の帰納族の要素が現れる場合、それは<em>strictly positively</em>に出現しなければならないという要件がある。これは単純に、任意のコンストラクタの任意の引数の型は、定義中の帰納型が結果としてのみ出現する依存関数型でなければならないことを意味する。ここで、添字は定数と前の引数を使って与えられる。</p>
<p>帰納型はある <code>u</code> が存在して <code>Sort u</code> の項なので、当該帰納型を項としてみたとき、その項が持つ型宇宙として<strong>どの</strong>宇宙レベル <code>u</code> がふさわしいかを問うのは合理的である。帰納族 <code>C</code> の定義内の各コンストラクタ <code>c</code> は以下の形式をとる。</p>
<pre><code>  c : (a : α) → (b : β[a]) → C a p[a,b]
</code></pre>
<p>ここで、<code>a</code> はデータ型パラメータの列、<code>b</code> はコンストラクタへの引数の列、<code>p[a, b]</code> は添字である。この添字 <code>p[a, b]</code> によって、そのコンストラクタが帰納族のどの要素の項を構築するかが決まる。(この説明はやや不正確である。実際には、コンストラクタへの引数は、依存関係が意味をなす限りどのような順番で現れてもよい。)<code>C</code> の宇宙レベルは、その帰納型が <code>Prop</code>(つまり、<code>Sort 0</code>)に属するように指定されているかどうかによって、2種類の制約を持つ。</p>
<p>まず、帰納型が <code>Prop</code> に属するように指定されて<strong>いない</strong>場合を考えよう。このとき、宇宙レベル <code>u</code> は次を満たすように制約される:</p>
<blockquote>
<p>上記の各コンストラクタ <code>c</code> と、列 <code>β[a]</code> 内の各 <code>βk[a]</code> に対して、もし <code>βk[a] : Sort v</code> なら、<code>u</code> ≥ <code>v</code> である。</p>
</blockquote>
<p>言い換えれば、当該帰納型の宇宙レベル <code>u</code> は、各コンストラクタの各引数の型の宇宙レベル以上であることが要求される。</p>
<p>帰納型が <code>Prop</code> に属するように指定されている場合、コンストラクタの引数の型の宇宙レベルには制約がない。しかし、コンストラクタの引数の型の宇宙レベルは除去則に影響を与える。一般的に、<code>Prop</code> に属する帰納型の場合、除去則のmotive(動機)の型は <code>Prop</code> に属することが要求される。</p>
<p>この最後のルールには例外がある: コンストラクタが1つしかなく、コンストラクタの各引数が <code>Prop</code> の項あるいは添字である場合、除去則によって帰納的に定義された <code>Prop</code> を除去して任意の <code>Sort</code> の項を作ることが許される。この場合、直感的には、エリミネータは引数の型が有項であるという事実なしに引数の情報を利用することはない、と言うことができる。この特別なケースは<em>singleton elimination</em>(シングルトン除去)として知られている。</p>
<p>帰納的に定義された等式型のエリミネータ <code>Eq.rec</code> の実用例で、シングルトン除去が活躍するのをすでに見てきた。<code>p a</code> と <code>p b</code> が <code>Prop</code> に限らない任意の型を持つ場合でも、項 <code>h : Eq a b</code> を使って項 <code>t' : p a</code> を <code>p b</code> にキャストすることができる。なぜなら、このキャストは新しいデータを生成せず、すでに持っているデータを再解釈するだけだからだ。シングルトン除去はheterogeneous equality(異型等式)やwell-founded recursion(整礎再帰)でも使われるが、これについては次章の<a href="./induction_and_recursion.html#well-founded-recursion-and-induction-%E6%95%B4%E7%A4%8E%E5%86%8D%E5%B8%B0%E3%81%A8%E6%95%B4%E7%A4%8E%E5%B8%B0%E7%B4%8D%E6%B3%95">Well-Founded Recursion and Induction (整礎再帰と整礎帰納法)</a>の節で説明する。</p>
<h2 id="mutual-and-nested-inductive-types-相互帰納型と入れ子帰納型"><a class="header" href="#mutual-and-nested-inductive-types-相互帰納型と入れ子帰納型">Mutual and Nested Inductive Types (相互帰納型と入れ子帰納型)</a></h2>
<p>ここで、帰納型を一般化して得られるしばしば便利な2つの型の概念<em>Mutual Inductive Types</em>(相互帰納型)と<em>Nested Inductive Types</em>(入れ子帰納型)について考えよう。Leanは、これらを上で説明したようなよりプリミティブな種類の帰納型に「コンパイル」することでこの2つの概念をサポートする。言い換えると、Leanはより一般的な定義を構文解析し、それに基づいて補助的な帰納型を定義し、その補助的な型を使って本当に必要なものを定義する。これらの型を効果的に利用するためには、次の章で説明するLeanの等式コンパイラが必要である。それでも、これらの型の宣言は通常の帰納的定義の簡単な変化形であるため、ここで説明することに意味がある。</p>
<p>まず、Leanは<em>mutually defined</em>(相互に定義された)帰納型をサポートする。これは、同時に定義される、それぞれが定義中の他の型を参照する帰納型たちである。</p>
<pre><code class="language-lean">mutual
  inductive Even : Nat → Prop where
    | even_zero : Even 0
    | even_succ : (n : Nat) → Odd n → Even (n + 1)

  inductive Odd : Nat → Prop where
    | odd_succ : (n : Nat) → Even n → Odd (n + 1)
end

open Even Odd

example : Even 2 := even_succ 1 (odd_succ 0 even_zero)
</code></pre>
<p>この例では、2つの帰納型が同時に定義されている: 自然数 <code>n</code> は、<code>0</code> であるか奇数 <code>Odd</code> より1大きいときは偶数 <code>Even</code> であり、偶数 <code>Even</code> より1大きいときは奇数 <code>Odd</code> である。以下の練習問題では、その詳細を記述せよ。</p>
<p>相互帰納型は、<code>α</code> の項でラベル付けされた頂点を持つ有限木を定義するのにも使える:</p>
<pre><code class="language-lean">mutual
    inductive Tree (α : Type u) where
      | node : α → TreeList α → Tree α

    inductive TreeList (α : Type u) where
      | nil  : TreeList α
      | cons : Tree α → TreeList α → TreeList α
end
</code></pre>
<p>この定義により、<code>α</code> の項 <code>a</code> と、空であってもよい部分木のリストを与えることで、<code>a</code> を根とする <code>Tree α</code> の項を構築することができる。部分木のリストは型 <code>TreeList α</code> の項として表現され、これは空リスト <code>nil</code> か、<code>Tree α</code> の項と <code>TreeList α</code> の項の <code>cons</code> のいずれかであると定義される。</p>
<p>しかしながら、この <code>Tree</code> と <code>TreeList</code> の定義は扱いにくい。特にLeanのライブラリにはリストを扱うための関数や定理が数多く含まれているため、部分木のリストが型 <code>List (Tree α)</code> の項として与えられたら、これらの定義はもっと扱いやすくなるだろう。型 <code>TreeList α</code> が <code>List (Tree α)</code> と「同型」であることを示すことはできる。しかし、この同型に沿って片方で得られた結果を他方へ翻訳するのは面倒である。</p>
<p>実際、Leanでは本当に必要としている帰納型を定義することができる:</p>
<pre><code class="language-lean">inductive Tree (α : Type u) where
  | mk : α → List (Tree α) → Tree α
</code></pre>
<p>これは<em>nested inductive type</em>(入れ子帰納型)として知られている。この <code>Tree</code> の定義は前節で示した帰納型の厳密な仕様から外れている。なぜなら、<code>mk</code> の引数の型の中で、<code>Tree</code> はstrictly positivelyに現れず、<code>List</code> 型コンストラクタの中に入れ子になっているからである。Leanはカーネルの中で <code>TreeList α</code> と <code>List (Tree α)</code> の間に同型を構築し、その同型の観点からこの入れ子帰納型 <code>Tree</code> のコンストラクタを定義する。</p>
<h2 id="exercises-練習問題-3"><a class="header" href="#exercises-練習問題-3">Exercises (練習問題)</a></h2>
<ol>
<li>
<p>自然数に対する他の演算、例えば乗法、前者関数(<code>pred 0 = 0</code> とする)、切り捨て減法(<code>m</code> が <code>n</code>以上のとき <code>n - m = 0</code>)、べき乗などを定義してみよ。次に、既に証明した定理を基に、それらの基本的な性質をいくつか証明してみよ。</p>
<p>それらの多くはLeanのコアライブラリで既に定義されている。名前衝突を避けるため、<code>Hidden</code> のような名前の名前空間の中で作業することを勧める。</p>
</li>
<li>
<p>リストに関する <code>length</code> 関数や <code>reverse</code> 関数のような操作をいくつか定義せよ。それらについて、次のような性質をいくつか証明せよ。</p>
<p>a. <code>length (s ++ t) = length s + length t</code></p>
<p>b. <code>length (reverse t) = length t</code></p>
<p>c. <code>reverse (reverse t) = t</code></p>
</li>
<li>
<p>以下のコンストラクタから構築される項からなる帰納データ型を定義せよ:</p>
<ul>
<li><code>const n</code>, 自然数 <code>n</code> を表す定数</li>
<li><code>var n</code>, <code>n</code> 番目の変数</li>
<li><code>plus s t</code>, <code>s</code> と <code>t</code> の和を表す</li>
<li><code>times s t</code>, <code>s</code> と <code>t</code> の積を表す</li>
</ul>
<p>今定義した型の項を評価する関数を再帰的に定義せよ。ただし、変数には値を割り当てることができるとする。</p>
</li>
<li>
<p>同様に、命題論理式の型と、その型に関する関数を定義せよ:
例えば、評価関数、式の複雑さを測る関数、与えられた変数に別の式を代入する関数などを定義せよ。</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="induction-and-recursion-帰納と再帰"><a class="header" href="#induction-and-recursion-帰納と再帰">Induction and Recursion (帰納と再帰)</a></h1>
<p>前章では、帰納的定義がLeanに新しい型を導入する強力な手段となることを説明した。さらに言えば、コンストラクタと再帰子(エリミネータ)は、帰納型から他の型への関数を定義する唯一の手段である。型としての命題対応により、この事実は帰納法が証明の基本的な方法であることを意味する。</p>
<p>Leanは再帰関数の定義、パターンマッチングの実行、帰納的証明の記述に対して自然な方法を提供する。関数を定義するには、その関数が満たすべき等式を指定する。定理を証明するには、起こりうる全てのケースをどのように扱うかを指定する。裏では、これらの記述は<em>equation compiler</em>(等式コンパイラ)と呼ばれるものを用いて、プリミティブな再帰子へと「コンパイル」される。等式コンパイラはtrusted code base(システムの信頼性保証において最も基礎的で重要なコード)の一部ではない。等式コンパイラの出力はカーネルによって独立にチェックされる項で構成される。</p>
<h2 id="用語に関する注意-1"><a class="header" href="#用語に関する注意-1">用語に関する注意</a></h2>
<p>この節は翻訳に際して追加した節である。</p>
<p>この章では、次のような定義</p>
<pre><code class="language-lean">open Nat
def foo : Nat → Nat → Nat
  | zero  , zero   =&gt; 0
  | zero  , succ y =&gt; 1
  | succ x, zero   =&gt; 2
  | succ x, succ y =&gt; 3
</code></pre>
<p>があるとき、<code>zero</code> や <code>succ y</code> などを「パターン(pattern)」、<code>| zero  , zero</code> などを「ケース(case)」、定義として与えられたケース全てをまとめたものを「ケースリスト(list of cases)」、不足なくケースが与えられたケースリストを用いてパターンマッチングすることを「場合分け(by cases)」あるいは「場合分けする(split on cases)」と呼ぶ。</p>
<h2 id="pattern-matching-パターンマッチング"><a class="header" href="#pattern-matching-パターンマッチング">Pattern Matching (パターンマッチング)</a></h2>
<p>schematic patternsの解釈は、コンパイルの最初のステップである。帰納型のコンストラクタと <code>casesOn</code> 再帰子を使って、関数を定義したり、場合分けによる定理の証明が行えることを見てきた。しかし、複雑な定義は、入れ子になった <code>casesOn</code> 適用をいくつも使うことがあり、そのような記述は読みにくく理解しにくいかもしれない。パターンマッチングはより便利で、関数型プログラミング言語ユーザーに馴染みのあるアプローチを提供する。</p>
<p>帰納的に定義された自然数の型について考える。全ての自然数は <code>zero</code> か <code>succ x</code> のどちらかの形をとるため、それぞれのケースにおいて出力の値を指定することで、自然数から任意の型への関数を定義することができる:</p>
<pre><code class="language-lean">open Nat

/- 等式コンパイラによるパターンマッチングを使った関数定義の構文

   この構文を使って帰納型から任意の型への関数を定義する場合、
   `:=` は不要である(書くとコンパイルエラーになる)ことに注意。
   定義したい項が型Tを持つとき、この構文は型Tの(1つ以上の)前件とパターンマッチングする -/

def sub1 : Nat → Nat
  | zero   =&gt; zero
  | succ x =&gt; x

def isZero : Nat → Bool
  | zero   =&gt; true
  | succ x =&gt; false
</code></pre>
<p>以上の関数を定義するために使われる等式の集まり(例えば、<code>sub1 zero = zero</code> は上記の関数定義の一部だとみなせる)はdefinitionallyに成立する:</p>
<pre><code class="language-lean"><span class="boring">open Nat
</span><span class="boring">def sub1 : Nat → Nat
</span><span class="boring">  | zero   =&gt; zero
</span><span class="boring">  | succ x =&gt; x
</span><span class="boring">def isZero : Nat → Bool
</span><span class="boring">  | zero   =&gt; true
</span><span class="boring">  | succ x =&gt; false
</span>example : sub1 0 = 0 := rfl
example (x : Nat) : sub1 (succ x) = x := rfl

example : isZero 0 = true := rfl
example (x : Nat) : isZero (succ x) = false := rfl

example : sub1 7 = 6 := rfl
example (x : Nat) : isZero (x + 3) = false := rfl
</code></pre>
<p><code>zero</code> や <code>succ</code> の代わりに、より馴染みのある表記を使うことができる:</p>
<pre><code class="language-lean">def sub1 : Nat → Nat
  | 0   =&gt; 0
  | x+1 =&gt; x

def isZero : Nat → Bool
  | 0   =&gt; true
  | x+1 =&gt; false
</code></pre>
<p>加法とゼロ表記には <code>[match_pattern]</code> 属性が割り当てられているため、これらの表記をパターンマッチングで使うことができる。Leanは、コンストラクタ <code>zero</code> や <code>succ</code> が出現するまで、加法やゼロ表記を含む式を単純に正規化する。</p>
<p>パターンマッチングは直積型や <code>Option</code> 型など、任意の帰納型に対して機能する:</p>
<pre><code class="language-lean">def swap : α × β → β × α
  | (a, b) =&gt; (b, a)

def foo : Nat × Nat → Nat
  | (m, n) =&gt; m + n

def bar : Option Nat → Nat
  | some n =&gt; n + 1
  | none   =&gt; 0
</code></pre>
<p>パターンマッチングは関数定義だけでなく、場合分けによる証明にも使うことができる:</p>
<pre><code class="language-lean">namespace Hidden
def not : Bool → Bool
  | true  =&gt; false
  | false =&gt; true

theorem not_not : ∀ (b : Bool), not (not b) = b
  | true  =&gt; rfl  -- proof that not (not true) = true
  | false =&gt; rfl  -- proof that not (not false) = false

theorem not_not' : (b : Bool) → not (not b) = b
  | true  =&gt; rfl
  | false =&gt; rfl
end Hidden
</code></pre>
<p>パターンマッチングは帰納的に定義された命題を分解するためにも使うことができる:</p>
<pre><code class="language-lean">example (p q : Prop) : p ∧ q → q ∧ p
  | And.intro h₁ h₂ =&gt; And.intro h₂ h₁

example (p q : Prop) : p ∨ q → q ∨ p
  | Or.inl hp =&gt; Or.inr hp
  | Or.inr hq =&gt; Or.inl hq
</code></pre>
<p>パターンマッチングは論理的結合子を含む仮説を分解するコンパクトな方法も提供する。</p>
<p>以上の全ての例で、パターンマッチングは「フラットな」場合分けを実行するために使われている。さらに興味深いことに、パターンは次のように入れ子になったコンストラクタを含むこともある。</p>
<pre><code class="language-lean">def sub2 : Nat → Nat
  | 0   =&gt; 0
  | 1   =&gt; 0
  | x+2 =&gt; x
</code></pre>
<p>この例において、等式コンパイラはまず入力が <code>zero</code> か <code>succ x</code> の形であるかで最初の場合分けを行う。入力が <code>zero</code> のときは <code>0</code> を返す。入力が <code>succ x</code> の形のときは、その <code>x</code> が <code>zero</code> か <code>succ x</code> の形であるかで2回目の場合分けを行う。等式コンパイラは提示されたケースリストから場合分けの方法を決定し、適切な場合分けに失敗したときはエラーを生じる。ここでも、次のように算術の記法を使うことができる。いずれにせよ、関数を定義する等式はdefinitionallyに成立する。</p>
<pre><code class="language-lean"><span class="boring">def sub2 : Nat → Nat
</span><span class="boring">  | 0   =&gt; 0
</span><span class="boring">  | 1   =&gt; 0
</span><span class="boring">  | x+2 =&gt; x
</span>example : sub2 0 = 0 := rfl
example : sub2 1 = 0 := rfl
example : sub2 (x+2) = x := rfl

example : sub2 5 = 3 := rfl
</code></pre>
<p><code>#print sub2</code> と書けば、この関数が再帰子を含むどんな式にコンパイルされたかが分かる。(Leanは <code>sub2</code> が内部の補助関数 <code>sub2.match_1</code> を使って定義されていることを伝えるかもしれないが、<code>#print</code> コマンドを使って <code>sub2.match_1</code> の定義を表示させることもできる。)Leanはこれらの補助関数を使って <code>match</code> 式をコンパイルする。実際には、上記の定義 <code>sub2</code> は次のように展開される。</p>
<pre><code class="language-lean">def sub2 : Nat → Nat :=
  fun x =&gt;
    match x with
    | 0   =&gt; 0
    | 1   =&gt; 0
    | x+2 =&gt; x
</code></pre>
<p>入れ子になったパターンマッチングの例をさらに挙げる:</p>
<pre><code class="language-lean">example (p q : α → Prop)
        : (∃ x, p x ∨ q x) → (∃ x, p x) ∨ (∃ x, q x)
  | Exists.intro x (Or.inl px) =&gt; Or.inl (Exists.intro x px)
  | Exists.intro x (Or.inr qx) =&gt; Or.inr (Exists.intro x qx)

def foo : Nat × Nat → Nat
  | (0, n)     =&gt; 0
  | (m+1, 0)   =&gt; 1
  | (m+1, n+1) =&gt; 2
</code></pre>
<p>等式コンパイラは複数の引数を連続して処理することができる。例えば、一つ上の例 <code>foo</code> は2つの引数を持つ関数として定義する方が自然だろう:</p>
<pre><code class="language-lean">def foo : Nat → Nat → Nat
  | 0,   n   =&gt; 0
  | m+1, 0   =&gt; 1
  | m+1, n+1 =&gt; 2
</code></pre>
<p>別の例を挙げる:</p>
<pre><code class="language-lean">-- `a :: as` は `cons a as` の糖衣構文

def bar : List Nat → List Nat → Nat
  | [],      []      =&gt; 0
  | a :: as, []      =&gt; a
  | [],      b :: bs =&gt; b
  | a :: as, b :: bs =&gt; a + b
</code></pre>
<p>複数の引数を持つケースは、パターン毎にカンマで区切られることに注意してほしい。</p>
<p>以下の各例では、2番目以降の引数がケースに含まれているが、最初の引数での場合分けのみが行われる。</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>def and : Bool → Bool → Bool
  | true,  a =&gt; a
  | false, _ =&gt; false

def or : Bool → Bool → Bool
  | true,  _ =&gt; true
  | false, a =&gt; a

def cond : Bool → α → α → α
  | true,  x, y =&gt; x
  | false, x, y =&gt; y
<span class="boring">end Hidden
</span></code></pre>
<p>また、ある引数の値が出力を定義するのに必要ない場合は、その引数のパターンにアンダースコアを使うことができることに注意してほしい。このアンダースコアは<em>wildcard pattern</em>(ワイルドカードパターン)あるいは<em>anonymous variable</em>(無名変数)として知られている。等式コンパイラ以外での使い方とは違い、ここでアンダースコアは暗黙の引数を表すものでは<strong>ない</strong>。ワイルドカードにアンダースコアを使うのは関数型プログラミング言語では一般的なので、Leanもその表記を採用した。節<a href="induction_and_recursion.html#wildcards-and-overlapping-patterns-%E3%83%AF%E3%82%A4%E3%83%AB%E3%83%89%E3%82%AB%E3%83%BC%E3%83%89%E3%81%A8%E3%82%B1%E3%83%BC%E3%82%B9%E3%81%AE%E9%87%8D%E8%A4%87">Wildcards and Overlapping Patterns (ワイルドカードとケースの重複)</a>ではワイルドカードの概念を拡張し、節<a href="induction_and_recursion.html#inaccessible-patterns-%E3%82%A2%E3%82%AF%E3%82%BB%E3%82%B9%E4%B8%8D%E8%83%BD%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3">Inaccessible Patterns (アクセス不能パターン)</a>ではパターン内で暗黙の引数を使用する方法を説明する。</p>
<p><a href="./inductive_types.html">7章 Inductive Types (帰納型)</a>で説明したように、帰納データ型はパラメータに依存しうる。次の例では、パターンマッチングを用いて <code>tail</code> 関数を定義している。引数 <code>α : Type u</code> は帰納データ型のパラメータであり、パターンマッチングに参加しないことを示すために(関数名・引数リストと型名を区切る)コロンの前に置かれる。Leanは <code>:</code> の後に帰納型のパラメータが来ることも許可するが、パラメータをパターンマッチさせることはできない。</p>
<pre><code class="language-lean">def tail1 {α : Type u} : List α → List α
  | []      =&gt; []
  | a :: as =&gt; as

def tail2 : {α : Type u} → List α → List α
  | α, []      =&gt; []
  | α, a :: as =&gt; as
</code></pre>
<p>この2つの例では、パラメータ <code>α</code> の出現位置が異なるにもかかわらず、どちらの例でも場合分けに参加しないという意味で同じように扱われている。</p>
<p>Leanは、依存型の引数が場合分けにおいて「このケースが生じることはない」という追加の制約を与えるような、より複雑な形のパターンマッチングも扱うことができる。このような<em>dependent pattern matching</em>(依存パターンマッチング)の例については、<a href="induction_and_recursion.html#dependent-pattern-matching-%E4%BE%9D%E5%AD%98%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3%E3%83%9E%E3%83%83%E3%83%81%E3%83%B3%E3%82%B0">Dependent Pattern Matching (依存パターンマッチング)</a>の節で説明する。</p>
<h2 id="wildcards-and-overlapping-patterns-ワイルドカードとケースの重複"><a class="header" href="#wildcards-and-overlapping-patterns-ワイルドカードとケースの重複">Wildcards and Overlapping Patterns (ワイルドカードとケースの重複)</a></h2>
<p>前節の例の1つについて考える:</p>
<pre><code class="language-lean">def foo : Nat → Nat → Nat
  | 0,   n   =&gt; 0
  | m+1, 0   =&gt; 1
  | m+1, n+1 =&gt; 2
</code></pre>
<p>この例は次のように表現することもできる:</p>
<pre><code class="language-lean">def foo : Nat → Nat → Nat
  | 0, n =&gt; 0
  | m, 0 =&gt; 1
  | m, n =&gt; 2
</code></pre>
<p>2つ目の表現では、ケースが重複している。例えば、引数のペア <code>0 0</code> は3つのケース全てにマッチする。しかし、Leanは上のケースから順にパターンマッチングを試し、一番最初にマッチしたケースを使うことで曖昧さを解消するので、この2つの例は結果的に同じ関数を定義している。実際、2つ目の表現について以下の等式がdefinitionallyに成立する:</p>
<pre><code class="language-lean">def foo : Nat → Nat → Nat
  | 0, n =&gt; 0
  | m, 0 =&gt; 1
  | m, n =&gt; 2
example : foo 0     0     = 0 := rfl
example : foo 0     (n+1) = 0 := rfl
example : foo (m+1) 0     = 1 := rfl
example : foo (m+1) (n+1) = 2 := rfl
</code></pre>
<p><code>m</code> と <code>n</code> の値は出力の定義に必要ないので、代わりにワイルドカードパターンを使ってもよい。</p>
<pre><code class="language-lean">def foo : Nat → Nat → Nat
  | 0, _ =&gt; 0
  | _, 0 =&gt; 1
  | _, _ =&gt; 2
</code></pre>
<p>直前の定義と同様に、この <code>foo</code> の定義が4つの恒等式をdefinitionallyに満たすことは容易に確認できる。</p>
<p>関数型プログラミング言語の中には、<em>incomplete pattern matching</em>(不完全なパターンマッチング)をサポートするものがある。これらの言語では、インタプリタはケースリスト内のどのケースともマッチしない入力に対して例外を生成するか、任意の値を返す。Leanでは、<code>Inhabited</code> 型クラスを使うと、「どのケースともマッチしない入力に対して任意の値を返す」アプローチをシミュレートできる。大雑把に言うと、<code>Inhabited α</code> は <code>α</code> の要素が存在することの証人である。<a href="./type_classes.html">10章 Type Classes (型クラス)</a>では、Leanに適切な基底型がinhabited(有項)であることを指示でき、Leanはその指示に基づいて、他の構築された型が有項であることを自動的に推論できることを説明する。これに基づいて、標準ライブラリは任意の有項型のデフォルト項 <code>default</code> を提供する。</p>
<p>型 <code>Option α</code> を使って不完全なパターンマッチングをシミュレートすることもできる。このアプローチでは、入力が適切に提供されたケースとマッチしたときは <code>some a</code> を返し、不完全なケースとマッチしたときは <code>none</code> を返す。次の例は、両方のアプローチを示している。</p>
<pre><code class="language-lean">def f1 : Nat → Nat → Nat
  | 0, _  =&gt; 1
  | _, 0  =&gt; 2
  | _, _  =&gt; default  -- the &quot;incomplete&quot; case

example : f1 0     0     = 1       := rfl
example : f1 0     (a+1) = 1       := rfl
example : f1 (a+1) 0     = 2       := rfl
example : f1 (a+1) (b+1) = default := rfl

def f2 : Nat → Nat → Option Nat
  | 0, _  =&gt; some 1
  | _, 0  =&gt; some 2
  | _, _  =&gt; none     -- the &quot;incomplete&quot; case

example : f2 0     0     = some 1 := rfl
example : f2 0     (a+1) = some 1 := rfl
example : f2 (a+1) 0     = some 2 := rfl
example : f2 (a+1) (b+1) = none   := rfl
</code></pre>
<p>等式コンパイラは賢い。以下の定義のどれかのケースを省くと、エラーメッセージでどんなケースがカバーされていないかを知らせてくれる。</p>
<pre><code class="language-lean">def bar : Nat → List Nat → Bool → Nat
  | 0,   _,      false =&gt; 0
  | 0,   b :: _, _     =&gt; b
  | 0,   [],     true  =&gt; 7
  | a+1, [],     false =&gt; a
  | a+1, [],     true  =&gt; a + 1
  | a+1, b :: _, _     =&gt; a + b
</code></pre>
<p>また、等式コンパイラは適切な状況では <code>casesOn</code> の代わりに &quot;if ... then ... else&quot; 構文を用いる。</p>
<pre><code class="language-lean">def foo : Char → Nat
  | 'A' =&gt; 1
  | 'B' =&gt; 2
  | _   =&gt; 3

#print foo.match_1
</code></pre>
<h2 id="structural-recursion-and-induction-構造的再帰と構造的帰納法"><a class="header" href="#structural-recursion-and-induction-構造的再帰と構造的帰納法">Structural Recursion and Induction (構造的再帰と構造的帰納法)</a></h2>
<p>再帰的定義もサポートしていることが、等式コンパイラを強力なものにしている。次の3つの節では、ここに挙げる3つの概念それぞれについて説明する:</p>
<ul>
<li>structurally recursive definitions(構造的再帰的定義)</li>
<li>well-founded recursive definitions(整礎再帰的定義)</li>
<li>mutually recursive definitions(相互再帰的定義)</li>
</ul>
<p>一般的に、等式コンパイラは次の形式の入力を処理する:</p>
<pre><code>def foo (a : α) : (b : β) → γ
  | [patterns₁] =&gt; t₁
  ...
  | [patternsₙ] =&gt; tₙ
</code></pre>
<p>ここで、<code>(a : α)</code> はパラメータの列、<code>(b : β)</code> はパターンマッチングが行われる引数の列、<code>γ</code> は任意の型であり、<code>γ</code> は <code>a</code> と <code>b</code> に依存することができる。<code>[patterns₁]</code> から <code>[patternsₙ]</code> は同じ数のパターンを含むべきであり、1つのパターンが <code>β</code> の各要素と対応する。これまで見てきたように、パターンは変数、他のパターンにコンストラクタを適用したもの、またはそのような形式に正規化される式のいずれかである(ここで、コンストラクタでないものは <code>[match_pattern]</code> 属性でマークされる)。コンストラクタの出現はケースの分割を促す。ここで、コンストラクタへの引数は与えられた変数で表される。節<a href="induction_and_recursion.html#dependent-pattern-matching-%E4%BE%9D%E5%AD%98%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3%E3%83%9E%E3%83%83%E3%83%81%E3%83%B3%E3%82%B0">Dependent Pattern Matching (依存パターンマッチング)</a>では、パターンマッチングでは何の役割も果たさないが、式の型チェックを行うために必要となる明示的な項をパターンに含める必要がある場合があることを説明する。この明示的な項は今述べた理由により<em>inaccessible patterns</em>(アクセス不能パターン)と呼ばれる。しかし、節<a href="induction_and_recursion.html#dependent-pattern-matching-%E4%BE%9D%E5%AD%98%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3%E3%83%9E%E3%83%83%E3%83%81%E3%83%B3%E3%82%B0">Dependent Pattern Matching (依存パターンマッチング)</a>より前では、アクセス不能パターンを使う必要はない。</p>
<p>前節で見たように、出力を定義する項 <code>t₁, ..., tₙ</code> は、任意のパラメータ <code>a</code> だけでなく、対応するパターン内で導入された変数を利用することができる。再帰と帰納が可能なのは、出力を定義する項が <code>foo</code> への再帰的呼び出しを含むことすら可能だからである。この節では、<em>structural recursion</em>(構造的再帰)を扱う。構造的再帰では、<code>=&gt;</code> の右辺に現れる <code>foo</code> への引数は <code>=&gt;</code> の左辺のパターンの部分項である。これは、部分項はマッチした引数よりstructurally small(構造的に小さい)であるため、帰納型の項としてマッチした引数より先に構築されるという考え方である。前章の構造的再帰の例を、今度は等式コンパイラを使って定義しよう:</p>
<pre><code class="language-lean">open Nat
def add : Nat → Nat → Nat
  | m, zero   =&gt; m
  | m, succ n =&gt; succ (add m n)

theorem add_zero (m : Nat)   : add m zero = m := rfl
theorem add_succ (m n : Nat) : add m (succ n) = succ (add m n) := rfl

theorem zero_add : ∀ n, add zero n = n
  | zero   =&gt; rfl
  | succ n =&gt; congrArg succ (zero_add n)

def mul : Nat → Nat → Nat
  | n, zero   =&gt; zero
  | n, succ m =&gt; add (mul n m) n

theorem mul_zero (m : Nat)   : mul m zero = zero := rfl
theorem mul_succ (m n : Nat) : mul m (succ n) = add (mul m n) m := rfl
</code></pre>
<p>この <code>zero_add</code> の証明は、Leanにおいて帰納法による証明が再帰の一つの形であることを明らかにしている。</p>
<p>上の例は、<code>add</code> と <code>mul</code> を定義する式がdefinitionallyに成立することを示している。等式コンパイラは構造的帰納法による証明内でも、可能な限り関数を定義する式がdefinitionallyに成立するようにする。例えば、<code>zero_add</code> の証明において、引数が <code>zero</code> のケースは <code>rfl</code> を使うだけで示せる。しかしながら、他の状況では、引数の部分項に関する当該定理(例えば <code>zero_add n</code>)は<em>propositionally</em>にしか成立しない。つまり、これは明示的に適用されなければならない等式定理である。等式コンパイラは <code>zero_add n</code> のような定理を内部的に作成するが、これらの定理はユーザーが直接使うものではなく、<code>simp</code> タクティクが必要に応じて使うように設定されている。したがって、次の <code>zero_add</code> の証明も機能する:</p>
<pre><code class="language-lean">open Nat
<span class="boring">def add : Nat → Nat → Nat
</span><span class="boring">  | m, zero   =&gt; m
</span><span class="boring">  | m, succ n =&gt; succ (add m n)
</span>theorem zero_add : ∀ n, add zero n = n
  | zero   =&gt; by simp [add]
  | succ n =&gt; by simp [add, zero_add]
</code></pre>
<p>パターンマッチングによる定義と同様に、構造的再帰や構造的帰納法のパラメータがコロンの前に現れることがある。このようなパラメータは、定義が処理される前にローカルコンテキストに追加される。例えば、加法の定義は次のように書くこともできる:</p>
<pre><code class="language-lean">open Nat
def add (m : Nat) : Nat → Nat
  | zero   =&gt; m
  | succ n =&gt; succ (add m n)
</code></pre>
<p>この例を <code>match</code> を使って書くこともできる。</p>
<pre><code class="language-lean">
/- `match` を使う場合はもちろん `:=` が必要になる -/

open Nat
def add (m n : Nat) : Nat :=
  match n with
  | zero   =&gt; m
  | succ n =&gt; succ (add m n)
</code></pre>
<p>構造的再帰のもっと面白い例はフィボナッチ関数 <code>fib</code> である。</p>
<pre><code class="language-lean">def fib : Nat → Nat
  | 0   =&gt; 1
  | 1   =&gt; 1
  | n+2 =&gt; fib (n+1) + fib n

example : fib 0 = 1 := rfl
example : fib 1 = 1 := rfl
example : fib (n + 2) = fib (n + 1) + fib n := rfl

example : fib 7 = 21 := rfl
</code></pre>
<p>ここで、<code>n + 2</code>( <code>succ (succ n)</code> とdefinitionally equal)における <code>fib</code> 関数の値は、<code>n + 1</code>( <code>succ n</code> とdefinitionally equal)における値と <code>n</code> における値で定義される。しかし、これはフィボナッチ関数を計算する方法としてはきわめて非効率的で、実行時間は指数 <code>n</code> の指数関数となる。もっと良い方法がある:</p>
<pre><code class="language-lean">def fibFast (n : Nat) : Nat :=
  (loop n).2
where
  loop : Nat → Nat × Nat
    | 0   =&gt; (0, 1)
    | n+1 =&gt; let p := loop n; (p.2, p.1 + p.2)

#eval fibFast 100
</code></pre>
<p><code>where</code> の代わりに <code>let rec</code> を用いた定義は次の通り:</p>
<pre><code class="language-lean">def fibFast (n : Nat) : Nat :=
  let rec loop : Nat → Nat × Nat
    | 0   =&gt; (0, 1)
    | n+1 =&gt; let p := loop n; (p.2, p.1 + p.2)
  (loop n).2
</code></pre>
<p>どちらの例でも、Leanは補助関数 <code>fibFast.loop</code> を生成する。</p>
<p>構造的再帰を処理するために、等式コンパイラは各帰納型の定義時に自動生成される定数 <code>below</code> と <code>brecOn</code> を用いて、<em>course-of-values recursion</em>(累積再帰)を使用する。<code>Nat.below</code> と <code>Nat.brecOn</code> の型を見れば、それらがどのように機能するかを知ることができる:</p>
<pre><code class="language-lean">variable (C : Nat → Type u)

#check (@Nat.below C : Nat → Type u)

#reduce @Nat.below C (3 : Nat)

#check (@Nat.brecOn C : (n : Nat) → ((n : Nat) → @Nat.below C n → C n) → C n)
</code></pre>
<p>型 <code>@Nat.below C (3 : nat)</code> は、<code>C 0</code>、<code>C 1</code>、<code>C 2</code> の項を格納するデータ構造である。累積再帰は <code>Nat.brecOn</code> によって実装される。<code>Nat.brecOn</code> は型 <code>(n : Nat) → C n</code> を持つ依存関数の入力 <code>m</code> における値を、(<code>@Nat.below C m</code> の要素として表される)その関数の以前の全ての値を使って定義することを可能にする。</p>
<p>累積再帰の利用は、等式コンパイラがLeanのカーネルに対して特定の関数が停止することを正当に主張するために使うテクニックの一つである。他の関数型プログラミング言語のコンパイラと同様、再帰関数をコンパイルするコードジェネレータに影響を与えることはない。<code>#eval fib n</code> の実行時間は指数 <code>n</code> の指数関数となることを思い出してほしい。一方で、<code>#reduce fib n</code> は <code>brecOn</code> による構築に基づいた定義を使用するため効率的である。</p>
<pre><code class="language-lean">def fib : Nat → Nat
  | 0   =&gt; 1
  | 1   =&gt; 1
  | n+2 =&gt; fib (n+1) + fib n

-- #eval fib 50 -- slow
#reduce fib 50  -- fast

#print fib
</code></pre>
<p>再帰的定義のもう一つの良い例がリストの <code>append</code> 関数である。</p>
<pre><code class="language-lean">def append : List α → List α → List α
  | [],    bs =&gt; bs
  | a::as, bs =&gt; a :: append as bs

example : append [1, 2, 3] [4, 5] = [1, 2, 3, 4, 5] := rfl
</code></pre>
<p>もう一つ例を挙げる: <code>listAdd x y</code> は2つのリストのどちらかの要素がなくなるまで、最初のリストの先頭の要素 <code>a</code> と2番目のリストの先頭の要素 <code>b</code> を削除して <code>a + b</code> をリスト <code>z</code> に追加する操作を繰り返し、最後に <code>z</code> を返す。</p>
<pre><code class="language-lean">def listAdd [Add α] : List α → List α → List α
  | [],      _       =&gt; []
  | _,       []      =&gt; []
  | a :: as, b :: bs =&gt; (a + b) :: listAdd as bs

#eval listAdd [1, 2, 3] [4, 5, 6, 6, 9, 10]
-- [5, 7, 9]
</code></pre>
<p>以下の練習問題で、これに似た例に関して実験してみることをお勧めする。</p>
<h2 id="local-recursive-declarations-ローカルな再帰的定義"><a class="header" href="#local-recursive-declarations-ローカルな再帰的定義">Local Recursive Declarations (ローカルな再帰的定義)</a></h2>
<p><code>let rec</code> キーワードを使うと、ローカルな再帰的定義を宣言することができる。</p>
<pre><code class="language-lean">def replicate (n : Nat) (a : α) : List α :=
  let rec loop : Nat → List α → List α
    | 0,   as =&gt; as
    | n+1, as =&gt; loop n (a::as)
  loop n []

#check @replicate.loop
-- {α : Type} → α → Nat → List α → List α
</code></pre>
<p>Leanは各 <code>let rec</code> に対して補助定義を作成する。上の例では、<code>replicate</code> の定義内にある <code>let rec loop</code> のために <code>replicate.loop</code> の定義を作成している。Leanは、<code>let rec</code> 宣言内で使われたローカル変数を定義中の関数のパラメータに追加することで、宣言を「閉じる」ことに注意してほしい。例えば、ローカル変数 <code>a</code> は <code>let rec loop</code> 内で使われている。</p>
<p><code>let rec</code> をタクティクモード内で使うこともできる。また、帰納法による証明を作るために <code>let rec</code> を使うこともできる。</p>
<pre><code class="language-lean"><span class="boring">def replicate (n : Nat) (a : α) : List α :=
</span><span class="boring"> let rec loop : Nat → List α → List α
</span><span class="boring">   | 0,   as =&gt; as
</span><span class="boring">   | n+1, as =&gt; loop n (a::as)
</span><span class="boring"> loop n []
</span>theorem length_replicate (n : Nat) (a : α) : (replicate n a).length = n := by
  let rec aux (n : Nat) (as : List α)
              : (replicate.loop a n as).length = n + as.length := by
    match n with
    | 0   =&gt; simp [replicate.loop]
    | n+1 =&gt; simp [replicate.loop, aux n, Nat.add_succ, Nat.succ_add]
  exact aux n []
</code></pre>
<p>定義を記述した後に <code>where</code> キーワードを使って補助再帰的定義を導入することもできる。Leanはこれらを <code>let rec</code> に変換する。</p>
<pre><code class="language-lean">def replicate (n : Nat) (a : α) : List α :=
  loop n []
where
  loop : Nat → List α → List α
    | 0,   as =&gt; as
    | n+1, as =&gt; loop n (a::as)

theorem length_replicate (n : Nat) (a : α) : (replicate n a).length = n := by
  exact aux n []
where
  aux (n : Nat) (as : List α)
      : (replicate.loop a n as).length = n + as.length := by
    match n with
    | 0   =&gt; simp [replicate.loop]
    | n+1 =&gt; simp [replicate.loop, aux n, Nat.add_succ, Nat.succ_add]
</code></pre>
<h2 id="well-founded-recursion-and-induction-整礎再帰と整礎帰納法"><a class="header" href="#well-founded-recursion-and-induction-整礎再帰と整礎帰納法">Well-Founded Recursion and Induction (整礎再帰と整礎帰納法)</a></h2>
<p>構造的再帰が使えない場合は、整礎再帰を使えば再帰的定義中の関数が停止することを証明できる。整礎再帰に必要なのは、整礎関係と、各再帰適用(<code>f t</code> の形をとる)が特定の項 <code>t</code> をこの関係において「減少させる」ことの証明である。依存型理論は整礎再帰を表現し、その正当性を証明するのに十分強力である。これらの仕組みを理解するために必要な論理的背景の説明から始めよう。</p>
<p>Leanの標準ライブラリは2つの述語 <code>Acc r a</code> と <code>WellFounded r</code> を定義している。ここで、<code>r</code> は型 <code>α</code> 上の二項関係であり、<code>a</code> は型 <code>α</code> の要素である。</p>
<pre><code class="language-lean">variable (α : Sort u)
variable (r : α → α → Prop)

#check (Acc r : α → Prop)
#check (WellFounded r : Prop)
</code></pre>
<p>1つ目 <code>Acc</code> は帰納的に定義された述語である。定義(唯一のコンストラクタ <code>Acc.intro</code>)によると、<code>Acc r x</code> は <code>∀ y, r y x → Acc r y</code> と同値である。<code>Acc r x</code> は <code>r</code> の下で <code>x</code> がアクセス可能であることを意味する。<code>r y x</code> が一種の順序関係 <code>y ≺ x</code> を表すと考えるなら、<code>Acc r x</code> は <code>x</code> の全ての前者がアクセス可能であることと同値である。特に、<code>x</code> が前者を持たない場合、<code>x</code> はアクセス可能である。任意の型 <code>α</code> の任意のアクセス可能な項 <code>x</code> に対して、<code>x</code> の全ての前者に先に値を割り当てることで、<code>x</code> にも値を割り当てることができるはずである。</p>
<pre><code class="language-lean">noncomputable def f {α : Sort u}
      (r : α → α → Prop)
      (h : WellFounded r)
      (C : α → Sort v)
      (F : (x : α) → ((y : α) → r y x → C y) → C x)
      : (x : α) → C x := WellFounded.fix h F
</code></pre>
<p><code>f</code> の引数が長い列をなしているが、前半はすでに見たとおりである: <code>α</code> は型、<code>r</code> は二項関係、そして <code>h</code> は「<code>r</code> が整礎である」という仮説である。変数 <code>C</code> は再帰的定義の動機を表す: 各項 <code>x : α</code> について、<code>C x</code> の項を構築したい。関数 <code>F</code> は <code>C x</code> の項を構築するための帰納的レシピを提供する: <code>F</code> は <code>x</code> の各前者 <code>y</code> について <code>C y</code> の項が与えられたとき、要素 <code>C x</code> を構築する方法を教えてくれる。</p>
<p><code>WellFounded.fix</code> は帰納法においても同様に機能する。つまり、もし <code>≺</code> が整礎で、<code>∀ x, C x</code> を証明したいなら、任意の <code>x</code> に対して「<code>∀ y ≺ x, C y</code> ならば <code>C x</code>」を示せば十分である。</p>
<p>上の例では、コードジェネレータが現在 <code>WellFounded.fix</code> をサポートしていないため、<code>noncomputable</code> という修飾子を使用している。関数 <code>WellFounded.fix</code> はLeanが関数の停止を正当に主張するために使う(累積再帰とは別の)ツールである。</p>
<p>Leanは、自然数に関する通常の順序 <code>&lt;</code> が整礎であることを知っている。また、Leanは既存の順序から新しい整礎順序を構築する方法もいくつか知っている。例えば、辞書式順序を使う方法がある。</p>
<p>以下は、標準ライブラリ内にある自然数の除法の定義である。</p>
<pre><code class="language-lean">open Nat

theorem div_lemma {x y : Nat} : 0 &lt; y ∧ y ≤ x → x - y &lt; x :=
  fun h =&gt; sub_lt (Nat.lt_of_lt_of_le h.left h.right) h.left

def div.F (x : Nat) (f : (x₁ : Nat) → x₁ &lt; x → Nat → Nat) (y : Nat) : Nat :=
  if h : 0 &lt; y ∧ y ≤ x then
    (f (x - y) (div_lemma h) y) + 1
  else
    zero

noncomputable def div := WellFounded.fix (measure id).wf div.F

#reduce div 8 2 -- 4
</code></pre>
<p>この定義はやや分かりにくい。ここで再帰は <code>x</code> に対して行われ、<code>div.F x f : Nat → Nat</code> はその固定された <code>x</code> に対する「<code>y</code> で割る」関数を返す。再帰のレシピである <code>div.F</code> の第2引数 <code>f</code> は、<code>x</code> より小さい全ての値 <code>x₁</code> に対して「<code>y</code> で割る」関数を返す(と想定される)関数であることを理解する必要がある。</p>
<p>elaboratorはこのような定義をより便利に作成できるようにデザインされている。次のような定義の書き方が認められる:</p>
<pre><code class="language-lean">def div (x y : Nat) : Nat :=
  if h : 0 &lt; y ∧ y ≤ x then
    have : x - y &lt; x := Nat.sub_lt (Nat.lt_of_lt_of_le h.1 h.2) h.1
    (div (x - y) y) + 1
  else
    0
</code></pre>
<p>再帰的な定義に遭遇すると、Leanはまず構造的再帰を試み、それが失敗したときだけ整礎再帰を試みる。Leanは <code>decreasing_tactic</code> というタクティクを使って、再帰適用後の項が元の項より「小さい」ことを示す。上の例の補助命題 <code>x - y &lt; x</code> はこのタクティクのためのヒントとみなされる。</p>
<p><code>div</code> を定義する等式はdefinitionallyに成立<strong>しない</strong>。しかし、<code>unfold</code> タクティクを使えば <code>div</code> を展開することはできる。<a href="./conv.html"><code>conv</code></a>を使うと、展開したい <code>div</code> 適用後の項を選択できる。</p>
<pre><code class="language-lean"><span class="boring">def div (x y : Nat) : Nat :=
</span><span class="boring"> if h : 0 &lt; y ∧ y ≤ x then
</span><span class="boring">   have : x - y &lt; x := Nat.sub_lt (Nat.lt_of_lt_of_le h.1 h.2) h.1
</span><span class="boring">   div (x - y) y + 1
</span><span class="boring"> else
</span><span class="boring">   0
</span>example (x y : Nat) : div x y = if 0 &lt; y ∧ y ≤ x then div (x - y) y + 1 else 0 := by
  conv =&gt; lhs; unfold div -- 等式の左辺の `div` を展開する

example (x y : Nat) (h : 0 &lt; y ∧ y ≤ x) : div x y = div (x - y) y + 1 := by
  conv =&gt; lhs; unfold div
  simp [h]
</code></pre>
<p>次の例も同様の構文を使って整礎再帰を行う: <code>natToBin</code> は任意の自然数を0と1のリストとして表される2進表記に変換する。まず、再帰適用後の項が元の項より減少する証拠を示さなければならないが、これは <code>sorry</code> で行う。<code>sorry</code> はインタプリタが関数を正常に評価することを妨げるものではない。(訳者注: <code>#eval</code> を使って関数を評価するだけなら証拠は不要ということだと思われる。しかし証拠がない場合、任意の引数 <code>n</code> に対して <code>#eval natToBin n</code> が停止する保証はないと思われる。)</p>
<pre><code class="language-lean">def natToBin : Nat → List Nat
  | 0     =&gt; [0]
  | 1     =&gt; [1]
  | n + 2 =&gt;
    have : (n + 2) / 2 &lt; n + 2 := sorry
    natToBin ((n + 2) / 2) ++ [n % 2]

#eval natToBin 1234567
</code></pre>
<p>最後の例として、Leanではアッカーマン関数が本来の定義をそのまま書くだけで定義できることを見る。なぜなら、この整礎再帰は自然数の辞書式順序の整礎性によって正当化されるからである。<code>termination_by</code> キーワードはLeanに辞書式順序を使うように指示している。実際には、このキーワードは関数の2つの引数を <code>Nat × Nat</code> 型の項にマッピングしている。そして、Leanは型クラス解決を使って <code>WellFoundedRelation (Nat × Nat)</code> 型の要素を合成する。</p>
<pre><code class="language-lean">def ack : Nat → Nat → Nat
  | 0,   y   =&gt; y+1
  | x+1, 0   =&gt; ack x 1
  | x+1, y+1 =&gt; ack x (ack (x+1) y)
termination_by x y =&gt; (x, y)

#eval ack 3 5
-- アッカーマン関数は入力値の増加に伴い出力値が急速に増加する関数であり、
-- 例えば `#eval ack 4 1` などはバッファオーバーフロー等のエラーを引き起こす可能性が高いため、
-- 実行しないことをお勧めする。
</code></pre>
<p>インスタンス <code>WellFoundedRelation (α × β)</code> が辞書式順序を使うため、上の定義の中では辞書式順序が使われていることに注意してほしい。また、Leanは標準ライブラリ内で次のインスタンス <code>instWellFoundedRelation</code> も定義している。</p>
<pre><code class="language-lean">instance (priority := low) [SizeOf α] : WellFoundedRelation α :=
  sizeOfWFRel
</code></pre>
<p>次の例では、<code>as.size - i</code> が再帰適用によって減少することを示すことで、<code>go</code> の停止性を証明する。</p>
<pre><code class="language-lean">-- Array `as` を先頭から見て、
-- `as` の要素 `a` が `p a` を満たす限りArray `r` に `a` を追加し、`r` を返す関数
def takeWhile (p : α → Bool) (as : Array α) : Array α :=
  go 0 #[]
where
  go (i : Nat) (r : Array α) : Array α :=
    if h : i &lt; as.size then
      let a := as.get ⟨i, h⟩
      if p a then
        go (i+1) (r.push a)
      else
        r
    else
      r
termination_by as.size - i

#eval takeWhile (fun n : Nat =&gt; if n % 2 = 1 then true else false) #[1, 3, 5, 6, 7]
</code></pre>
<p>この例では、補助関数 <code>go</code> は再帰的だが、<code>takeWhile</code> は再帰的でないことに注意してほしい。</p>
<p>デフォルトでは、Leanは <code>decreasing_tactic</code> タクティクを使って再帰適用後の項が元の項より小さいことを証明する。<code>decreasing_by</code> 修飾子を使うと、独自のタクティクを提供することができる。以下はその例である。</p>
<pre><code class="language-lean">theorem div_lemma {x y : Nat} : 0 &lt; y ∧ y ≤ x → x - y &lt; x :=
  fun ⟨ypos, ylex⟩ =&gt; Nat.sub_lt (Nat.lt_of_lt_of_le ypos ylex) ypos

def div (x y : Nat) : Nat :=
  if h : 0 &lt; y ∧ y ≤ x then
    div (x - y) y + 1
  else
    0
decreasing_by apply div_lemma; assumption
</code></pre>
<p><code>decreasing_by</code> は <code>termination_by</code> を置き換えるものではなく、互いに補完し合うものである。<code>termination_by</code> は整礎関係を指定するのに使われ、<code>decreasing_by</code> は再帰適用後の項が元の項より小さいことを示すために独自のタクティクを提供するために使われる。次の例ではその両方を使う。</p>
<pre><code class="language-lean">def ack : Nat → Nat → Nat
  | 0,   y   =&gt; y+1
  | x+1, 0   =&gt; ack x 1
  | x+1, y+1 =&gt; ack x (ack (x+1) y)
termination_by x y =&gt; (x, y)
decreasing_by
  all_goals simp_wf -- unfolds well-founded recursion auxiliary definitions
  · apply Prod.Lex.left; simp_arith
  · apply Prod.Lex.right; simp_arith
  · apply Prod.Lex.left; simp_arith
</code></pre>
<p><code>decreasing_by sorry</code> を使えば、Leanに関数が停止することを「信じ」させることができる。</p>
<pre><code class="language-lean">def natToBin : Nat → List Nat
  | 0     =&gt; [0]
  | 1     =&gt; [1]
  | n + 2 =&gt; natToBin ((n + 2) / 2) ++ [n % 2]
decreasing_by sorry

#eval natToBin 1234567
</code></pre>
<p><code>sorry</code> を使うことは新しい公理を導入することと同じであり、避けるべきであることを思い出してほしい。次の例では、<code>sorry</code> を使って <code>False</code> を証明した。コマンド <code>#print axioms</code> は、<code>unsound</code> が <code>sorry</code> を実装するために使われている不健全な公理 <code>sorryAx</code> に依存していることを示す。</p>
<pre><code class="language-lean">def unsound (x : Nat) : False :=
  unsound (x + 1)
decreasing_by sorry

#check unsound 0
-- `unsound 0` is a proof of `False`

#print axioms unsound
-- 'unsound' depends on axioms: [sorryAx]
</code></pre>
<p>要約:</p>
<ul>
<li>
<p><code>termination_by</code> がない場合、Leanはある引数を選択し、型クラス解決を使って選択した引数の型上の整礎関係を合成することで、(可能であれば)整礎関係が導出される。</p>
</li>
<li>
<p><code>termination_by</code> が指定されている場合、<code>termination_by</code> は関数の引数を <code>α</code> 型にマッピングし、再び型クラス解決が使われる。<code>β × γ</code> に関するデフォルトインスタンスは <code>β</code> と <code>γ</code> 上の整礎関係に基づいた辞書式順序であることを思い出してほしい。</p>
</li>
<li>
<p><code>Nat</code> に関するデフォルトの整礎関係インスタンスは <code>&lt;</code> である。</p>
</li>
<li>
<p>デフォルトでは、選択された整礎関係について、再帰適用後の項が元の項より小さいことを示すために <code>decreasing_tactic</code> タクティクが使われる。<code>decreasing_tactic</code> が失敗した場合に表示されるエラーメッセージは残りのゴール <code>... |- G</code> を含む。<code>decreasing_tactic</code> は <code>assumption</code> タクティクを使うことに注意。つまり、<code>have</code> 式を使ってコンテキストに仮説を追加することがターゲット <code>G</code> の証明の役に立つことがある。<code>decreasing_by</code> を使って独自のタクティクを提供することもできる。</p>
</li>
</ul>
<h2 id="mutual-recursion-相互再帰"><a class="header" href="#mutual-recursion-相互再帰">Mutual Recursion (相互再帰)</a></h2>
<p>Leanは<em>mutual recursive definitions</em>(相互再帰的定義)もサポートしている。その構文は相互帰納型と似ている。以下に例を挙げる:</p>
<pre><code class="language-lean">mutual
  def even : Nat → Bool
    | 0   =&gt; true
    | n+1 =&gt; odd n

  def odd : Nat → Bool
    | 0   =&gt; false
    | n+1 =&gt; even n
end

example : even (a + 1) = odd a := by
  simp [even]

example : odd (a + 1) = even a := by
  simp [odd]

theorem even_eq_not_odd : ∀ a, even a = not (odd a) := by
  intro a; induction a
  . simp [even, odd]
  . simp [even, odd, *]
</code></pre>
<p><code>even</code> は <code>odd</code> を用いて定義され、<code>odd</code> は <code>even</code> を用いて定義されているため、この定義は相互定義になっている。内部では、この定義は単一の再帰的定義としてコンパイルされる。内部で定義された関数は、直和型の項を引数として取る。直和型の項の片側は <code>even</code> への入力、もう片側は <code>odd</code> への入力と解釈される。そして、入力に適した出力を返す。この関数を定義するために、Leanは適切な整礎関係を使用するが、その内部はユーザーから隠されている。このような定義を利用する正規の方法は、前節でやったように <code>simp</code> または <code>unfold</code> を使うことである。</p>
<p>また、相互再帰的定義は相互帰納型および入れ子帰納型を扱う自然な方法を提供する。前章で示した、相互帰納述語型としての <code>Even</code> と <code>Odd</code> の定義を思い出してほしい。</p>
<pre><code class="language-lean">mutual
  inductive Even : Nat → Prop where
    | even_zero : Even 0
    | even_succ : ∀ n, Odd n → Even (n + 1)

  inductive Odd : Nat → Prop where
    | odd_succ : ∀ n, Even n → Odd (n + 1)
end
</code></pre>
<p>コンストラクタ <code>even_zero</code>、<code>even_succ</code>、<code>odd_succ</code> はある自然数が偶数か奇数かを示す積極的な手段を提供する。0が奇数でないこと、そして後の2つのコンストラクタの意味が逆であることを知るには、この相互帰納型がこれらのコンストラクタによって生成されたという事実を使う必要がある。いつものように、コンストラクタは定義された型の名前を持つ名前空間に保管されており、コマンド <code>open Even Odd</code> を使えば、コンストラクタに便利にアクセスできるようになる。</p>
<pre><code class="language-lean"><span class="boring">mutual
</span><span class="boring"> inductive Even : Nat → Prop where
</span><span class="boring">   | even_zero : Even 0
</span><span class="boring">   | even_succ : ∀ n, Odd n → Even (n + 1)
</span><span class="boring"> inductive Odd : Nat → Prop where
</span><span class="boring">   | odd_succ : ∀ n, Even n → Odd (n + 1)
</span><span class="boring">end
</span>open Even Odd

theorem not_odd_zero : ¬ Odd 0 :=
  fun h =&gt; nomatch h

theorem even_of_odd_succ : ∀ n, Odd (n + 1) → Even n
  | _, odd_succ n h =&gt; h

theorem odd_of_even_succ : ∀ n, Even (n + 1) → Odd n
  | _, even_succ n h =&gt; h
</code></pre>
<p>別の例を挙げる。入れ子帰納型を使って、型 <code>Term</code> の項を帰納的に定義することを考える。ここで、<code>Term</code> の項は定数(文字列によって与えられる名前を持つ)か、定数のリストに定数を適用した結果のどちらかになるとする。</p>
<pre><code class="language-lean">inductive Term where
  | const : String → Term
  | app   : String → List Term → Term
</code></pre>
<p>そして、相互再帰を使って、各項の中に登場する定数の数を数える関数と、項のリストの中に登場する要素の数を数える関数を定義することができる。</p>
<pre><code class="language-lean"><span class="boring">inductive Term where
</span><span class="boring"> | const : String → Term
</span><span class="boring"> | app   : String → List Term → Term
</span>namespace Term

mutual
  def numConsts : Term → Nat
    | const _ =&gt; 1
    | app _ cs =&gt; numConstsLst cs

  def numConstsLst : List Term → Nat
    | [] =&gt; 0
    | c :: cs =&gt; numConsts c + numConstsLst cs
end

def sample := app &quot;f&quot; [app &quot;g&quot; [const &quot;x&quot;], const &quot;y&quot;]
def sample2 := [app &quot;g&quot; [const &quot;x&quot;, const &quot;y&quot;], const &quot;y&quot;]

#eval numConsts sample
#eval numConstsLst sample2

end Term
</code></pre>
<p>最後の例として、項 <code>e</code> 内の定数 <code>a</code> を <code>b</code> に置き換える関数 <code>replaceConst a b e</code> を定義し、<code>e</code> が持つ定数の個数と <code>replaceConst a b e</code> が持つ定数の個数が同じであることを証明する。この証明は、相互帰納法を使っていることに注意してほしい。</p>
<pre><code class="language-lean"><span class="boring">inductive Term where
</span><span class="boring"> | const : String → Term
</span><span class="boring"> | app   : String → List Term → Term
</span><span class="boring">namespace Term
</span><span class="boring">mutual
</span><span class="boring"> def numConsts : Term → Nat
</span><span class="boring">   | const _ =&gt; 1
</span><span class="boring">   | app _ cs =&gt; numConstsLst cs
</span><span class="boring">  def numConstsLst : List Term → Nat
</span><span class="boring">   | [] =&gt; 0
</span><span class="boring">   | c :: cs =&gt; numConsts c + numConstsLst cs
</span><span class="boring">end
</span>mutual
  def replaceConst (a b : String) : Term → Term
    | const c =&gt; if a == c then const b else const c
    | app f cs =&gt; app f (replaceConstLst a b cs)

  def replaceConstLst (a b : String) : List Term → List Term
    | [] =&gt; []
    | c :: cs =&gt; replaceConst a b c :: replaceConstLst a b cs
end

mutual
  theorem numConsts_replaceConst (a b : String) (e : Term)
            : numConsts (replaceConst a b e) = numConsts e := by
    match e with
    | const c =&gt; simp [replaceConst]; split &lt;;&gt; simp [numConsts]
    | app f cs =&gt; simp [replaceConst, numConsts, numConsts_replaceConstLst a b cs]

  theorem numConsts_replaceConstLst (a b : String) (es : List Term)
            : numConstsLst (replaceConstLst a b es) = numConstsLst es := by
    match es with
    | [] =&gt; simp [replaceConstLst, numConstsLst]
    | c :: cs =&gt;
      simp [replaceConstLst, numConstsLst, numConsts_replaceConst a b c,
            numConsts_replaceConstLst a b cs]
end
</code></pre>
<h2 id="dependent-pattern-matching-依存パターンマッチング"><a class="header" href="#dependent-pattern-matching-依存パターンマッチング">Dependent Pattern Matching (依存パターンマッチング)</a></h2>
<p><a href="induction_and_recursion.html#pattern-matching-%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3%E3%83%9E%E3%83%83%E3%83%81%E3%83%B3%E3%82%B0">Pattern Matching (パターンマッチング)</a>の節で説明した全ての例は、<code>casesOn</code> と <code>recOn</code> を使って簡単に書くことができる。しかし、<code>Vector α n</code> のような添字付き帰納族では、ケース分割が添字の値に制約を課すため、簡単に書けないことがよくある。もし等式コンパイラが無かったら、再帰子だけを使って <code>map</code>、<code>zip</code>、<code>unzip</code> などの非常に単純な関数を定義するために、多くの定型的なコードが必要になっただろう。その難しさを理解するために、ベクトル <code>v : Vector α (succ n)</code> を受け取り、最初の要素を削除したベクトルを返す関数 <code>tail</code> を定義するためには何が必要かを考えてみよう。まずは、<code>casesOn</code> 関数を使うことが考えられる:</p>
<pre><code class="language-lean">inductive Vector (α : Type u) : Nat → Type u
  | nil  : Vector α 0
  | cons : α → {n : Nat} → Vector α n → Vector α (n+1)

namespace Vector

#check @Vector.casesOn
/-
  {α : Type u}
  → {motive : (a : Nat) → Vector α a → Sort v} →
  → {a : Nat} → (t : Vector α a)
  → motive 0 nil
  → ((a : α) → {n : Nat} → (a_1 : Vector α n) → motive (n + 1) (cons a a_1))
  → motive a t
-/

end Vector
</code></pre>
<p>しかし、入力が <code>nil</code> の場合は何を返せばいいだろうか。何かおかしなことが起こっている: <code>v</code> の型が <code>Vector α (succ n)</code> なら、<code>v</code> が <code>nil</code> である<strong>はずがない</strong>。しかし、それを <code>casesOn</code> に伝える方法は明らかではない。</p>
<p>1つの解決策は、補助関数を定義することである:</p>
<pre><code class="language-lean"><span class="boring">inductive Vector (α : Type u) : Nat → Type u
</span><span class="boring">  | nil  : Vector α 0
</span><span class="boring">  | cons : α → {n : Nat} → Vector α n → Vector α (n+1)
</span><span class="boring">namespace Vector
</span>def tailAux (v : Vector α m) : m = n + 1 → Vector α n :=
  Vector.casesOn (motive := fun x _ =&gt; x = n + 1 → Vector α n) v
    (fun h : 0 = n + 1 =&gt; Nat.noConfusion h)
    (fun (a : α) (m : Nat) (as : Vector α m) =&gt;
     fun (h : m + 1 = n + 1) =&gt;
       Nat.noConfusion h (fun h1 : m = n =&gt; h1 ▸ as))

def tail (v : Vector α (n+1)) : Vector α n :=
  tailAux v rfl
<span class="boring">end Vector
</span></code></pre>
<p>補助関数 <code>tailAux</code> において、<code>v</code> が <code>nil</code> の場合、<code>m</code> の値は <code>0</code> に決定し、<code>noConfusion</code> は <code>0 = succ n</code> は成立しえないという事実を使う。そうでなければ、<code>v</code> は <code>a :: w</code> の形をとり、<code>w</code> を長さ <code>m</code> のベクトルから長さ <code>n</code> のベクトルへキャストした後、単純に <code>w</code> を返すことができる(<code>h1 ▸ as</code>)。</p>
<p><code>tail</code> を定義する上で難しいのは、添字間の関係を維持することである。<code>tailAux</code> 内の仮説 <code>e : m = n + 1</code> は、<code>n</code> と小前提(<code>Vector.casesOn</code> の4番目と5番目の引数)に関連した添字(<code>0</code> と <code>m + 1</code>)の関係を <code>noConfusion</code> 等に伝えるために使われる。さらに、<code>zero = n + 1</code> のケースは到達不能である。このようなケースを破棄する正規の方法は <code>noConfusion</code> を使うことである。</p>
<p>しかし、実際は <code>tail</code> 関数は再帰を使って簡単に定義できる。そして、等式コンパイラが全ての定型コードを自動的に生成してくれる。似た例をいくつか紹介しよう:</p>
<pre><code class="language-lean"><span class="boring">inductive Vector (α : Type u) : Nat → Type u
</span><span class="boring">  | nil  : Vector α 0
</span><span class="boring">  | cons : α → {n : Nat} → Vector α n → Vector α (n+1)
</span><span class="boring">namespace Vector
</span>def head : {n : Nat} → Vector α (n+1) → α
  | n, cons a as =&gt; a

def tail : {n : Nat} → Vector α (n+1) → Vector α n
  | n, cons a as =&gt; as

theorem eta : ∀ {n : Nat} (v : Vector α (n+1)), cons (head v) (tail v) = v
  | n, cons a as =&gt; rfl

def map (f : α → β → γ) : {n : Nat} → Vector α n → Vector β n → Vector γ n
  | 0,   nil,       nil       =&gt; nil
  | n+1, cons a as, cons b bs =&gt; cons (f a b) (map f as bs)

def zip : {n : Nat} → Vector α n → Vector β n → Vector (α × β) n
  | 0,   nil,       nil       =&gt; nil
  | n+1, cons a as, cons b bs =&gt; cons (a, b) (zip as bs)
<span class="boring">end Vector
</span></code></pre>
<p>再帰的定義において、<code>head nil</code> のような「到達不能」なケースはケースリストから除外できることに注意してほしい。自動生成される添字付き帰納族の定義は単純とは言いがたいものである。次の例について、<code>#print</code> コマンドの出力を見てほしい:</p>
<pre><code class="language-lean"><span class="boring">inductive Vector (α : Type u) : Nat → Type u
</span><span class="boring">  | nil  : Vector α 0
</span><span class="boring">  | cons : α → {n : Nat} → Vector α n → Vector α (n+1)
</span><span class="boring">namespace Vector
</span>def map (f : α → β → γ) : {n : Nat} → Vector α n → Vector β n → Vector γ n
  | 0,   nil,       nil       =&gt; nil
  | n+1, cons a as, cons b bs =&gt; cons (f a b) (map f as bs)

#print map
#print map.match_1
<span class="boring">end Vector
</span></code></pre>
<p><code>map</code> 関数を手で定義するのは <code>tail</code> 関数よりもさらに面倒である。自信のある人は <code>recOn</code>、<code>casesOn</code>、<code>noConfusion</code> を使って <code>map</code> 関数を手作りしてみてほしい。</p>
<h2 id="inaccessible-patterns-アクセス不能パターン"><a class="header" href="#inaccessible-patterns-アクセス不能パターン">Inaccessible Patterns (アクセス不能パターン)</a></h2>
<p>依存パターンマッチングにおいて、項の型を適切に特殊化するために、定義には必要のない引数を含まなければならない場合がある。Leanでは、このような補助項を、パターンマッチングにおいて<em>inaccessible</em>(アクセス不能)なものとしてマークすることができる。例えば、左辺に出現する項が変数単体でも変数にコンストラクタを適用したものでもない場合、これらの注釈は不可欠である。なぜなら、それらの項はパターンマッチングにおいて不適切なターゲットだからである。このようなアクセス不能パターンは、ケースの左辺の<em>don't care</em>な構成要素とみなすことができる。<code>.(t)</code> と書くことで、補助項へのアクセスが不能であることを宣言することができる。アクセス不能パターンの形が推論できる場合は、<code>_</code> と書いてもよい。</p>
<p>次の例では、「<code>f</code> のimage(像)の中にある」という性質を定義する帰納型を宣言する。型 <code>ImageOf f b</code> の項は、<code>b</code> が <code>f</code> の像の中にあることの証拠だと見なすことができる。コンストラクタ <code>imf</code> はそのような証拠を構築するために使われる。それから、<code>f</code> の像の中にある項 <code>b</code> を受け取り、証拠 <code>imf a</code> に基づいて、<code>f</code> によって <code>b</code> にマップされた要素の1つ <code>a</code> を返す「逆関数」を持つ関数 <code>f</code> を定義することができる。型付けのルールに従うと、最初の引数を <code>f a</code> と書かなければならないが、この項は変数単体でも変数にコンストラクタを適用したものでもないため、パターンマッチングを用いた定義において何の役割も果たさない。以下の逆関数 <code>inverse</code> を定義するためには、<code>f a</code> にアクセス不能であるとマーク<strong>しなければならない</strong>。</p>
<pre><code class="language-lean">inductive ImageOf {α β : Type u} (f : α → β) : β → Type u where
  | imf : (a : α) → ImageOf f (f a)

open ImageOf

/-
def bad_inverse {f : α → β} : (b : β) → ImageOf f b → α
  | b, imf a =&gt; a  -- `imf a` has type `ImageOf f (f a)` but is expected to have type `ImageOf f b`

def bad_inverse' {f : α → β} : (b : β) → ImageOf f b → α
  | f a, imf a =&gt; a  -- invalid pattern
-/

def inverse {f : α → β} : (b : β) → ImageOf f b → α
  | .(f a), imf a =&gt; a

def inverse' {f : α → β} : (b : β) → ImageOf f b → α
  | _, imf a =&gt; a
</code></pre>
<p>上記の例では、アクセス不能注釈は <code>f</code> がパターンマッチング対象の変数では<strong>ない</strong>ことを明確にしている。</p>
<p>アクセス不能パターンは、依存パターンマッチングを利用する定義を明確にし、制御するために使用することができる。ある型 <code>α</code> に関連する加法演算があると仮定して、<code>α</code> の項を要素に持つ2つのベクトルを足し合わせる関数 <code>Vector.add</code> を定義することを考えてみよう:</p>
<pre><code class="language-lean">inductive Vector (α : Type u) : Nat → Type u
  | nil  : Vector α 0
  | cons : α → {n : Nat} → Vector α n → Vector α (n+1)

namespace Vector

def add [Add α] : {n : Nat} → Vector α n → Vector α n → Vector α n
  | 0,   nil,       nil       =&gt; nil
  | n+1, cons a as, cons b bs =&gt; cons (a + b) (add as bs)

end Vector
</code></pre>
<p>引数 <code>{n : Nat}</code> はコロンの後に現れるが、これはパターンマッチングを用いた定義内で <code>n</code> を固定し続けることができないからである。この定義を実装したとき、等式コンパイラは最初の引数が <code>0</code> か <code>n+1</code> の形をとるかのケース判別から始める。続いて、次の2つの引数についてネストされたケース判別がなされる。それぞれのケースについて、等式コンパイラは最初の引数 <code>n</code> のパターンと整合性のないケースを除外する(例えば、<code>n+1, nil, nil</code> というパターンたちを持つケースを除外する)。</p>
<p>しかし、実際には最初の引数 <code>n</code> についてケース判別をする必要はない。<code>Vector</code> の <code>casesOn</code> エリミネータは2番目の引数でケース判別をするときに、引数 <code>n</code> の値を自動的に抽象化して <code>0</code> か <code>n + 1</code> に置き換える。アクセス不能パターンを使うことで、等式コンパイラに <code>n</code> でのケース判別を避けるように促すことができる。</p>
<pre><code class="language-lean"><span class="boring">inductive Vector (α : Type u) : Nat → Type u
</span><span class="boring">  | nil  : Vector α 0
</span><span class="boring">  | cons : α → {n : Nat} → Vector α n → Vector α (n+1)
</span><span class="boring">namespace Vector
</span>def add [Add α] : {n : Nat} → Vector α n → Vector α n → Vector α n
  | .(_), nil,       nil       =&gt; nil
  | .(_), cons a as, cons b bs =&gt; cons (a + b) (add as bs)
<span class="boring">end Vector
</span></code></pre>
<p>この位置をアクセス不能パターンとしてマークすることは、等式コンパイラに次の2つのことを伝える。第一に、最初の引数の形式は他の引数によってもたらされる制約から推論されるべきである。第二に、最初の引数はパターンマッチングに参加すべきでは<strong>ない</strong>。</p>
<p>アクセス不能パターン <code>.(_)</code> は簡便のため <code>_</code> と書くことができる。</p>
<pre><code class="language-lean"><span class="boring">inductive Vector (α : Type u) : Nat → Type u
</span><span class="boring">  | nil  : Vector α 0
</span><span class="boring">  | cons : α → {n : Nat} → Vector α n → Vector α (n+1)
</span><span class="boring">namespace Vector
</span>def add [Add α] : {n : Nat} → Vector α n → Vector α n → Vector α n
  | _, nil,       nil       =&gt; nil
  | _, cons a as, cons b bs =&gt; cons (a + b) (add as bs)
<span class="boring">end Vector
</span></code></pre>
<p>上述したように、引数 <code>{n : Nat}</code> は定義内で固定し続けることができないため、パターンマッチングの一部のならざるを得ない。Leanの以前のバージョンでは、ユーザーはこのような余分な判別子を含めなければならないことが面倒だとしばしば感じていた。そこで、Lean 4は新機能<em>discriminant refinement</em>(判別子の絞り込み)を実装した。この機能は余分な判別子を自動でパターンマッチングに含める。</p>
<pre><code class="language-lean"><span class="boring">inductive Vector (α : Type u) : Nat → Type u
</span><span class="boring">  | nil  : Vector α 0
</span><span class="boring">  | cons : α → {n : Nat} → Vector α n → Vector α (n+1)
</span><span class="boring">namespace Vector
</span>def add [Add α] {n : Nat} : Vector α n → Vector α n → Vector α n
  | nil,       nil       =&gt; nil
  | cons a as, cons b bs =&gt; cons (a + b) (add as bs)
<span class="boring">end Vector
</span></code></pre>
<p><em>auto bound implicits</em>(自動束縛暗黙引数)機能と組み合わせると、<code>add</code> の定義をより簡潔に書くことができる:</p>
<pre><code class="language-lean"><span class="boring">inductive Vector (α : Type u) : Nat → Type u
</span><span class="boring">  | nil  : Vector α 0
</span><span class="boring">  | cons : α → {n : Nat} → Vector α n → Vector α (n+1)
</span><span class="boring">namespace Vector
</span>def add [Add α] : Vector α n → Vector α n → Vector α n
  | nil,       nil       =&gt; nil
  | cons a as, cons b bs =&gt; cons (a + b) (add as bs)
<span class="boring">end Vector
</span></code></pre>
<p>これらの新機能を使うことで、前節で定義した他のベクトル関数を次のようによりコンパクトに書くことができる:</p>
<pre><code class="language-lean"><span class="boring">inductive Vector (α : Type u) : Nat → Type u
</span><span class="boring">  | nil  : Vector α 0
</span><span class="boring">  | cons : α → {n : Nat} → Vector α n → Vector α (n+1)
</span><span class="boring">namespace Vector
</span>def head : Vector α (n+1) → α
  | cons a as =&gt; a

def tail : Vector α (n+1) → Vector α n
  | cons a as =&gt; as

theorem eta : (v : Vector α (n+1)) → cons (head v) (tail v) = v
  | cons a as =&gt; rfl

def map (f : α → β → γ) : Vector α n → Vector β n → Vector γ n
  | nil,       nil       =&gt; nil
  | cons a as, cons b bs =&gt; cons (f a b) (map f as bs)

def zip : Vector α n → Vector β n → Vector (α × β) n
  | nil,       nil       =&gt; nil
  | cons a as, cons b bs =&gt; cons (a, b) (zip as bs)
<span class="boring">end Vector
</span></code></pre>
<h2 id="match-expressions-マッチ式"><a class="header" href="#match-expressions-マッチ式">Match Expressions (マッチ式)</a></h2>
<p>Leanは、多くの関数型言語で見られる<em>match-with</em>式のコンパイラも提供している。</p>
<pre><code class="language-lean">def isNotZero (m : Nat) : Bool :=
  match m with
  | 0   =&gt; false
  | n+1 =&gt; true
</code></pre>
<p><code>match</code> は普通のパターンマッチングによる定義とあまり変わらないように見える。しかし、<code>match</code> のポイントは、定義内のどこでも使えることと、任意の引数に対して使えることである。</p>
<pre><code class="language-lean">def isNotZero (m : Nat) : Bool :=
  match m with
  | 0   =&gt; false
  | n+1 =&gt; true

def filter (p : α → Bool) : List α → List α
  | []      =&gt; []
  | a :: as =&gt;
    match p a with
    | true =&gt; a :: filter p as
    | false =&gt; filter p as

example : filter isNotZero [1, 0, 0, 3, 0] = [1, 3] := rfl
</code></pre>
<p>別の例を挙げる:</p>
<pre><code class="language-lean">def foo (n : Nat) (b c : Bool) :=
  5 + match n - 5, b &amp;&amp; c with
      | 0,   true  =&gt; 0
      | m+1, true  =&gt; m + 7
      | 0,   false =&gt; 5
      | m+1, false =&gt; m + 3

#eval foo 7 true false

example : foo 7 true false = 9 := rfl
</code></pre>
<p>Leanは、システムの全ての部分で、パターンマッチングを実装するために内部で <code>match</code> 式を使用する。したがって、以下の4つの定義は全て同じ効果を持つ。</p>
<pre><code class="language-lean">def bar₁ : Nat × Nat → Nat
  | (m, n) =&gt; m + n

def bar₂ (p : Nat × Nat) : Nat :=
  match p with
  | (m, n) =&gt; m + n

def bar₃ : Nat × Nat → Nat :=
  fun (m, n) =&gt; m + n

def bar₄ (p : Nat × Nat) : Nat :=
  let (m, n) := p; m + n
</code></pre>
<p>命題を分解する際には、上記の変形版が役に立つ:</p>
<pre><code class="language-lean">variable (p q : Nat → Prop)

example : (∃ x, p x) → (∃ y, q y) → ∃ x y, p x ∧ q y
  | ⟨x, px⟩, ⟨y, qy⟩ =&gt; ⟨x, y, px, qy⟩

example (h₀ : ∃ x, p x) (h₁ : ∃ y, q y)
        : ∃ x y, p x ∧ q y :=
  match h₀, h₁ with
  | ⟨x, px⟩, ⟨y, qy⟩ =&gt; ⟨x, y, px, qy⟩

example : (∃ x, p x) → (∃ y, q y) → ∃ x y, p x ∧ q y :=
  fun ⟨x, px⟩ ⟨y, qy⟩ =&gt; ⟨x, y, px, qy⟩

example (h₀ : ∃ x, p x) (h₁ : ∃ y, q y)
        : ∃ x y, p x ∧ q y :=
  let ⟨x, px⟩ := h₀
  let ⟨y, qy⟩ := h₁
  ⟨x, y, px, qy⟩
</code></pre>
<h2 id="exercises-練習問題-4"><a class="header" href="#exercises-練習問題-4">Exercises (練習問題)</a></h2>
<ol>
<li>
<p>名前の衝突を避けるために名前空間 <code>Hidden</code> を開き、等式コンパイラを使って自然数上の加法、乗法、べき乗を定義せよ。次に、等式コンパイラを使って、それらの基本的な性質を証明せよ。</p>
</li>
<li>
<p>同様に、等式コンパイラを使ってリストに対する基本的な操作(<code>reverse</code> 関数など)を定義し、リストに関する定理を帰納法で証明せよ。例えば、任意のリストに対して、<code>reverse (reverse xs) = xs</code> となることを示せ。</p>
</li>
<li>
<p>累積再帰を実行する自然数上の関数を自分で定義せよ。同様に、<code>WellFounded.fix</code> を自分で定義する方法を見つけられるか試してみよ。</p>
</li>
<li>
<p>節<a href="induction_and_recursion.html#dependent-pattern-matching-%E4%BE%9D%E5%AD%98%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3%E3%83%9E%E3%83%83%E3%83%81%E3%83%B3%E3%82%B0">Dependent Pattern Matching (依存パターンマッチング)</a>の例に従って、2つのベクトル <code>va</code> <code>vb</code> を受け取り、<code>va</code> の末尾に <code>vb</code> を追加したベクトルを返す関数を定義せよ。これは厄介で、補助関数を定義しなければならないだろう。</p>
</li>
<li>
<p>次のような算術式の型を考える。ここで、<code>var n</code> は変数 <code>vₙ</code>を、<code>const n</code> は値が <code>n</code> である定数を表す。</p>
</li>
</ol>
<pre><code class="language-lean">inductive Expr where
  | const : Nat → Expr
  | var : Nat → Expr
  | plus : Expr → Expr → Expr
  | times : Expr → Expr → Expr
  deriving Repr

open Expr

def sampleExpr : Expr :=
  plus (times (var 0) (const 7)) (times (const 2) (var 1))
</code></pre>
<p>ここで、<code>sampleExpr</code> は <code>(v₀ * 7) + (2 * v₁)</code> を表す。</p>
<p>各 <code>var n</code> を <code>v n</code> に評価した上で、このような式(<code>Expr</code> の項)を評価する関数を書け。</p>
<pre><code class="language-lean"><span class="boring">inductive Expr where
</span><span class="boring">  | const : Nat → Expr
</span><span class="boring">  | var : Nat → Expr
</span><span class="boring">  | plus : Expr → Expr → Expr
</span><span class="boring">  | times : Expr → Expr → Expr
</span><span class="boring">  deriving Repr
</span><span class="boring">open Expr
</span><span class="boring">def sampleExpr : Expr :=
</span><span class="boring">  plus (times (var 0) (const 7)) (times (const 2) (var 1))
</span>def eval (v : Nat → Nat) : Expr → Nat
  | const n     =&gt; sorry
  | var n       =&gt; v n
  | plus e₁ e₂  =&gt; sorry
  | times e₁ e₂ =&gt; sorry

def sampleVal : Nat → Nat
  | 0 =&gt; 5
  | 1 =&gt; 6
  | _ =&gt; 0

-- 次のコマンドを実行せよ。`47` が出力されたら正解である。
-- #eval eval sampleVal sampleExpr
</code></pre>
<p>補助関数 <code>simpConst</code> を使って、<code>5 + 7</code> のような部分項を <code>12</code> に単純化する「定数融合関数」<code>fuse</code> を実装せよ。<code>plus</code> や <code>times</code> を単純化するために、まず引数を再帰的に単純化せよ。次に <code>simpConst</code> を適用して結果の単純化を試みよ。</p>
<pre><code class="language-lean"><span class="boring">inductive Expr where
</span><span class="boring">  | const : Nat → Expr
</span><span class="boring">  | var : Nat → Expr
</span><span class="boring">  | plus : Expr → Expr → Expr
</span><span class="boring">  | times : Expr → Expr → Expr
</span><span class="boring">  deriving Repr
</span><span class="boring">open Expr
</span><span class="boring">def eval (v : Nat → Nat) : Expr → Nat
</span><span class="boring">  | const n     =&gt; sorry
</span><span class="boring">  | var n       =&gt; v n
</span><span class="boring">  | plus e₁ e₂  =&gt; sorry
</span><span class="boring">  | times e₁ e₂ =&gt; sorry
</span>def simpConst : Expr → Expr
  | plus (const n₁) (const n₂)  =&gt; const (n₁ + n₂)
  | times (const n₁) (const n₂) =&gt; const (n₁ * n₂)
  | e                           =&gt; e

def fuse : Expr → Expr := sorry

theorem simpConst_eq (v : Nat → Nat)
        : ∀ e : Expr, eval v (simpConst e) = eval v e :=
  sorry

theorem fuse_eq (v : Nat → Nat)
        : ∀ e : Expr, eval v (fuse e) = eval v e :=
  sorry
</code></pre>
<p>最後の2つの定理は、<code>simpConst</code> や <code>fuse</code> が式の値を保存することを表す。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structures-and-records-構造体とレコード"><a class="header" href="#structures-and-records-構造体とレコード">Structures and Records (構造体とレコード)</a></h1>
<p>Leanの基礎システムは帰納型を含むことを見てきた。さらに、型宇宙、依存関数型、そして帰納型のみで巨大で頑丈な数学の体系を構築できるという驚くべき事実を説明した。それ以外の全てはこの3種類の型から派生するのである。Leanの標準ライブラリには帰納型の具体例(例えば <code>Nat</code>、<code>Prod</code>、<code>List</code>)が多数含まれており、論理的結合子でさえも帰納型を用いて定義されている。</p>
<p>コンストラクタを1つだけ持つ非再帰的帰納型は<em>structure</em>(構造体)または<em>record</em>(レコード)と呼ばれることを思い出してほしい。直積型は構造体であり、依存直積型(シグマ型)も同様に構造体である。一般に、構造体 <code>S</code> が定義されるとき、<code>S</code> の各インスタンス(レコード or オブジェクト)を「分解」し、そのフィールドに格納されている値を取り出すことができる<em>projection</em>(射影)関数も同時に定義することが多い。直積ペアの1番目の要素を返す関数 <code>prod.fst</code> と2番目の要素を返す関数 <code>prod.snd</code> はそのような射影関数の例である。</p>
<p>プログラムを書いたり数学を形式化するとき、多くのフィールドを含む構造を定義することは珍しくない。Leanでは、<code>structure</code> コマンドが構造体の定義をサポートするインフラを提供する。このコマンドを使って構造体を定義すると、Leanは各フィールドに対する射影関数を自動生成する。<code>structure</code> コマンドは、以前に定義した構造体に基づいて新しい構造体を定義することもできる。さらに、Leanは与えられた構造体のインスタンスを定義するための便利な記法も提供する。</p>
<h2 id="declaring-structures-構造体を定義する"><a class="header" href="#declaring-structures-構造体を定義する">Declaring Structures (構造体を定義する)</a></h2>
<p><code>structure</code> コマンドは、言わば帰納データ型を定義するための「フロントエンド」である。全ての <code>structure</code> 宣言は、構造体に与えられた名前と同じ名前の名前空間を導入する。<code>structure</code> コマンドの構文の一般的な形式は次の通りである:</p>
<pre><code>    structure &lt;name&gt; &lt;parameters&gt; &lt;parent-structures&gt; where
      &lt;constructor&gt; :: &lt;fields&gt;
</code></pre>
<p>ほとんどの部分はオプションである。構造体定義の例を挙げる:</p>
<pre><code class="language-lean">structure Point (α : Type u) where
  mk :: (x : α) (y : α)
</code></pre>
<p><code>Point</code> 型の値はコンストラクタ <code>Point.mk a b</code> を使って生成され、点 <code>p</code> のフィールドには <code>Point.x p</code> と <code>Point.y p</code> を使ってアクセスする(以下で見るように、<code>p.x</code> と <code>p.y</code> も同様に機能する)。<code>structure</code> コマンドは定義した構造体に関する有用な再帰子や定理も自動生成する。上の <code>Point</code> 型の宣言の際に自動生成されたもののいくつかを以下に挙げる。</p>
<pre><code class="language-lean"><span class="boring">structure Point (α : Type u) where
</span><span class="boring"> mk :: (x : α) (y : α)
</span>#check Point       -- a Type
#check @Point.rec  -- the eliminator
#check @Point.mk   -- the constructor
#check @Point.x    -- a projection
#check @Point.y    -- a projection
</code></pre>
<p>コンストラクタ名を指定しなかった場合、デフォルトでコンストラクタは <code>mk</code> と名付けられる。また、各フィールドの間に改行を入れると、フィールド名を括弧で囲むのを省略することができる。</p>
<pre><code class="language-lean">structure Point (α : Type u) where
  x : α
  y : α
</code></pre>
<p><code>structure</code> コマンドにより自動生成されたものを使った簡単な定理や式をいくつか紹介しよう。いつものように、<code>open Point</code> コマンドを使えば <code>Point</code> という接頭辞を省略した名前を使えるようになる。</p>
<pre><code class="language-lean"><span class="boring">structure Point (α : Type u) where
</span><span class="boring"> x : α
</span><span class="boring"> y : α
</span>#eval Point.x (Point.mk 10 20)
#eval Point.y (Point.mk 10 20)

open Point

example (a b : α) : x (mk a b) = a :=
  rfl

example (a b : α) : y (mk a b) = b :=
  rfl
</code></pre>
<p><code>p : Point Nat</code> が与えられたとき、ドット記法 <code>p.x</code> は <code>Point.x p</code> の略記である。これは構造体のフィールドにアクセスする便利な方法である。</p>
<pre><code class="language-lean"><span class="boring">structure Point (α : Type u) where
</span><span class="boring"> x : α
</span><span class="boring"> y : α
</span>def p := Point.mk 10 20

#check p.x  -- Nat
#eval p.x   -- 10
#eval p.y   -- 20
</code></pre>
<p>ドット記法はレコードの射影関数にアクセスするときだけでなく、同じ名前空間内で定義された他の関数を適用するときにも便利である。節<a href="./propositions_and_proofs.html#conjunction-%E9%80%A3%E8%A8%80">Conjunction (連言)</a>の内容を思い出してほしい。<code>p</code> が <code>Point</code> 型を持ち、<code>foo</code> の最初の非暗黙引数が <code>Point</code> 型を持つなら、式 <code>p.foo</code> は <code>Point.foo p</code> と解釈される。したがって、次の例のように、式 <code>p.add q</code> は <code>Point.add p q</code> の略記となる。</p>
<pre><code class="language-lean">structure Point (α : Type u) where
  x : α
  y : α
  deriving Repr

def Point.add (p q : Point Nat) :=
  mk (p.x + q.x) (p.y + q.y)

def p : Point Nat := Point.mk 1 2
def q : Point Nat := Point.mk 3 4

#eval p.add q  -- {x := 4, y := 6}
</code></pre>
<p>次の章では、型 <code>α</code> に関連する加法演算があるという仮定の下、<code>add</code> のような関数を定義して、それが <code>Point Nat</code> だけでなく <code>Point α</code> の項に対して汎用的に機能するようにする方法を学ぶ。</p>
<p>より一般的には、項 <code>p : Point</code> と式 <code>p.foo x y z</code> が与えられると、Leanは <code>Point.foo</code> の「<code>Point</code> 型の」最初の引数として <code>p</code> を挿入する。例えば、以下のスカラー倍の定義では、<code>p.smul 3</code> は <code>Point.smul 3 p</code> と解釈される。</p>
<pre><code class="language-lean"><span class="boring">structure Point (α : Type u) where
</span><span class="boring"> x : α
</span><span class="boring"> y : α
</span><span class="boring"> deriving Repr
</span>def Point.smul (n : Nat) (p : Point Nat) :=
  Point.mk (n * p.x) (n * p.y)

def p : Point Nat := Point.mk 1 2

#eval p.smul 3  -- {x := 3, y := 6}
</code></pre>
<p><code>List.map</code> 関数では同様のトリックがよく使われる。<code>List.map</code> 関数は2番目の非暗黙引数としてリストを取る:</p>
<pre><code class="language-lean">#check @List.map

def xs : List Nat := [1, 2, 3]
def f : Nat → Nat := fun x =&gt; x * x

#eval xs.map f  -- [1, 4, 9]
</code></pre>
<p>ここで、<code>xs.map f</code> は <code>List.map f xs</code> と解釈されている。</p>
<h2 id="objects-オブジェクト"><a class="header" href="#objects-オブジェクト">Objects (オブジェクト)</a></h2>
<p>これまでコンストラクタを使って構造体の項を作成してきた。多くのフィールドを含む構造体の場合、コンストラクタを使って構造体の項を作成する方法は、フィールドが定義された順番を覚えておく必要があるため、しばしば不便である。そこで、Leanでは構造体の項を定義するための次のような代替記法を用意している。(訳者注: <code>*</code> は括弧内が1回以上の繰り返しからなることを表す。実際にこの構文を用いるときに括弧を書く必要はない。)</p>
<pre><code>    { (&lt;field-name&gt; := &lt;expr&gt;)* : structure-type }
    or
    { (&lt;field-name&gt; := &lt;expr&gt;)* }
</code></pre>
<p>接尾辞 <code>: structure-type</code> は、期待される構造体の型が与えられた情報から推論できる場合はいつでも省略できる。例えば、<code>Point</code> 型のオブジェクト「点」を定義するためにこの記法を用いる。フィールドを指定する順番は任意であるため、以下の式は全て同じ点を定義する。</p>
<pre><code class="language-lean">structure Point (α : Type u) where
  x : α
  y : α

#check { x := 10, y := 20 : Point Nat }    -- { (&lt;field-name&gt; := &lt;expr&gt;)* : structure-type }
#check { y := 20, x := 10 : Point _ }      -- フィールドを指定する順番は任意
#check ({ x := 10, y := 20 } : Point Nat)  -- { (&lt;field-name&gt; := &lt;expr&gt;)* } 構造体の型が明らか

example : Point Nat :=
  { y := 20, x := 10 }                     -- { (&lt;field-name&gt; := &lt;expr&gt;)* } 構造体の型が明らか
</code></pre>
<p>フィールドの値が指定されていない場合、Leanはその値を推論しようとする。指定されていないフィールドの値を推論できなかった場合、Leanは対応するプレースホルダーを埋められなかったことを示すエラーフラグを立てる。</p>
<pre><code class="language-lean">structure MyStruct where
    {α : Type u}
    {β : Type v}
    a : α
    b : β

#check { a := 10, b := true : MyStruct }
</code></pre>
<p><em>Record update</em>(レコード更新)は、古いレコード(オブジェクト)の1つまたは複数のフィールドの値を変更して新しいレコードを作成する、もう1つの一般的操作である。Leanでは、フィールドへの値の割り当ての前に <code>s with</code> という注釈を追加することで、新しいレコード内の値未割り当てのフィールドを古いレコード <code>s</code> から取得するように指示することができる。複数の古いレコードが提供された場合、新しいレコード内でまだ値が指定されていないフィールドを含むレコードを見つけるまで、Leanは提供されたレコードを順番に参照する。全てのオブジェクトを参照した後、新しいレコード内に値未指定のフィールドが存在した場合、Leanはエラーを発生させる。</p>
<pre><code class="language-lean">structure Point (α : Type u) where
  x : α
  y : α
  deriving Repr

def p : Point Nat :=
  { x := 1, y := 2 }

#eval { p with y := 3 }  -- { x := 1, y := 3 }
#eval { p with x := 4 }  -- { x := 4, y := 2 }

structure Point3 (α : Type u) where
  x : α
  y : α
  z : α

def q : Point3 Nat :=
  { x := 5, y := 5, z := 5 }

def r : Point3 Nat :=
  { p, q with x := 6 }

example : r.x = 6 := rfl
example : r.y = 2 := rfl
example : r.z = 5 := rfl
</code></pre>
<h2 id="inheritance-継承"><a class="header" href="#inheritance-継承">Inheritance (継承)</a></h2>
<p>新しいフィールドを追加することで、既存の構造体を<em>extend</em>(拡張)させることができる。この機能によって、一種の<em>inheritance</em>(継承)をシミュレートすることができる。</p>
<pre><code class="language-lean">structure Point (α : Type u) where
  x : α
  y : α

inductive Color where
  | red | green | blue

structure ColorPoint (α : Type u) extends Point α where
  c : Color
</code></pre>
<p>次の例では、多重継承(複数の親構造体を一度に継承すること)を使って新しい構造体 <code>RedGreenPoint</code> を定義し、各親構造体のオブジェクトを使って <code>RedGreenPoint</code> 型のオブジェクトを定義する。</p>
<pre><code class="language-lean">structure Point (α : Type u) where
  x : α
  y : α
  z : α

structure RGBValue where
  red : Nat
  green : Nat
  blue : Nat

structure RedGreenPoint (α : Type u) extends Point α, RGBValue where
  no_blue : blue = 0

def p : Point Nat :=
  { x := 10, y := 10, z := 20 }

def rgp : RedGreenPoint Nat :=
  { p with red := 200, green := 40, blue := 0, no_blue := rfl }

example : rgp.x   = 10 := rfl
example : rgp.red = 200 := rfl
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-classes-型クラス"><a class="header" href="#type-classes-型クラス">Type Classes (型クラス)</a></h1>
<p>型クラスは、関数型プログラミング言語においてアドホックな多相性を実現する原理的な方法として導入された。まず、次のことを見る: もし関数が型固有の加法の実装を引数として取り、残りの引数に対してその加法の実装を呼び出すだけであれば、加法のようなアドホックな多相性関数を実装するのは簡単である。例えば、Leanで加法の実装を保持する構造体を宣言したとしよう。</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span>structure Add (a : Type) where
  add : a → a → a

#check @Add.add
-- Add.add : {a : Type} → Add a → a → a → a
-- `Add.add` はstructure宣言によって自動生成される射影関数
<span class="boring">end Ex
</span></code></pre>
<p>このLeanコードでは、<code>add</code> フィールドへの射影関数は <code>Add.add : {a : Type} → Add a → a → a → a</code> という型を持っている。ここで、型 <code>a</code> を囲んでいる波括弧は、<code>a</code> が暗黙の引数であることを示している。次のようにして <code>double</code> 関数を実装することができる:</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span><span class="boring">structure Add (a : Type) where
</span><span class="boring"> add : a → a → a
</span>def double (s : Add a) (x : a) : a :=
  s.add x x

#eval double { add := Nat.add } 10
-- 20

#eval double { add := Nat.mul } 10
-- 100

#eval double { add := Int.add } 10
-- 20
<span class="boring">end Ex
</span></code></pre>
<p><code>double { add := Nat.add } n</code> と書くことで自然数 <code>n</code> を2倍することができる。もちろん、このように手動で実装(を保持するレコード)を渡すのはユーザーにとって非常に面倒である。実際、そのような面倒さがあれば、アドホック多相性の潜在的な利点のほとんどを失うことになる。</p>
<p>型クラスの主な考え方は、まず <code>Add a</code> のような型の引数を暗黙にすることである。それから、ユーザーが定義したインスタンスを保管するデータベースを使用して、<em>typeclass resolution</em>(型クラス解決)として知られるプロセスを通じて、目的のインスタンス <code>{s : Add a}</code> を自動合成することである。Leanでは、上の例で <code>structure</code> を <code>class</code> に書き換えることで、<code>Add.add</code> の型は次のように変化する:</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span>class Add (a : Type) where
  add : a → a → a

#check @Add.add
-- Add.add : {a : Type} → [self : Add a] → a → a → a
<span class="boring">end Ex
</span></code></pre>
<p>ここで、角括弧 <code>[]</code> は <code>Add a</code> 型の引数が<em>instance implicit</em>(インスタンス暗黙引数)であること、つまり型クラス解決を使って合成されるべきであることを示している。<code>class</code> 宣言によって自動生成された <code>add</code> 射影関数は、Haskellの <code>add :: Add a =&gt; a -&gt; a -&gt; a</code> のLean版である。そして、ユーザー定義インスタンスは次のように登録できる:</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span><span class="boring">class Add (a : Type) where
</span><span class="boring"> add : a → a → a
</span>instance : Add Nat where
  add := Nat.add

instance : Add Int where
  add := Int.add

instance : Add Float where
  add := Float.add
<span class="boring">end Ex
</span></code></pre>
<p>インスタンスの登録後、<code>n : Nat</code> と <code>m : Nat</code> に対して、<code>Add.add n m</code> という項は、<code>Add Nat</code> 型のインスタンス合成を目標とする型クラス解決を引き起こす。型クラス解決は上で <code>instance</code> 宣言を用いて登録した <code>Add Nat</code> のインスタンスを参照し、目標のインスタンスを合成する。インスタンス暗黙引数を使って、<code>double</code> を再実装することができる:</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span><span class="boring">class Add (a : Type) where
</span><span class="boring">  add : a → a → a
</span><span class="boring">instance : Add Nat where
</span><span class="boring"> add := Nat.add
</span><span class="boring">instance : Add Int where
</span><span class="boring"> add := Int.add
</span><span class="boring">instance : Add Float where
</span><span class="boring"> add := Float.add
</span>def double [Add a] (x : a) : a :=
  Add.add x x

#check @double
-- @double : {a : Type} → [inst : Add a] → a → a

#eval double 10
-- 20

#eval double (10 : Int)
-- 20

#eval double (7 : Float)
-- 14.000000

#eval double (239.0 + 2)
-- 482.000000

<span class="boring">end Ex
</span></code></pre>
<!--
(訳者注: この時点では、大雑把に言えば、型クラスは型クラス解決によりインスタンスが自動合成される構造体だといえる。)
-->
<p>一般的に、インスタンスは複雑な方法で他のインスタンスに依存することがある。例えば、「もし <code>a</code> が加法を持つなら、<code>Array a</code> も加法を持つ」と主張する(無名)インスタンスを宣言することができる:</p>
<pre><code class="language-lean">instance [Add a] : Add (Array a) where
  add x y := Array.zipWith x y (· + ·)

#eval Add.add #[1, 2] #[3, 4]
-- #[4, 6]

#eval #[1, 2] + #[3, 4]
-- #[4, 6]
</code></pre>
<p>Leanにおいて <code>(· + ·)</code> は <code>fun x y =&gt; x + y</code> の略記であることに注意してほしい。</p>
<p>上記の例では、記法をオーバーロード(多重定義)するために型クラスを使う方法を実践した。別の応用例も見てみよう。まず、Leanにおいて、型は項を1つも持たないことがあることを思い出してほしい。しかし、型が有項なら、その型について様々なことができるようになる。Leanを使っていると、ある型の任意の項が必要になることがよくある。例えば、「コーナーケース」において任意の項を返す関数を定義したいと思うことがよくある。また、<code>xs</code> が <code>List a</code> 型を持つとき、<code>head xs</code> は <code>a</code> 型を持ってほしいと思うかもしれない。同様に、型が空でないという付加的な仮定の下では、多くの付加的な定理が成立する。例えば、<code>a</code> が型であるとき、<code>exists x : a, x = x</code> が成立するためには <code>a</code> が空でないことが必要である。標準ライブラリは、有項型の<em>default</em>要素を推論できるようにするために、<code>Inhabited</code> という型クラスを定義している。今述べた応用例を実践するために、まず適切なクラスを宣言することから始めよう:</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span>class Inhabited (a : Type u) where
  default : a

#check @Inhabited.default
-- Inhabited.default : {a : Type u} → [self : Inhabited a] → a
<span class="boring">end Ex
</span></code></pre>
<p><code>Inhabited.default</code> は明示的な引数を持たないことに注意してほしい。</p>
<p><code>Inhabited a</code> クラスの項とは、ある項 <code>x : a</code> に対する <code>Inhabited.mk x</code> という形の式である。射影 <code>Inhabited.default</code> を使えば、<code>Inhabited a</code> の項から <code>a</code> の項 <code>x</code> を「抽出」することができる。次に、このクラスにいくつかのインスタンスを登録する:</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span><span class="boring">class Inhabited (a : Type _) where
</span><span class="boring"> default : a
</span>instance : Inhabited Bool where
  default := true

instance : Inhabited Nat where
  default := 0

instance : Inhabited Unit where
  default := ()

instance : Inhabited Prop where
  default := True

#eval (Inhabited.default : Nat)
-- 0

#eval (Inhabited.default : Bool)
-- true
<span class="boring">end Ex
</span></code></pre>
<p><code>export</code> コマンドを使うと、<code>Inhabited.default</code> に対して別名 <code>default</code> を生成することができる(正確には、<code>export</code> コマンドは名前空間 <code>Foo</code> 内で <code>Bar.baz</code> に対して別名 <code>Foo.baz</code> を生成する)。</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span><span class="boring">class Inhabited (a : Type _) where
</span><span class="boring"> default : a
</span><span class="boring">instance : Inhabited Bool where
</span><span class="boring"> default := true
</span><span class="boring">instance : Inhabited Nat where
</span><span class="boring"> default := 0
</span><span class="boring">instance : Inhabited Unit where
</span><span class="boring"> default := ()
</span><span class="boring">instance : Inhabited Prop where
</span><span class="boring"> default := True
</span>export Inhabited (default)

#eval (default : Nat)
-- 0

#eval (default : Bool)
-- true
<span class="boring">end Ex
</span></code></pre>
<h2 id="chaining-instances-インスタンスの連鎖"><a class="header" href="#chaining-instances-インスタンスの連鎖">Chaining Instances (インスタンスの連鎖)</a></h2>
<p>型クラス推論で出来ることがこれで終わりだとしたら、それほど印象的なものではないだろう。もしそうなら、型クラス推論はユーザー定義インスタンスを保存して、elaboratorがルックアップテーブル(配列や連想配列などのデータ構造)からそれらを見つけられるようにする仕組みに過ぎないからである。型クラス推論が強力なのは、インスタンスを「連鎖」させることができるからである。つまり、インスタンス宣言は、他の型クラスの暗黙のインスタンスに依存することができる。これにより、型クラス推論は、Prolog-likeな探索を用いて、必要に応じてバックトラッキングしながら、再帰的にインスタンスを連鎖させることができる。</p>
<p>例えば、次の定義は、2つの型 <code>a</code> と <code>b</code> が有項なら、その直積型 <code>a × b</code> も有項であることを示している:</p>
<pre><code class="language-lean">instance [Inhabited a] [Inhabited b] : Inhabited (a × b) where
  default := (default, default)
</code></pre>
<p>前節のインスタンス宣言に今の宣言を加えることで、例えば <code>Nat × Bool</code> のデフォルト項を推論できるようになる:</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span><span class="boring">class Inhabited (a : Type u) where
</span><span class="boring"> default : a
</span><span class="boring">instance : Inhabited Bool where
</span><span class="boring"> default := true
</span><span class="boring">instance : Inhabited Nat where
</span><span class="boring"> default := 0
</span><span class="boring">opaque default [Inhabited a] : a :=
</span><span class="boring"> Inhabited.default
</span>instance [Inhabited a] [Inhabited b] : Inhabited (a × b) where
  default := (default, default)

#eval (default : Nat × Bool)
-- (0, true)
<span class="boring">end Ex
</span></code></pre>
<p>同様に、適切な定数関数の存在により、型 <code>b</code> が有項なら関数型 <code>a → b</code> も有項であることを示すことができる:</p>
<pre><code class="language-lean">instance [Inhabited b] : Inhabited (a → b) where
  default := fun _ =&gt; default
</code></pre>
<p>練習として、<code>List</code> 型や <code>Sum</code> 型などの他の型のデフォルトインスタンスを定義してみよう。</p>
<p>Leanの標準ライブラリには <code>inferInstance</code> という定義がある。これは型 <code>{α : Sort u} → [i : α] → α</code> を持ち、期待される型がインスタンスを持つときに型クラス解決手続きを実行させるのに便利である。</p>
<pre><code class="language-lean">#check (inferInstance : Inhabited Nat) -- Inhabited Nat

def foo : Inhabited (Nat × Nat) :=
  inferInstance

#eval foo.default  -- (0, 0)

theorem ex : foo.default = (default, default) :=
  rfl
</code></pre>
<p><code>#print</code> コマンドを使うと、<code>inferInstance</code> がいかにシンプルかを見ることができる。</p>
<pre><code class="language-lean">#print inferInstance
</code></pre>
<h2 id="tostring-tostring-型クラス"><a class="header" href="#tostring-tostring-型クラス">ToString (<code>ToString</code> 型クラス)</a></h2>
<p><code>ToString</code> 型クラスの多相メソッド <code>toString</code> は型 <code>{α : Type u} → [ToString α] → α → String</code> を持つ。ユーザー定義の型 <code>Foo</code> に対して型 <code>ToString Foo</code> のインスタンスを宣言すると、連鎖を利用して複雑な値を文字列に変換することができる。Leanでは、ほとんどのビルトイン型 <code>α</code> について <code>ToString α</code> のインスタンスが付属している。</p>
<pre><code class="language-lean">structure Person where
  name : String
  age  : Nat

instance : ToString Person where
  toString p := p.name ++ &quot;@&quot; ++ toString p.age

#eval toString { name := &quot;Leo&quot;, age := 542 : Person }
#eval toString ({ name := &quot;Daniel&quot;, age := 18 : Person }, &quot;hello&quot;)  -- `instToStringProd` と `instToStringPerson` の連鎖

</code></pre>
<h2 id="numerals-数字"><a class="header" href="#numerals-数字">Numerals (数字)</a></h2>
<p>Leanでは数字は多相である。型クラス <code>OfNat</code> に関するインスタンスを持つ任意の型の項を表すために、数字(例えば <code>2</code>)を使うことができる。</p>
<pre><code class="language-lean">structure Rational where
  num : Int
  den : Nat
  inv : den ≠ 0

instance instOfNatRational (n : Nat) : OfNat Rational n where
  ofNat := { num := n, den := 1, inv := by decide }

instance : ToString Rational where
  toString r := s!&quot;{r.num}/{r.den}&quot;

#eval (2 : Rational) -- 2/1

#check (2 : Rational) -- Rational
#check (2 : Nat)      -- Nat

#check @OfNat.ofNat Nat 2 (instOfNatNat 2)  -- Nat
#check @OfNat.ofNat Rational 2 (instOfNatRational 2)  -- Rational
</code></pre>
<p>Leanのelaboratorは、項 <code>(2 : Nat)</code> と <code>(2 : Rational)</code> をそれぞれ <code>@OfNat.ofNat Nat 2 (instOfNatNat 2)</code> と <code>@OfNat.ofNat Rational 2 (instOfNatRational 2)</code> に変換する。変換後の項中に出現する数字 <code>2</code> は「生の」自然数と呼ばれる。マクロ <code>nat_lit 2</code> を使うと生の自然数 <code>2</code> を入力することができる。</p>
<pre><code class="language-lean">#check nat_lit 2  -- Nat
</code></pre>
<p>生の自然数は多相では<strong>ない</strong>。</p>
<p><code>OfNat</code> インスタンスは生の自然数を引数に取る。そのため、特定の数字に対して <code>OfNat</code> のインスタンスを定義することができる。<code>OfNat</code> 型クラスの2番目の引数は、上の例のように変数であることが多いが、生の自然数の場合もある。</p>
<pre><code class="language-lean">class Monoid (α : Type u) where
  unit : α
  op   : α → α → α

instance [s : Monoid α] : OfNat α (nat_lit 1) where
  ofNat := s.unit

def getUnit [Monoid α] : α :=
  1
</code></pre>
<h2 id="output-parameters-出力パラメータ"><a class="header" href="#output-parameters-出力パラメータ">Output Parameters (出力パラメータ)</a></h2>
<p>デフォルトでは、Leanは型 <code>T</code> のデフォルト項が既知であり、<code>T</code> が欠落部分を含まない場合にのみ、<code>Inhabited T</code> のインスタンスを合成しようとする。次のコマンドは、型が欠落部分(つまり <code>_</code>)を含むため、&quot;failed to create type class instance for Inhabited (Nat × ?m.1499)&quot; というエラーを生成する。</p>
<pre><code class="language-lean">#check_failure (inferInstance : Inhabited (Nat × _))
</code></pre>
<p><code>Inhabited</code> 型クラスのパラメータは、<code>Inhabited</code> 型クラスのコンストラクタの「入力」の型とみなすことができる。型クラスが複数のパラメータを持つ場合、そのうちのいくつかを出力パラメータ(型クラスのインスタンス合成時に、既に与えられた型から推論される型)としてマークすることができる。出力パラメータの推論のために使われる型は入力パラメータと呼ばれる。出力パラメータに欠落部分があっても、Leanは型クラスのインスタンス合成を開始する。以下の例では、出力パラメータを使って<em>heterogeneous</em>(異種)多相乗法を定義している。</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span>class HMul (α : Type u) (β : Type v) (γ : outParam (Type w)) where
  hMul : α → β → γ

export HMul (hMul)

instance : HMul Nat Nat Nat where
  hMul := Nat.mul

instance : HMul Nat (Array Nat) (Array Nat) where
  hMul a bs := bs.map (fun b =&gt; hMul a b)

#eval hMul 4 3           -- 12
#eval hMul 4 #[2, 3, 4]  -- #[8, 12, 16]
<span class="boring">end Ex
</span></code></pre>
<p>パラメータ <code>α</code> と <code>β</code> は入力パラメータ、<code>γ</code> は出力パラメータとみなされる。関数適用 <code>hMul a b</code> が与えられると、<code>a</code> と <code>b</code> の型が分かっているなら型クラスインスタンス合成器が呼び出され、型クラスインスタンス合成器は <code>hMul a b</code> の出力の型情報を(入力パラメータ <code>α</code> と <code>β</code> から推論された)出力パラメータ <code>γ</code> から得る。上の例では、2つのインスタンスを定義した。最初のインスタンスは自然数上の同種乗法である。2つ目のインスタンスは配列のスカラー倍である。2つ目のインスタンスの定義では、インスタンスの連鎖が使われていることに注意してほしい。</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span>class HMul (α : Type u) (β : Type v) (γ : outParam (Type w)) where
  hMul : α → β → γ

export HMul (hMul)

instance : HMul Nat Nat Nat where
  hMul := Nat.mul

instance : HMul Int Int Int where
  hMul := Int.mul

instance [HMul α β γ] : HMul α (Array β) (Array γ) where
  hMul a bs := bs.map (fun b =&gt; hMul a b)

#eval hMul 4 3                    -- 12
#eval hMul 4 #[2, 3, 4]           -- #[8, 12, 16]
#eval hMul (-2) #[3, -1, 4]       -- #[-6, 2, -8]
#eval hMul 2 #[#[2, 3], #[0, 4]]  -- #[#[4, 6], #[0, 8]]
<span class="boring">end Ex
</span></code></pre>
<p>この新しい配列スカラー倍インスタンスは、<code>HMul α β γ</code> のインスタンスがあれば、いつでも <code>Array β</code> 型の配列と <code>α</code> 型のスカラーに対して使用することができる。最後の <code>#eval</code> では、<code>HMul Nat Nat Nat</code> のインスタンスから <code>HMul Nat (Array Nat) (Array Nat)</code> のインスタンスが合成され、<code>HMul Nat (Array Nat) (Array Nat)</code> のインスタンスから <code>HMul Nat (Array (Array Nat)) (Array (Array Nat))</code> のインスタンスが合成されていることに注意してほしい。</p>
<h2 id="default-instances-デフォルトインスタンス"><a class="header" href="#default-instances-デフォルトインスタンス">Default Instances (デフォルトインスタンス)</a></h2>
<p>型クラス <code>HMul</code> では、パラメータ <code>α</code> と <code>β</code> は入力パラメータとして扱われる。したがって、型クラスインスタンス合成はこれら2つの型が特定されてから開始される。場合によっては、この制約は強すぎるかもしれない。</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span>class HMul (α : Type u) (β : Type v) (γ : outParam (Type w)) where
  hMul : α → β → γ

export HMul (hMul)

instance : HMul Int Int Int where
  hMul := Int.mul

def xs : List Int := [1, 2, 3]

-- Error &quot;typeclass instance problem is stuck, it is often due to metavariables HMul ?m.89 ?m.90 ?m.91&quot;
-- `y` の型を明示的に与えればエラーは消える
#check_failure fun y =&gt; xs.map (fun x =&gt; hMul x y)
<span class="boring">end Ex
</span></code></pre>
<p><code>y</code> の型が与えられていないため、<code>HMul</code> のインスタンスはLeanによって合成されない。しかし、このような状況では <code>y</code> と <code>x</code> の型は同じはずだと考えるのが自然である。<em>default instances</em>(デフォルトインスタンス)を使えば、まさにそれを実現できる。</p>
<pre><code class="language-lean">namespace Ex
class HMul (α : Type u) (β : Type v) (γ : outParam (Type w)) where
  hMul : α → β → γ

export HMul (hMul)

@[default_instance]
instance : HMul Int Int Int where
  hMul := Int.mul

def xs : List Int := [1, 2, 3]

#check fun y =&gt; xs.map (fun x =&gt; hMul x y)    -- Int → List Int
#eval (fun y =&gt; xs.map (fun x =&gt; hMul x y)) 3 -- [3, 6, 9]
end Ex
</code></pre>
<p>上記のインスタンスに <code>default_instance</code> 属性を付けることで、保留中の型クラスインスタンス合成問題においてこのインスタンスを使用するようLeanに指示することができる。実際のLeanの実装では、各算術演算子について同種型クラス(<code>Add</code> など)と異種型クラス(<code>HAdd</code> など)が定義されている。さらに言うと、<code>a+b</code>、<code>a*b</code>、<code>a-b</code>、<code>a/b</code>、<code>a%b</code> は異種版演算子を表す。<code>OfNat Nat n</code> のインスタンスは <code>OfNat</code> 型クラスのデフォルトインスタンス(優先度100)である。これが、期待される型が不明な場合に、数字 <code>2</code> が <code>Nat</code> 型を持つ理由である。より高い優先度を持つデフォルトインスタンスを定義することで、ビルトインのデフォルトインスタンスをオーバーライドすることができる。</p>
<pre><code class="language-lean">structure Rational where
  num : Int
  den : Nat
  inv : den ≠ 0

@[default_instance 200]
instance : OfNat Rational n where
  ofNat := { num := n, den := 1, inv := by decide }

instance : ToString Rational where
  toString r := s!&quot;{r.num}/{r.den}&quot;

#check 2 -- Rational
</code></pre>
<p>優先度は、異なるデフォルトインスタンス間の相互作用を制御するのにも便利である。例えば、<code>xs</code> が <code>List α</code> 型を持つとする。elaboratorが式 <code>xs.map (fun x =&gt; 2 * x)</code> を解釈するとき、この式が多相性を持つために、同種乗法のデフォルトインスタンスが <code>OfNat</code> のデフォルトインスタンスより高い優先度を持つようにしたい。これは、<code>HMul α α α</code> のインスタンスを実装し、<code>HMul Nat α α</code> のインスタンスは実装しなかった場合に特に重要である。ここで、Leanにおいて表記 <code>a*b</code> がどう定義されているかを種明かしする。</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span>class OfNat (α : Type u) (n : Nat) where
  ofNat : α

@[default_instance]
instance (n : Nat) : OfNat Nat n where
  ofNat := n

class HMul (α : Type u) (β : Type v) (γ : outParam (Type w)) where
  hMul : α → β → γ

class Mul (α : Type u) where
  mul : α → α → α

@[default_instance 10]
instance [Mul α] : HMul α α α where
  hMul a b := Mul.mul a b

infixl:70 &quot; * &quot; =&gt; HMul.hMul
<span class="boring">end Ex
</span></code></pre>
<p><code>Mul</code> 型クラスは、同種乗法は実装されているが異種乗法は実装されていない型を扱う際に便利である。</p>
<h2 id="local-instances-ローカルインスタンス"><a class="header" href="#local-instances-ローカルインスタンス">Local Instances (ローカルインスタンス)</a></h2>
<p>Leanにおいて、型クラスのインスタンスは属性を用いて実装される。そのため、<code>local</code> 修飾子を使うことで、そのインスタンスが現在のセクションや名前空間が閉じられるまで、あるいは現在のファイルの終わりまでしか効果がないことを示すことができる。</p>
<pre><code class="language-lean">structure Point where
  x : Nat
  y : Nat

section

local instance : Add Point where
  add a b := { x := a.x + b.x, y := a.y + b.y }

def double (p : Point) :=
  p + p

end -- もうインスタンス `Add Point` は使えない

-- def triple (p : Point) :=
--  p + p + p  -- Error: failed to synthesize instance
</code></pre>
<p>コマンド <code>attribute [-instance]</code> を使えば、現在のセクションや名前空間が閉じられるまで、あるいは現在のファイルの終わりまで、指定したインスタンスを一時的に無効化することもできる。</p>
<pre><code class="language-lean">structure Point where
  x : Nat
  y : Nat

instance addPoint : Add Point where
  add a b := { x := a.x + b.x, y := a.y + b.y }

def double (p : Point) :=
  p + p

attribute [-instance] addPoint

-- def triple (p : Point) :=
--  p + p + p  -- Error: failed to synthesize instance
</code></pre>
<p>コマンド <code>attribute [-instance]</code> は問題の分析時にのみ使うことを勧める。</p>
<h2 id="scoped-instances-スコープ付きインスタンス"><a class="header" href="#scoped-instances-スコープ付きインスタンス">Scoped Instances (スコープ付きインスタンス)</a></h2>
<p><code>scoped instance</code> を用いてスコープ付きのインスタンスを宣言することもできる。スコープ付きインスタンスは、名前空間の中にいるとき、または名前空間を開いているときのみ使用可能である。</p>
<pre><code class="language-lean">structure Point where
  x : Nat
  y : Nat

namespace Point

scoped instance : Add Point where
  add a b := { x := a.x + b.x, y := a.y + b.y }

def double (p : Point) :=
  p + p

end Point
-- インスタンス `Add Point` はもう使えない

-- #check fun (p : Point) =&gt; p + p + p  -- Error

namespace Point
-- インスタンス `Add Point` は再び利用可能になった
#check fun (p : Point) =&gt; p + p + p

end Point

open Point -- 名前空間を開き、インスタンス `Add Point` を利用可能にする
#check fun (p : Point) =&gt; p + p + p
</code></pre>
<p>コマンド <code>open scoped &lt;namespace&gt;</code> を使うと、名前空間 <code>&lt;namespace&gt;</code> 内の <code>scoped</code> 属性のついた定義が利用可能になるが、名前空間 <code>&lt;namespace&gt;</code> 内のそれ以外の定義に短い別名でアクセスすることはできない。</p>
<pre><code class="language-lean">structure Point where
  x : Nat
  y : Nat

namespace Point

scoped instance : Add Point where
  add a b := { x := a.x + b.x, y := a.y + b.y }

def double (p : Point) :=
  p + p

end Point

open scoped Point -- インスタンス `Add Point` を利用可能にする
#check fun (p : Point) =&gt; p + p + p

-- #check fun (p : Point) =&gt; double p -- Error: unknown identifier 'double'
</code></pre>
<h2 id="decidable-propositions-決定可能命題"><a class="header" href="#decidable-propositions-決定可能命題">Decidable Propositions (決定可能命題)</a></h2>
<p>標準ライブラリで定義されている、命題に関する型クラス <code>Decidable</code> について考えてみよう。大雑把に言えば、<code>Prop</code> 型の項(具体的な命題)は、それが真か偽かを決めることができる場合、決定可能であると言われる。古典論理において全ての命題は決定可能であるため、命題が決定可能かどうかという区別は構成的論理においてのみ有用である。古典論理を使っているかどうかの区別は重要である。古典論理を使って、例えば場合分けによって関数を定義すると、その関数は計算不能になる。</p>
<pre><code class="language-lean">variable (p : Nat → Prop)

-- error : failed to synthesize instance
--   Decidable (p n)
/-
def bad_foo : Nat → Bool :=
  fun (n : Nat) =&gt;
  if p n then true
  else false
-/

open Classical

noncomputable def foo : Nat → Bool :=
  fun (n : Nat) =&gt;
  if p n then true
  else false

#print axioms foo
-- 'foo' depends on axioms: [Classical.choice, Quot.sound, propext]
</code></pre>
<p>アルゴリズム的に言えば、<code>Decidable</code> 型クラスは、その命題が真か偽かを効果的に決定する手続きを推論するために使うことができる。結果として、この型クラスはある定義が計算可能なときその定義をサポートすると同時に、古典論理を使った定義や推論の使用へのスムーズな移行を可能にする。</p>
<p>標準ライブラリでは、<code>Decidable</code> は次のように形式的に定義されている:</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>class inductive Decidable (p : Prop) where
  | isFalse (h : ¬p) : Decidable p
  | isTrue  (h : p)  : Decidable p
<span class="boring">end Hidden
</span></code></pre>
<p>論理的に言えば、項 <code>t : Decidable p</code> を持つことは、証明項 <code>t : p ∨ ¬p</code> を持つことよりも強い。項 <code>t : Decidable p</code> の存在は、<code>p</code> の真理値に依存して任意の型の値や関数を定義することを可能にする。例えば、<code>if p then a else b</code> という式が意味をなすには、<code>p</code> が決定可能であることを知っている必要がある。ここで <code>if p then a else b</code> は <code>ite p a b</code> の糖衣構文である。<code>ite</code> は次のように定義される:</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>def ite {α : Sort u} (c : Prop) [h : Decidable c] (t e : α) : α :=
  Decidable.casesOn (motive := fun _ =&gt; α) h (fun _ =&gt; e) (fun _ =&gt; t)
<span class="boring">end Hidden
</span></code></pre>
<p>標準ライブラリは <code>dite</code> と呼ばれる <code>ite</code> の変形版を持っている。<code>dite</code> は依存版if-then-else式である。これは次のように定義される:</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>def dite {α : Sort u} (c : Prop) [h : Decidable c] (t : c → α) (e : Not c → α) : α :=
  Decidable.casesOn (motive := fun _ =&gt; α) h e t
<span class="boring">end Hidden
</span></code></pre>
<p>つまり、<code>dite c t e</code> において、「then」分岐では <code>hc : c</code> を、「else」分岐では <code>hnc : ¬ c</code> を仮定できる。Leanでは、<code>dite</code> をより使いやすくするために、<code>dite c (λ h : c =&gt; t) (λ h : ¬ c =&gt; e)</code> の代わりに <code>if h : c then t else e</code> と書くことができる。</p>
<p>古典論理がなければ、全ての命題が決定可能であることを証明することはできない。しかし、<strong>ある</strong>命題が決定可能であることは証明できる。例えば、自然数や整数に関する等式や不等式のような基本関係の決定可能性は古典論理なしで証明できる。さらに、決定可能性は命題結合子の適用前後で保存される:</p>
<pre><code class="language-lean">#check @instDecidableAnd
  -- {p q : Prop} → [Decidable p] → [Decidable q] → Decidable (And p q)

#check @instDecidableOr
#check @instDecidableNot
</code></pre>
<p>したがって、自然数上の決定可能述語を用いた場合分けによって関数を定義することができる:</p>
<pre><code class="language-lean">def step (a b x : Nat) : Nat :=
  if x &lt; a ∨ x &gt; b then 0 else 1

set_option pp.explicit true  -- 暗黙の引数を表示する
#print step
</code></pre>
<p>暗黙の引数の表示をオンにすると、elaboratorは適切なインスタンス <code>instDecidableOr</code> と <code>Nat.decLt</code> を適用しただけで、命題 <code>x &lt; a ∨ x &gt; b</code> の決定可能性を推論したことがわかる。</p>
<p>古典論理の公理を使うと、全ての命題が決定可能であることが証明できる。<code>Classical</code> 名前空間を開くと、古典論理の公理がインポートされ、全ての命題 <code>p</code> に対して <code>Decidable p</code> のインスタンスが利用できるようになる。</p>
<pre><code class="language-lean">open Classical
</code></pre>
<p>したがって、古典論理的に推論したい場合、決定可能性を前提とするライブラリ内の定理は、全て自由に利用できる。<a href="./axioms_and_computation.html">12章 Axioms and Computation (公理と計算)</a>では、排中律を使って関数を定義すると、その関数が計算に使われなくなることがあることを説明する。したがって、標準ライブラリでは <code>Classical.propDecidable</code> インスタンスに低い優先度を割り当てている。</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>open Classical
noncomputable scoped
instance (priority := low) propDecidable (a : Prop) : Decidable a :=
  choice &lt;| match em a with
    | Or.inl h =&gt; ⟨isTrue h⟩
    | Or.inr h =&gt; ⟨isFalse h⟩
<span class="boring">end Hidden
</span></code></pre>
<p>これは、<code>Decidable p</code> の型クラス解決において、Leanが他のインスタンスを優先し、他の試みが全て失敗した後にのみインスタンス <code>propDecidable p</code> を使うことを保証する。</p>
<p><code>Decidable</code> 型クラスは、定理証明の小規模な自動化もいくつか提供している。標準ライブラリには、<code>Decidable</code> のインスタンスを使って単純なゴールを解くタクティク <code>decide</code> が含まれている。</p>
<pre><code class="language-lean">example : 10 &lt; 5 ∨ 1 &gt; 0 := by
  decide

example : ¬ (True ∧ False) := by
  decide

example : 10 * 20 = 200 := by
  decide

theorem ex : True ∧ 2 = 1+1 := by
  decide

#print ex
-- theorem ex : True ∧ 2 = 1 + 1 :=
-- of_decide_eq_true (Eq.refl true)

#check @of_decide_eq_true
-- ∀ {p : Prop} [Decidable p], decide p = true → p

#check @decide
-- (p : Prop) → [Decidable p] → Bool
</code></pre>
<p>これらは次のように動作する。式 <code>decide p</code> は <code>p</code> の決定可能性を用いて <code>p</code> の真偽決定手続きの推論を試み、成功すれば <code>decide p</code> は <code>true</code> か <code>false</code> のどちらかに評価される。特に、<code>p</code> が正しい閉論理式である場合、<code>decide p</code> はdefinitionallyにブール値 <code>true</code> に簡約される。<code>decide p = true</code> が成立するという前提を受け取ると、<code>of_decide_eq_true</code> は <code>p</code> の証明を出力する。ターゲット <code>p</code> を証明するために以上の過程をまとめたものが <code>decide</code> タクティクである。前述した内容により、<code>decide</code> は、推論された <code>c</code> の真偽決定手続きが、<code>c</code> が <code>isTrue</code> の場合であることをdefinitionallyに評価するために十分な情報を持っていれば、いつでも成功する。</p>
<h2 id="managing-type-class-inference-型クラス推論の管理"><a class="header" href="#managing-type-class-inference-型クラス推論の管理">Managing Type Class Inference (型クラス推論の管理)</a></h2>
<p>Leanの型クラス推論によって合成できる式 <code>t</code> を提供する必要があるとき、<code>inferInstance</code> を使うと <code>t</code> を推論によって合成するようLeanに依頼することができる:</p>
<pre><code class="language-lean">def foo : Add Nat := inferInstance
def bar : Inhabited (Nat → Nat) := inferInstance

#check @inferInstance
-- {α : Sort u} → [α] → α
</code></pre>
<p>Leanの <code>(t : T)</code> 記法を使えば、今探している <code>t</code> がどの型クラス <code>T</code> のインスタンスなのかを簡潔に指定することができる:</p>
<pre><code class="language-lean">#check (inferInstance : Add Nat)
</code></pre>
<p>型 <code>T</code> を引数に取る補助定義 <code>inferInstanceAs</code> を使うこともできる:</p>
<pre><code class="language-lean">#check inferInstanceAs (Add Nat)

#check @inferInstanceAs
-- (α : Sort u) → [α] → α
</code></pre>
<p>型クラスが定義の下に埋もれているために、Leanがインスタンスを見つけられないことがある。例えば、単に <code>inferInstance</code> を使うだけで <code>Inhabited (Set α)</code> のインスタンスを見つけることはできない。この場合、定義を使って <code>Set α</code> を <code>α → Prop</code> に書き下し、それを明示的に与えればよい:</p>
<pre><code class="language-lean">def Set (α : Type u) := α → Prop

-- fails
-- example : Inhabited (Set α) :=
--  inferInstance

instance : Inhabited (Set α) :=
  inferInstanceAs (Inhabited (α → Prop))

-- 別解
example : Inhabited (Set α) :=
  @inferInstance (Inhabited (α → Prop)) _
</code></pre>
<p>時には、型クラス推論が期待されるインスタンスを見つけることに失敗したり、最悪の場合、無限ループに陥ってタイムアウトすることがある。このような状況でのデバッグを手伝ってもらうために、Leanにインスタンス探索の追跡を依頼することができる:</p>
<pre><code class="language-lean">set_option trace.Meta.synthInstance true
</code></pre>
<p>VSCodeを使用している場合は、関連する定理や定義にカーソルを合わせるか、<code>Ctrl-Shift-Enter</code> によりメッセージウィンドウを開くことで、追跡結果を読むことができる。Emacsでは、<code>C-c C-x</code> によりファイルと独立したLeanプロセスを実行することができる。その後、出力バッファには型クラス解決手順が起きるたびに追跡内容が表示される。</p>
<p>次のオプションを使ってインスタンス探索を制限することもできる:</p>
<pre><code class="language-lean">set_option synthInstance.maxHeartbeats 10000
set_option synthInstance.maxSize 400
</code></pre>
<p><code>synthInstance.maxHeartbeats</code> オプションは、型クラス解決問題ごとのheartbeatsの最大量を指定する。heartbeatsとは(小さな)メモリ割り当ての数(1000単位)であり、<code>synthInstance.maxHeartbeats 0</code> は制限がないことを意味する。<code>synthInstance.maxSize</code> オプションは、型クラスインスタンス合成過程で解を構築するために使われるインスタンスの最大数を指定する。</p>
<p>VSCodeでもEmacsでも、<code>set_option</code> の中でタブ補完が機能することを覚えてほしい。タブ補完は適切なオプションを探すのに役立つ。</p>
<p>上述したように、与えられたコンテキストでの型クラスインスタンス合成はProlog-likeなプログラムであり、これはバックトラック探索を生じさせる。プログラムの効率も発見される解も、システムがインスタンスを探索する順番に依存して変化する。探索においては、最後に宣言されたインスタンスから順番に探索される。さらに、インスタンスが他のモジュール(ファイル)で宣言されている場合、インスタンスが探索される順番は名前空間を開いた順番に依存する。後に開いた名前空間で宣言されたインスタンスほど先に探索される。</p>
<p>型クラスのインスタンスに「優先度」を割り当てることで、探索される順番を変更することができる。普通にインスタンスが宣言されると、そのインスタンスにはデフォルトの優先度が割り当てられる。インスタンスを定義するとき、デフォルト以外の優先度を割り当てることができる。次の例はその方法を示している:</p>
<pre><code class="language-lean">class Foo where
  a : Nat
  b : Nat

instance (priority := default+1) i1 : Foo where
  a := 1
  b := 1

instance i2 : Foo where
  a := 2
  b := 2

example : Foo.a = 1 :=
  rfl

instance (priority := default+2) i3 : Foo where
  a := 3
  b := 3

example : Foo.a = 3 :=
  rfl
</code></pre>
<h2 id="coercions-using-type-classes-型クラスを用いた強制"><a class="header" href="#coercions-using-type-classes-型クラスを用いた強制">Coercions using Type Classes (型クラスを用いた強制)</a></h2>
<p>最も基本的なタイプの(型)強制は、ある型の項を別の型の項にマッピングする。例えば、<code>Nat</code> 型から <code>Int</code> 型への強制は、任意の項 <code>n : Nat</code> を <code>Int</code> の項とみなすことを可能にする。しかし、いくつかの強制はより複雑で、パラメータに依存する。例えば、任意の型 <code>α</code> に対して、任意の項 <code>as : List α</code> を <code>Set α</code> の項、つまりリストに出現する <code>α</code> の項全体からなる集合とみなすことが可能である。これに対応する強制は、<code>α</code> によってパラメータ化された型の「族」<code>List α</code> 上で定義される。</p>
<p>Leanでは3種類の強制を宣言することができる:</p>
<ul>
<li>ある型の族から他の型の族への強制</li>
<li>ある型の族からSortのクラスへの強制</li>
<li>ある型の族から関数型のクラスへの強制</li>
</ul>
<p>1種類目の強制は、強制元の族に属する型の任意の「項」を、強制先の族に属する対応する型の「項」として見ることを可能にする。2種類目の強制は、強制元の族に属する型の任意の「項」を「型」として見ることを可能にする。3種類目の強制は、強制元の族に属する型の任意の「項」を「関数」として見ることを可能にする。それぞれを順番に考えてみよう:</p>
<pre><code class="language-lean">instance : Coe Bool Prop where
  coe b := b = true
</code></pre>
<p>この強制により、if-then-else式の条件の中でブール型の項を使うことができる:</p>
<pre><code class="language-lean">#eval if true then 5 else 3
#eval if false then 5 else 3
</code></pre>
<p><code>List α</code> から <code>Set α</code> への強制は次のように定義される:</p>
<pre><code class="language-lean"><span class="boring">def Set (α : Type u) := α → Prop
</span><span class="boring">def Set.empty {α : Type u} : Set α := fun _ =&gt; False
</span><span class="boring">def Set.mem (a : α) (s : Set α) : Prop := s a
</span><span class="boring">def Set.singleton (a : α) : Set α := fun x =&gt; x = a
</span><span class="boring">def Set.union (a b : Set α) : Set α := fun x =&gt; a x ∨ b x
</span><span class="boring">notation &quot;{ &quot; a &quot; }&quot; =&gt; Set.singleton a
</span><span class="boring">infix:55 &quot; ∪ &quot; =&gt; Set.union
</span>def List.toSet : List α → Set α
  | []    =&gt; Set.empty
  | a::as =&gt; {a} ∪ as.toSet

instance : Coe (List α) (Set α) where
  coe a := a.toSet

def s : Set Nat := {1}
#check s ∪ [2, 3]
-- s ∪ List.toSet [2, 3] : Set Nat
</code></pre>
<p>特定の場所に明示的に強制を導入するために、<code>↑</code> という記法を使うことができる。この記法は書き手の意図を明確にすることや、強制解決システムの制限を回避することにも役立つ。</p>
<pre><code class="language-lean"><span class="boring">def Set (α : Type u) := α → Prop
</span><span class="boring">def Set.empty {α : Type u} : Set α := fun _ =&gt; False
</span><span class="boring">def Set.mem (a : α) (s : Set α) : Prop := s a
</span><span class="boring">def Set.singleton (a : α) : Set α := fun x =&gt; x = a
</span><span class="boring">def Set.union (a b : Set α) : Set α := fun x =&gt; a x ∨ b x
</span><span class="boring">notation &quot;{ &quot; a &quot; }&quot; =&gt; Set.singleton a
</span><span class="boring">infix:55 &quot; ∪ &quot; =&gt; Set.union
</span><span class="boring">def List.toSet : List α → Set α
</span><span class="boring">  | []    =&gt; Set.empty
</span><span class="boring">  | a::as =&gt; {a} ∪ as.toSet
</span><span class="boring">instance : Coe (List α) (Set α) where
</span><span class="boring">  coe a := a.toSet
</span>def s : Set Nat := {1}

#check let x := ↑[2, 3]; s ∪ x
-- let x := List.toSet [2, 3]; s ∪ x : Set Nat
#check let x := [2, 3]; s ∪ x
-- let x := [2, 3]; s ∪ List.toSet x : Set Nat
</code></pre>
<p>Leanは <code>CoeDep</code> 型クラスを使った依存強制もサポートしている。例えば、<code>Prop</code> 型の任意の項 <code>p</code> をBool型の項に強制することはできないが、<code>Decidable p</code> 型クラスがインスタンスを持つような <code>p</code> だけはBool型の項に強制できる。</p>
<pre><code class="language-lean">instance (p : Prop) [Decidable p] : CoeDep Prop p Bool where
  coe := decide p
</code></pre>
<p>Leanは必要に応じて(非依存)強制を連鎖させる。実際、型クラス <code>CoeT</code> は <code>Coe</code> の推移的閉包である。</p>
<p>次に、2種類目の強制について考えよう。「Sortのクラス」とは、宇宙 <code>Type u</code> の集まりを意味する。2種類目の強制は次のような形をとる:</p>
<pre><code>    c : (x1 : A1) → ... → (xn : An) → F x1 ... xn → Type u
</code></pre>
<p>ここで、<code>F</code> は型の族であり、<code>F x1 ... xn</code> は型の族に属する特定の型である。この種類の強制により、<code>t</code> が型 <code>F a1 ... an</code> の項であるときは、いつでも <code>s : t</code> と書くことができる。言い換えれば、この強制は <code>F a1 ... an</code> の項を型として見ることを可能にする。これは、構造体の1つの要素、つまり構造の台(集合) <code>carrier</code> が型であるような代数的構造を定義するときに非常に便利である。例えば、<em>semigroup</em>(半群)は次のように定義できる:</p>
<pre><code class="language-lean">structure Semigroup where
  carrier : Type u
  mul : carrier → carrier → carrier
  mul_assoc (a b c : carrier) : mul (mul a b) c = mul a (mul b c)

instance (S : Semigroup) : Mul S.carrier where
  mul a b := S.mul a b
</code></pre>
<p>つまり、半群は型 <code>carrier</code>、乗法 <code>mul</code>、「乗法は結合的である」という性質の3要素からなる。上記の <code>instance</code> コマンドは、<code>a b : S.carrier</code> があるとき、<code>Semigroup.mul S a b</code> を <code>a * b</code> と略記することを可能にする。Leanは <code>a</code> と <code>b</code> の型からインスタンスの引数 <code>S</code> を推測できることに注意してほしい。関数 <code>Semigroup.carrier</code> はクラス <code>Semigroup</code> の項(半群)を <code>Type u</code> の項(型)にマッピングする:</p>
<pre><code class="language-lean"><span class="boring">structure Semigroup where
</span><span class="boring">  carrier : Type u
</span><span class="boring">  mul : carrier → carrier → carrier
</span><span class="boring">  mul_assoc (a b c : carrier) : mul (mul a b) c = mul a (mul b c)
</span><span class="boring">instance (S : Semigroup) : Mul S.carrier where
</span><span class="boring">  mul a b := S.mul a b
</span>#check Semigroup.carrier
</code></pre>
<p>この関数は強制であると宣言すれば、半群 <code>S : Semigroup</code> があるときはいつでも、<code>a : S.carrier</code> を <code>a : S</code> と略記することができる:</p>
<pre><code class="language-lean"><span class="boring">structure Semigroup where
</span><span class="boring">  carrier : Type u
</span><span class="boring">  mul : carrier → carrier → carrier
</span><span class="boring">  mul_assoc (a b c : carrier) : mul (mul a b) c = mul a (mul b c)
</span><span class="boring">instance (S : Semigroup) : Mul S.carrier where
</span><span class="boring">  mul a b := S.mul a b
</span>instance : CoeSort Semigroup (Type u) where
  coe s := s.carrier

example (S : Semigroup) (a b c : S) : (a * b) * c = a * (b * c) :=
  Semigroup.mul_assoc _ a b c
</code></pre>
<p>上記の <code>CoeSort Semigroup (Type u)</code> のインスタンスは、<code>(a b c : S)</code> と書くことを可能にする強制である。ここで、2種類目の強制では <code>Coe Semigroup (Type u)</code> ではなく <code>CoeSort Semigroup (Type u)</code> のインスタンスを定義したことに注意してほしい。</p>
<p>最後に、3種類目の強制について考えよう。「関数型のクラス」とは、依存関数型(パイ型) <code>(z : B) → C</code> の集まりを意味する。3種類目の強制は次のような形をとる:</p>
<pre><code>    c : (x1 : A1) → ... → (xn : An) → (y : F x1 ... xn) → (z : B) → C
</code></pre>
<p>ここで、<code>F</code> は再び型の族であり、<code>F x1 ... xn</code> は型の族に属する特定の型である。<code>B</code> と <code>C</code> は <code>x1, ..., xn, y</code> に依存することができる。この種類の強制により、<code>t</code> が <code>F a1 ... an</code> の項であるときは、いつでも <code>t s</code> と書くことができる。言い換えれば、この強制は <code>F a1 ... an</code> の項を関数として見ることを可能にする。上記の例の続きとして、半群 <code>S1</code> と <code>S2</code> の間の<em>morphism</em>(射)あるいは<em>homomorphism</em>(準同型)という概念を定義できる。射とは、<code>S1</code> の台から <code>S2</code> の台への、乗法を保存する(<code>mor (a * b) = (mor a) * (mor b)</code>)関数である。次のコードでは、<code>S1</code>、<code>S2</code>、<code>*</code> に関する暗黙の強制に注意してほしい。射影 <code>Morphism.mor</code> は、構造体 <code>Morphism S1 S2</code> の項を受け取り、射の台関数を返す:</p>
<pre><code class="language-lean"><span class="boring">structure Semigroup where
</span><span class="boring">  carrier : Type u
</span><span class="boring">  mul : carrier → carrier → carrier
</span><span class="boring">  mul_assoc (a b c : carrier) : mul (mul a b) c = mul a (mul b c)
</span><span class="boring">instance (S : Semigroup) : Mul S.carrier where
</span><span class="boring">  mul a b := S.mul a b
</span><span class="boring">instance : CoeSort Semigroup (Type u) where
</span><span class="boring">  coe s := s.carrier
</span>structure Morphism (S1 S2 : Semigroup) where
  mor : S1 → S2
  resp_mul : ∀ a b : S1, mor (a * b) = (mor a) * (mor b)

#check @Morphism.mor
</code></pre>
<p>以下のコードにより、半群間の射は3種類目の強制 <code>CoeFun</code> の代表例となった。</p>
<pre><code class="language-lean"><span class="boring">structure Semigroup where
</span><span class="boring">  carrier : Type u
</span><span class="boring">  mul : carrier → carrier → carrier
</span><span class="boring">  mul_assoc (a b c : carrier) : mul (mul a b) c = mul a (mul b c)
</span><span class="boring">instance (S : Semigroup) : Mul S.carrier where
</span><span class="boring">  mul a b := S.mul a b
</span><span class="boring">instance : CoeSort Semigroup (Type u) where
</span><span class="boring">  coe s := s.carrier
</span><span class="boring">structure Morphism (S1 S2 : Semigroup) where
</span><span class="boring">  mor : S1 → S2
</span><span class="boring">  resp_mul : ∀ a b : S1, mor (a * b) = (mor a) * (mor b)
</span>instance (S1 S2 : Semigroup) : CoeFun (Morphism S1 S2) (fun _ =&gt; S1 → S2) where
  coe m := m.mor

theorem resp_mul {S1 S2 : Semigroup} (f : Morphism S1 S2) (a b : S1)
        : f (a * b) = f a * f b :=
  f.resp_mul a b

example (S1 S2 : Semigroup) (f : Morphism S1 S2) (a : S1) :
      f (a * a * a) = f a * f a * f a :=
  calc f (a * a * a)
    _ = f (a * a) * f a := by rw [resp_mul f]
    _ = f a * f a * f a := by rw [resp_mul f]
</code></pre>
<p>この強制を使えば、<code>f.mor (a * a * a)</code> を <code>f (a * a * a)</code> と略記することができる。関数型が期待される場所で <code>Morphism</code> や <code>f</code> が使われると、Leanは強制を挿入する。フィールド <code>F</code> は強制先の関数型を指定するために使われる。<code>F</code> の型は強制元の型に依存しうる。</p>
<p>まとめると、1種類目の強制のために型クラス <code>Coe</code> があり、2種類目の強制のために型クラス <code>CoeSort</code> があり、3種類目の強制のために型クラス <code>CoeFun</code> がある。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-conversion-tactic-mode-変換タクティクモード"><a class="header" href="#the-conversion-tactic-mode-変換タクティクモード">The Conversion Tactic Mode (変換タクティクモード)</a></h1>
<p>タクティクブロックの内部では、<code>conv</code> キーワードを使うと<em>conversion mode</em>(変換モード)に入ることができる。このモードでは、仮説やターゲットの内部、さらには関数抽象や依存関数型の内部を移動して、その部分項に書き換えや単純化のステップを適用することができる。</p>
<h2 id="用語に関する注意-2"><a class="header" href="#用語に関する注意-2">用語に関する注意</a></h2>
<p>この節は翻訳に際して追加した節である。</p>
<p>変換モードにおいて、「ターゲット」とは項構築の目標となる型のこと<strong>ではなく</strong>、書き換え・単純化の対象のことである。また、「ゴール」は単に1つのターゲットを保持するためにある。</p>
<p>通常のタクティクモードでは、ターゲットは <code>⊢</code> の後に書かれる。一方で、変換タクティクモードでは、ターゲットは <code>|</code> の後に書かれる。</p>
<h2 id="basic-navigation-and-rewriting-基本的なナビゲーションと書き換え"><a class="header" href="#basic-navigation-and-rewriting-基本的なナビゲーションと書き換え">Basic navigation and rewriting (基本的なナビゲーションと書き換え)</a></h2>
<p>最初の例として、<code>example (a b c : Nat) : a * (b * c) = a * (c * b)</code> を証明してみよう(このページで挙げる例は、他のタクティクを使えばすぐに解ける可能性があるため、多少作為的である)。素朴な最初の一手は、タクティクモードに入って <code>rw [Nat.mul_comm]</code> を試すことである。しかし、そうするとターゲット内の一番最初に登場する乗法について可換性が適用され、ターゲットが <code>b * c * a = a * (c * b)</code> に変換されてしまう。この問題を解決する方法はいくつかあるが、より正確なツールである変換モードを使用することは解決法の1つである。次のコードブロックでは、タクティクブロック内の各行の後に現在のターゲットを示している。</p>
<pre><code class="language-lean">example (a b c : Nat) : a * (b * c) = a * (c * b) := by
  conv =&gt;
    -- ⊢ a * (b * c) = a * (c * b)
    lhs
    -- ⊢ a * (b * c)
    congr
    -- 2 goals: ⊢ a, ⊢ b * c
    rfl
    -- ⊢ b * c
    rw [Nat.mul_comm]
</code></pre>
<p>上記のスニペット(小さなコード)では次の3つのナビゲーションコマンドを使っている:</p>
<ul>
<li><code>lhs</code> は関係(ここでは等号)の左辺にターゲットを絞る。関係の右辺にターゲットを絞る <code>rhs</code> コマンドもある。</li>
<li>現在のターゲット内の先頭の関数(ここでは乗法)が(非依存的かつ明示的な)引数をとるなら、<code>congr</code> は先頭の関数を分解し、各引数をターゲットとするゴールを引数の数だけ生成する。</li>
<li><code>rfl</code> は現在のターゲットを反射性を使って閉じ、次のゴールに移る。</li>
</ul>
<p>目的のターゲットに到着したら、通常のタクティクモードと同様に <code>rw</code> を使うことができる。</p>
<p>変換モードを使う2つ目の主な理由は、束縛のスコープ内で部分項を書き換えることができるからである。例えば、<code>(fun x : Nat =&gt; 0 + x) = (fun x =&gt; x)</code> を証明したいとしよう。素朴な最初の一手は、タクティクモードに入って <code>rw [Nat.zero_add]</code> を試すことである。しかし、これは失敗し、次のようなエラーメッセージを見ていらいらするだろう。</p>
<pre><code>error: tactic 'rewrite' failed, did not find instance of the pattern
       in the target expression
  0 + ?n
⊢ (fun x =&gt; 0 + x) = fun x =&gt; x
</code></pre>
<p>正しい解法(の一例)はこうである:</p>
<pre><code class="language-lean">example : (fun x : Nat =&gt; 0 + x) = (fun x =&gt; x) := by
  conv =&gt;
    lhs
    intro x
    rw [Nat.zero_add]
</code></pre>
<p>ここで、<code>intro x</code> は <code>fun</code> の束縛スコープ内に入るナビゲーションコマンドである。この例は多少作為的であることを断っておく。この例は次のように解くこともできる:</p>
<pre><code class="language-lean">example : (fun x : Nat =&gt; 0 + x) = (fun x =&gt; x) := by
  funext x; rw [Nat.zero_add]
</code></pre>
<p>あるいは、<code>simp</code> を使うだけでよい。</p>
<pre><code class="language-lean">example : (fun x : Nat =&gt; 0 + x) = (fun x =&gt; x) := by
  simp
</code></pre>
<p><code>conv at h</code> を使うと、現在のコンテキスト内の仮説 <code>h</code> を書き換えることもできる。</p>
<h2 id="pattern-matching-パターンマッチング-1"><a class="header" href="#pattern-matching-パターンマッチング-1">Pattern matching (パターンマッチング)</a></h2>
<p>上記のコマンドを使ったナビゲーションは面倒だと思うかもしれない。パターンマッチングを使えば、次のようにショートカットできる:</p>
<pre><code class="language-lean">example (a b c : Nat) : a * (b * c) = a * (c * b) := by
  conv in b * c =&gt; rw [Nat.mul_comm]
</code></pre>
<p>これは次の糖衣構文である:</p>
<pre><code class="language-lean">example (a b c : Nat) : a * (b * c) = a * (c * b) := by
  conv =&gt;
    pattern b * c
    rw [Nat.mul_comm]
</code></pre>
<p>もちろん、ワイルドカードも使える:</p>
<pre><code class="language-lean">example (a b c : Nat) : a * (b * c) = a * (c * b) := by
  conv in _ * c =&gt; rw [Nat.mul_comm]
</code></pre>
<h2 id="structuring-conversion-tactics-変換タクティク証明の構造化"><a class="header" href="#structuring-conversion-tactics-変換タクティク証明の構造化">Structuring conversion tactics (変換タクティク証明の構造化)</a></h2>
<p><code>conv</code> モード中も、タクティク証明を構造化するために波括弧と <code>.</code> を使うことができる。</p>
<pre><code class="language-lean">example (a b c : Nat) : (0 + a) * (b * c) = a * (c * b) := by
  conv =&gt;
    lhs
    congr
    . rw [Nat.zero_add]
    . rw [Nat.mul_comm]
</code></pre>
<h2 id="other-tactics-inside-conversion-mode-変換モードにおける他のタクティク"><a class="header" href="#other-tactics-inside-conversion-mode-変換モードにおける他のタクティク">Other tactics inside conversion mode (変換モードにおける他のタクティク)</a></h2>
<ul>
<li><code>arg i</code> は現在のターゲットの <code>i</code> 番目の非依存的明示的引数にターゲットを絞る。</li>
</ul>
<pre><code class="language-lean">example (a b c : Nat) : a * (b * c) = a * (c * b) := by
  conv =&gt;
    -- ⊢ a * (b * c) = a * (c * b)
    lhs
    -- ⊢ a * (b * c)
    arg 2
    -- ⊢ b * c
    rw [Nat.mul_comm]
</code></pre>
<ul>
<li>
<p><code>args</code> は <code>congr</code> の別名である。</p>
</li>
<li>
<p><code>simp</code> は現在のターゲットに単純化子を適用する。<code>simp</code> は通常のタクティクモードと同様のオプションをサポートする。</p>
</li>
</ul>
<pre><code class="language-lean">def f (x : Nat) :=
  if x &gt; 0 then x + 1 else x + 2

example (g : Nat → Nat) (h₁ : g x = x + 1) (h₂ : x &gt; 0) : g x = f x := by
  conv =&gt;
    rhs
    simp [f, h₂]
  exact h₁
</code></pre>
<ul>
<li><code>enter [1, x, 2, y]</code> は与えられた引数を使って <code>arg</code> と <code>intro</code> を繰り返す。これは単なるマクロである:</li>
</ul>
<pre><code>syntax enterArg := ident &lt;|&gt; group(&quot;@&quot;? num)
syntax &quot;enter &quot; &quot;[&quot; (colGt enterArg),+ &quot;]&quot;: conv
macro_rules
  | `(conv| enter [$i:num]) =&gt; `(conv| arg $i)
  | `(conv| enter [@$i:num]) =&gt; `(conv| arg @$i)
  | `(conv| enter [$id:ident]) =&gt; `(conv| ext $id)
  | `(conv| enter [$arg:enterArg, $args,*]) =&gt; `(conv| (enter [$arg]; enter [$args,*]))
</code></pre>
<ul>
<li>
<p><code>done</code> は、もし未解決のゴールがあるなら失敗する。</p>
</li>
<li>
<p><code>trace_state</code> は現在のゴールの状態を表示する。</p>
</li>
<li>
<p><code>whnf</code> は現在のターゲットを<em>Weak Head Normal Form</em>(WHNF / 弱頭部正規形)に変換する。</p>
</li>
<li>
<p><code>tactic =&gt; &lt;tactic sequence&gt;</code> を使うと通常のタクティクモードに戻る。これは、<code>conv</code> モードでサポートされていないタクティクでゴールを閉じるときや、従来の合同性や外延性の補題を適用するときに便利である。</p>
</li>
</ul>
<pre><code class="language-lean">example (g : Nat → Nat → Nat)
        (h₁ : ∀ x, x ≠ 0 → g x x = 1)
        (h₂ : x ≠ 0)
        : g x x + x = 1 + x := by
  conv =&gt;
    lhs
    -- ⊢ g x x + x
    arg 1
    -- ⊢ g x x
    rw [h₁]
    -- 2 goals: ⊢ 1, ⊢ x ≠ 0
    . skip
    . tactic =&gt; exact h₂
</code></pre>
<ul>
<li><code>apply &lt;term&gt;</code> は <code>tactic =&gt; apply &lt;term&gt;</code> の糖衣構文である。</li>
</ul>
<pre><code class="language-lean">example (g : Nat → Nat → Nat)
        (h₁ : ∀ x, x ≠ 0 → g x x = 1)
        (h₂ : x ≠ 0)
        : g x x + x = 1 + x := by
  conv =&gt;
    lhs
    arg 1
    rw [h₁]
    . skip
    . apply h₂
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="axioms-and-computation-公理と計算"><a class="header" href="#axioms-and-computation-公理と計算">Axioms and Computation (公理と計算)</a></h1>
<p>Leanに実装された<em>Calculus of Constructions</em>には、依存関数型、帰納型、そして最下層にある<em>impredicative</em>(非可述的)で<em>proof-irrelevant</em>(証明無関係)な <code>Prop</code> 型から始まる宇宙の階層が含まれていることを見てきた。本章では、Leanに実装されている<em>Calculus of Inductive Constructions</em>(CIC)に公理と規則を追加して、CICを拡張する方法を考える。このような方法で基礎体系を拡張することは、多くの場合便利である。基礎体系を拡張することで、より多くの定理を証明することが可能になるか、そうでなければ以前は簡単に証明できなかった定理を簡単に証明できるようになる。しかし、公理を追加することで、その正しさ(無矛盾性)に関する懸念の増大以上の否定的な結果が生じることもある。特に、追加した公理の使用は、以下で紹介するように定義と定理の計算内容に影響する。</p>
<p>Leanは計算的推論と古典論理的推論の両方をサポートするように設計されている。望むなら、ユーザーは<em>computationally pure</em>(計算上純粋)なフラグメントだけを使うことができ、そうすればシステム内の全ての閉じた式が<em>canonical normal form</em>(正規標準形)に評価されることが保証される。特に、例えば <code>Nat</code> 型の計算上純粋な閉じた式は、全て数字に簡約される。</p>
<p>Leanの標準ライブラリでは、<em>propositional extensionality</em>(命題外延性)という追加の公理と、<em>function extensionality</em>(関数外延性)の原理を含意する<em>quotient</em>(商)の構築が定義されている。これらの公理の拡張は、例えば集合や有限集合の理論を開発するために利用される。これらの公理やそれらに依存する定理を使うと、Leanのカーネルにおける項評価がブロックされ、<code>Nat</code> 型の閉項が数字に評価されなくなることがあることを以下で見る。しかし、これらの公理は新しい命題(の証明項)を(無条件に)追加するだけであり、Leanは仮想マシン評価器用のバイトコード(中間コード)に定義をコンパイルする際に型と命題の情報を消去するため、これらの公理は計算的解釈と両立する。計算に傾倒したユーザーであっても、計算における推論を行うために古典的な排中律を使いたいと思うかもしれない。排中律もカーネルでの項評価をブロックするが、排中律は定義のバイトコードへのコンパイルと両立する。</p>
<p>また、標準ライブラリは、計算的解釈とは全く相反する<em>choice principle</em>(選択原理)も定義している。選択原理は「データ(証明以外の項)」の存在を主張する命題から魔法のようにデータを生成することができ、便利だからである。いくつかの古典的な構文を使うには選択原理が必須であり、ユーザーは必要なときに選択原理をインポートすることができる。しかし、古典的な構文を使ってデータを生成する式は、計算可能な内容を持っていない。Leanでは、その事実を示すために、このような定義を <code>noncomputable</code> とマークする必要がある。</p>
<p>(<em>Diaconescu's theorem</em>として知られる)巧妙なトリックを使うと、命題外延性、関数外延性、選択原理から排中律を導くことができる。しかし、上述の通り、データを作るために使用されない限り、排中律や他の古典的な原理の使用はバイトコードコンパイルやコード抽出と両立する。(訳者注: 上記の公理たちに関して言えば、データを作るために古典的な原理を使用したときに限り計算不可能になる。)</p>
<p>要約すると、宇宙、依存関数型、帰納型という基本的なフレームワークの上に、標準ライブラリはさらに3つの公理を追加している:</p>
<ul>
<li>命題外延性の公理 <code>propext</code></li>
<li>商型 <code>Quot</code> の構築 : 関数外延性 <code>funext</code> を含意する</li>
<li>選択原理 <code>Classical.choice</code> : 存在命題 <code>Nonempty α</code> からデータ <code>a : α</code> を生成する</li>
</ul>
<p>ここで、最初の2つはLeanにおける項の正規化をブロックするが、バイトコード評価とは両立する。一方で、3つ目は計算的に解釈することができない。以下でこれらの詳細について述べる。</p>
<h2 id="historical-and-philosophical-context-歴史的文脈と哲学的文脈"><a class="header" href="#historical-and-philosophical-context-歴史的文脈と哲学的文脈">Historical and Philosophical Context (歴史的文脈と哲学的文脈)</a></h2>
<p>数学の歴史の大半において、数学は本質的に計算可能なものであった: 幾何学は幾何学的なオブジェクトの作図を扱い、代数学は連立方程式の計算可能な解法と関係があり、解析学は時間発展する物理系の将来の振る舞いを計算する手段を提供した。「任意の <code>x</code> について、...を満たす <code>y</code> が存在する(<code>∀ x, ∃ y, ...</code>)」という定理の証明から、<code>x</code> が与えられたときにそのような <code>y</code> を計算するアルゴリズムを抽出するのは、一般的に簡単なことだった。</p>
<p>しかし、19世紀になり数学的議論の複雑さが増すと、数学者たちはアルゴリズム的情報を必須としない、数学的対象の具体的な表現方法の詳細を抽象化した数学的対象の記述を使う新たな推論様式を開発した。その目的は計算の細部に拘泥することなく強力な「概念的」理解を得ることだったが、結果として直観的で計算可能な体系では単に<strong>偽</strong>である数学的定理を認めることになった。</p>
<p>今日においても、計算が数学にとって重要であることはほとんど一律に合意されている。しかし、計算にまつわる問題にどのように対処するのが最善かについては、様々な見解がある。<em>constructive</em>(構成的)な観点からすれば、数学をその計算的ルーツから切り離すのは間違いである: 全ての意味のある数学の定理は、直観的で計算的な解釈を持つべきである。<em>classical</em>(古典的)な観点からすると、問題の分離を維持した方が有益である: 私たちは、プログラムについて推論するために非構成的な理論やメソッドを使う自由を維持しながら、コンピュータプログラムを書くためにある言語と付属するメソッドを使うことができる。Leanは構成的アプローチと古典的アプローチの両方をサポートするように設計されている。ライブラリのコア部分は構成的に開発されている(そのため古典的な原理を使わない選択ができる)が、システムは古典的な数学的推論を行うためのサポートも提供している。</p>
<p>依存型理論の最も計算上純粋な部分は <code>Prop</code> 型の使用を完全に避けている。帰納型と依存関数型はデータ型とみなすことができ、これらの型の項は、これ以上簡約規則を適用できなくなるまで簡約規則を適用することで「評価」することができる。原理的には、<code>Nat</code> 型の任意の閉項(自由変数を持たない項)は <code>succ (succ (... (succ zero)...))</code> という数字に評価されるはずである。</p>
<p>証明無関係な <code>Prop</code> 型を導入し、定理に <code>irreducible</code> とマークすることは、問題分離への第一歩である。このマークの意図は、型 <code>p : Prop</code> の項は計算において何の役割も果たすべきでないということであり、その意味で項 <code>t : p</code> の具体的な構成は計算に「無関係」である。<code>Prop</code> 型の項を組み込んだ計算可能オブジェクトを定義することはできる。ポイントは、<code>Prop</code> 型の項は「計算結果を推論」する役に立つが、項から「コードを抽出」するときには無視できるということである。しかし、<code>Prop</code> 型の項はまったく無害というわけではない。<code>Prop</code> 型の項には任意の型 <code>α</code> とその項 <code>s : α</code>、<code>t : α</code> に対する等式 <code>s = t : Prop</code> が含まれる。このような等式は項を型チェックするためにキャストとして使用される。以下では、このようなキャストがどのようにシステム内の計算をブロックしうるかの例を見ていく。しかし、命題の内容を消去し、中間の型付け制約を無視し、正規形に達するまで項を簡約する評価枠組みの中では、計算は依然として可能である。これはまさにLeanの仮想マシンが行っていることである。</p>
<p>証明無関係な <code>Prop</code> を採用した場合、任意の命題 <code>p</code> に対する排中律 <code>p ∨ ¬p</code> を使うことは正当だと考えるかもしれない。もちろん、排中律がCICの規則に従って計算をブロックする可能性はあるが、上述のようにバイトコードの評価をブロックすることはない。Leanの基礎的理論において、計算に無関係な証明と計算に関係するデータの区別を完全に消し去り、データを計算不可能にするのは、節<a href="axioms_and_computation.html#choice-%E9%81%B8%E6%8A%9E%E5%8E%9F%E7%90%86">Choice (選択原理)</a>で説明する選択原理だけである。</p>
<h2 id="propositional-extensionality-命題外延性"><a class="header" href="#propositional-extensionality-命題外延性">Propositional Extensionality (命題外延性)</a></h2>
<p>命題外延性は次のような公理である:</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>axiom propext {a b : Prop} : (a ↔ b) → a = b
<span class="boring">end Hidden
</span></code></pre>
<p><code>propext</code> は、2つの命題が互いを含意するとき、それらは実際に等しいと主張する公理である。これは命題の集合論的な解釈と一致する。命題の集合論的な解釈において、<code>a : Prop</code> は空であるか、互いに区別されたある元 <code>*</code> のみを含むシングルトン <code>{*}</code> である。この公理は、どのようなコンテキストでも命題をそれと同値な命題に置き換えることができるという効果を持つ:</p>
<pre><code class="language-lean">theorem thm₁ (a b c d e : Prop) (h : a ↔ b) : (c ∧ a ∧ d → e) ↔ (c ∧ b ∧ d → e) :=
  propext h ▸ Iff.refl _

theorem thm₂ (a b : Prop) (p : Prop → Prop) (h : a ↔ b) (h₁ : p a) : p b :=
  propext h ▸ h₁

#print axioms thm₁  -- 'thm₁' depends on axioms: [propext]
#print axioms thm₂  -- 'thm₂' depends on axioms: [propext]
</code></pre>
<!--
最初の定理は、命題結合子が命題の同値性を保存するという事実を使えば、手間はかかるが ``propext`` なしで証明することができる。2番目の定理はより本質的な ``propext`` の使い方である。実際、2番目の定理は ``propext`` 自体と同値である。

定義や定理が与えられたとき、コマンド ``#print axioms`` を使うと、それらがどの公理に依存しているかを表示させることができる。

.. code-block:: lean

    variables a b c d e : Prop
    variable p : Prop → Prop

    theorem thm₁ (h : a ↔ b) : (c ∧ a ∧ d → e) ↔ (c ∧ b ∧ d → e) :=
    propext h ▸ iff.refl _

    theorem thm₂ (h : a ↔ b) (h₁ : p a) : p b :=
    propext h ▸ h₁

    -- BEGIN
    #print axioms thm₁  -- propext
    #print axioms thm₂  -- propext
    -- END
-->
<h2 id="function-extensionality-関数外延性"><a class="header" href="#function-extensionality-関数外延性">Function Extensionality (関数外延性)</a></h2>
<p>命題外延性と同様に、関数外延性は、全ての入力に対して出力が一致する <code>(x : α) → β x</code> 型の2つの関数は等しいことを主張する。</p>
<pre><code class="language-lean">universe u v
#check (@funext :
           {α : Type u}
         → {β : α → Type u}
         → {f g : (x : α) → β x}
         → (∀ (x : α), f x = g x)
         → f = g)

#print funext
</code></pre>
<p>古典的な集合論の観点からは、2つの関数が等しいというのはまさにこのことを意味する(<a href="https://us.metamath.org/mpeuni/eqfnfv.html">eqfnfv - Metamath Proof Explorer</a>)。これは関数の「外延的な」見方として知られている。しかし、構成的な観点からは、関数をアルゴリズム、あるいは何らかの明示的な方法で提示されるコンピュータプログラムと考える方が自然な場合もある。2つのコンピュータプログラムが、構文的には全く異なっているにも関わらず、全ての入力に対して同じ答えを計算できるという例は確かにある。同様に、同じ入出力動作をする2つの関数を同一視することを強制しないような関数の見方を維持したいと思うかもしれない。これは関数の「内包的な」見方として知られている。</p>
<p>関数外延性は商の存在から導かれる。この事実については次の節で説明する。実際、Leanの標準ライブラリでは、<code>funext</code> は<a href="https://github.com/leanprover/lean4/blob/master/src/Init/Core.lean">商の構築から証明されている</a>。</p>
<p><code>α : Type</code> に対して、<code>α</code> の部分集合の型を表す <code>Set α := α → Prop</code> を定義したとする。つまり、部分集合と述語を本質的に同一視するとする。<code>funext</code> と <code>propext</code> を組み合わせることで、このような集合の「外延性の定理」<code>setext</code> が得られる:</p>
<pre><code class="language-lean">def Set (α : Type u) := α → Prop

namespace Set

def mem (x : α) (a : Set α) : Prop := a x

infix:50 (priority := high) &quot;∈&quot; =&gt; mem

theorem setext {a b : Set α} (h : ∀ (x : α), x ∈ a ↔ x ∈ b) : a = b :=
  funext (fun x =&gt; propext (h x))

theorem setext' {a b : Set α} (h : ∀ (x : α), a x ↔ b x) : a = b :=
  funext (fun x =&gt; propext (h x))

end Set
</code></pre>
<p>それから、例えば空集合や集合の共通部分を定義し、集合に関する恒等式を証明することができる:</p>
<pre><code class="language-lean"><span class="boring">def Set (α : Type u) := α → Prop
</span><span class="boring">namespace Set
</span><span class="boring">def mem (x : α) (a : Set α) := a x
</span><span class="boring">infix:50 (priority := high) &quot;∈&quot; =&gt; mem
</span><span class="boring">theorem setext {a b : Set α} (h : ∀ x, x ∈ a ↔ x ∈ b) : a = b :=
</span><span class="boring">  funext (fun x =&gt; propext (h x))
</span>def empty : Set α := fun x =&gt; False

notation (priority := high) &quot;∅&quot; =&gt; empty

def inter (a b : Set α) : Set α :=
  fun x =&gt; x ∈ a ∧ x ∈ b

infix:70 &quot; ∩ &quot; =&gt; inter

theorem inter_self (a : Set α) : a ∩ a = a :=
  setext fun x =&gt; Iff.intro
    (fun ⟨h, _⟩ =&gt; h)
    (fun h =&gt; ⟨h, h⟩)

theorem inter_empty (a : Set α) : a ∩ ∅ = ∅ :=
  setext fun x =&gt; Iff.intro
    (fun ⟨_, h⟩ =&gt; h)
    (fun h =&gt; False.elim h)

theorem empty_inter (a : Set α) : ∅ ∩ a = ∅ :=
  setext fun x =&gt; Iff.intro
    (fun ⟨h, _⟩ =&gt; h)
    (fun h =&gt; False.elim h)

theorem inter.comm (a b : Set α) : a ∩ b = b ∩ a :=
  setext fun x =&gt; Iff.intro
    (fun ⟨h₁, h₂⟩ =&gt; ⟨h₂, h₁⟩)
    (fun ⟨h₁, h₂⟩ =&gt; ⟨h₂, h₁⟩)
<span class="boring">end Set
</span></code></pre>
<p>以下は、Leanのカーネル内部で関数外延性がどのように計算をブロックするかの一例である。</p>
<pre><code class="language-lean">def f (x : Nat) := x
def g (x : Nat) := 0 + x

theorem f_eq_g : f = g :=
  funext fun x =&gt; (Nat.zero_add x).symm

def val : Nat :=
  Eq.recOn (motive := fun _ _ =&gt; Nat) f_eq_g 0

-- does not reduce to 0
#reduce val

-- evaluates to 0
#eval val
</code></pre>
<p>まず、関数外延性を用いて2つの関数 <code>f</code> と <code>g</code> が等しいことを示す。次に <code>0</code> の型 <code>Nat</code> の中に登場する <code>f</code> を <code>g</code> に置き換えて <code>0</code> をキャストする。もちろん <code>Nat</code> は <code>f</code> に依存しないので、このキャストは実質的に何もしない。しかし、計算をブロックするにはこれで十分である: このシステムの計算規則の下で、数字に簡約されない <code>Nat</code> の閉項 <code>val</code> を手に入れた。今回の場合、<code>val</code> を <code>0</code> に簡約してほしいと思うかもしれない。しかし、自明でない例では、このようなキャストを除去すると項の型が変わり、周囲の式の型が不正確になる可能性がある。しかしながら、仮想マシンは何の問題もなく <code>val</code> を <code>0</code> に評価できる。次は <code>propext</code> がどのように計算をブロックするかを示す、上と似た作為的な例である。</p>
<pre><code class="language-lean">theorem tteq : (True ∧ True) = True :=
  propext (Iff.intro (fun ⟨h, _⟩ =&gt; h) (fun h =&gt; ⟨h, h⟩))

def val : Nat :=
  Eq.recOn (motive := fun _ _ =&gt; Nat) tteq 0

-- does not reduce to 0
#reduce val

-- evaluates to 0
#eval val
</code></pre>
<p><em>observational type theory</em>や<em>cubical type theory</em>を含む現在の型理論の研究プログラムは、関数外延性や商などを含む型キャストに対する簡約を許可する方法で型理論を拡張することを目指している。しかし、解決策はそれほど明確ではなく、Leanの基礎となるcalculusの規則はそのようなキャストの簡約を認めていない。</p>
<p>しかしながらある意味では、キャストは式の意味を変えるものではない。むしろ、キャストは式の型を推論するためのメカニズムだと言える。適切な意味論が与えられれば、簡約前後で型付けの正しさを保存するために必要な中間的な記録を無視して、項の意味を保持するやり方で項を簡約することは理にかなっている。</p>
<p>簡約可能性について、<code>Prop</code> に新しい公理を追加することは問題にならない。証明無関係により、<code>Prop</code> の項は何の情報も持たない。したがって、簡約手続きにおいて <code>Prop</code> の項は安全に無視できる。</p>
<h2 id="quotients-商"><a class="header" href="#quotients-商">Quotients (商)</a></h2>
<p><code>α</code> を任意の型とし、<code>r</code> を <code>α</code> 上の同値関係とする。数学において、<em>quotient</em>(商) <code>α / r</code>、つまり「<code>α</code> の項の <code>r</code> による同値類」全体からなる型を作ることは一般的である。集合論的には、<code>α / r</code> を <code>α</code> の項の <code>r</code> による同値類全体からなる集合とみなすことができる。このとき、<code>∀ a b, r a b → f a = f b</code> を満たすという意味で同値関係を尊重する任意の関数 <code>f : α → β</code> を、各同値類 <code>⟦x⟧</code> に対して <code>f' ⟦x⟧ = f x</code> で定義される関数 <code>f' : α / r → β</code> に「持ち上げる」ことができる。Leanの標準ライブラリは、まさにこのような構築を実行する定数(公理)をいくつか追加することで、<em>Calculus of Constructions</em>を拡張している。そして、これらの最後の公理 <code>Quot.lift</code> をdefinitionalな除去則として導入している。</p>
<p>最も基本的な形では、商の構築 <code>Quot.mk</code> は <code>r</code> が同値関係であることさえ要求しない。Leanには以下の定数(公理)がビルトインに(ライブラリの最初のファイル <code>Init.Prelude</code> より先に)定義されている:</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>universe u v

axiom Quot : {α : Sort u} → (α → α → Prop) → Sort u

axiom Quot.mk : {α : Sort u} → (r : α → α → Prop) → α → Quot r

axiom Quot.ind :
    ∀ {α : Sort u} {r : α → α → Prop} {β : Quot r → Prop},
      (∀ a, β (Quot.mk r a)) → (q : Quot r) → β q

axiom Quot.lift :
    {α : Sort u} → {r : α → α → Prop} → {β : Sort u} → (f : α → β)
    → (∀ a b, r a b → f a = f b) → Quot r → β
<span class="boring">end Hidden
</span></code></pre>
<p>最初の公理 <code>Quot</code> は、型 <code>α</code> と <code>α</code> 上の二項関係 <code>r</code> が与えられたときに型 <code>Quot r</code> を形成する。2つ目の公理 <code>Quot.mk</code> は、<code>α</code> の項を <code>Quot r</code> の項に写すもので、<code>r : α → α → Prop</code> と <code>a : α</code> があれば、<code>Quot.mk r a</code> は <code>Quot r</code> の項である。3つ目の公理 <code>Quot.ind</code> は、全ての <code>Quot r</code> の項が <code>Quot.mk r a</code> の形をとることを示す(<code>Quot r → Prop</code> を <code>Set (Quot r)</code> とみなすと分かりやすい)。4つ目の公理 <code>Quot.lift</code> は、関数 <code>f : α → β</code> が与えられたとき、<code>h</code> が「<code>f</code> は関係 <code>r</code> を尊重する」ことの証明であれば、<code>Quot.lift f h</code> は <code>f</code> に対応する <code>Quot r</code> 上の関数であることを主張する。この考え方は、<code>h</code> が「<code>f</code> はwell-definedである」ことを示す証明なら、関数 <code>Quot.lift f h</code> は <code>α</code> の各項 <code>a</code> について、<code>Quot.mk r a</code> (<code>a</code> を含む <code>r</code>-(同値)類)を <code>f a</code> に写す、というものである。以下の証明で明らかなように、計算原理 <code>Quot.Lift</code> は除去則として宣言されている。</p>
<pre><code class="language-lean">def mod7Rel (x y : Nat) : Prop :=
  x % 7 = y % 7

-- 商型 `Quot mod7Rel`
#check (Quot mod7Rel : Type)

-- `4` を含む `mod7Rel`-(同値)類
#check (Quot.mk mod7Rel 4 : Quot mod7Rel)

def f (x : Nat) : Bool :=
  x % 7 = 0

theorem f_respects (a b : Nat) (h : mod7Rel a b) : f a = f b := by
  simp [mod7Rel, f] at *
  rw [h]

def f' (x : Quot mod7Rel) : Bool :=
  Quot.lift f f_respects x

#check (f' : Quot mod7Rel → Bool)

-- 計算原理
example (a : Nat) : f' (Quot.mk mod7Rel a) = f a :=
  rfl
</code></pre>
<p>4つの定数(公理) <code>Quot</code>、<code>Quot.mk</code>、<code>Quot.ind</code>、<code>Quot.lift</code> 自体はあまり強くない。<code>Quot r</code> を単に <code>α</code> とみなし、<code>Quot.lift</code> を(<code>h</code> を無視して) <code>α → β</code> 上の恒等関数とみなせば、<code>Quot.ind</code> が満たされることが確認できる。そのため、これら4つの公理は追加の公理とはみなさない。</p>
<pre><code class="language-lean"><span class="boring">variable (α β : Type)
</span><span class="boring">variable (r : α → α → Prop)
</span><span class="boring">variable (a : α)
</span><span class="boring">variable (f : α → β)
</span><span class="boring">variable (h : ∀ a₁ a₂, r a₁ a₂ → f a₁ = f a₂)
</span>theorem thm : Quot.lift f h (Quot.mk r a) = f a := rfl

#print axioms thm   -- 'thm' does not depend on any axioms
</code></pre>
<p>これら4つの公理は、帰納型や帰納型に関連するコンストラクタと再帰子と同様に、<em>logical framework</em>(論理フレームワーク)の一部とみなされる。</p>
<p><code>Quot</code> を正真正銘の商にするのは、次の追加公理 <code>Quot.sound</code> である:</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span><span class="boring">universe u v
</span>axiom Quot.sound :
      ∀ {α : Type u} {r : α → α → Prop} {a b : α},
        r a b → Quot.mk r a = Quot.mk r b
<span class="boring">end Hidden
</span></code></pre>
<p>これは「<code>α</code> の任意の2つの項は、<code>r</code> によって関係しているなら、商の中で同一視される」と主張する公理である。定義や定理 <code>foo</code> が <code>Quot.sound</code> を使っている場合、コマンド <code>#print axioms foo</code> は <code>Quot.sound</code> を表示する。</p>
<p>もちろん、商の構築は <code>r</code> が同値関係である場合に最もよく使われる。上記のように <code>r</code> が与えられたとき、<code>r' a b</code> と <code>Quot.mk r a = Quot.mk r b</code> が同値になるように <code>r'</code> を定義すれば、<code>r'</code> が同値関係であることは明らかである。実際、<code>r'</code> は関数 <code>a ↦ quot.mk r a</code> の<em>kernel</em>(核)である。公理 <code>Quot.sound</code> は、<code>r a b</code> が <code>r' a b</code> を含意すると主張している。<code>Quot.lift</code> と <code>Quot.ind</code> を使えば、「<code>r</code> を含む任意の同値関係 <code>r''</code> に対して、<code>r' a b</code> は <code>r'' a b</code> を含意する」という意味で、<code>r'</code> が <code>r</code> を含む最小の同値関係であることを証明できる。特に、<code>r</code> がそもそも同値関係であったならば、任意の <code>a</code> と <code>b</code> に対して、<code>r a b</code> と <code>r' a b</code> が同値であることが証明できる。</p>
<p>同値関係や商の一般的なユースケースをサポートするために、標準ライブラリは<em>setoid</em>という概念を定義している。これは単に同値関係を持つ型である:</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>class Setoid (α : Sort u) where
  r : α → α → Prop
  iseqv : Equivalence r

instance {α : Sort u} [Setoid α] : HasEquiv α :=
  ⟨Setoid.r⟩

namespace Setoid

variable {α : Sort u} [Setoid α]

theorem refl (a : α) : a ≈ a :=
  iseqv.refl a

theorem symm {a b : α} (hab : a ≈ b) : b ≈ a :=
  iseqv.symm hab

theorem trans {a b c : α} (hab : a ≈ b) (hbc : b ≈ c) : a ≈ c :=
  iseqv.trans hab hbc

end Setoid
<span class="boring">end Hidden
</span></code></pre>
<p>型 <code>α</code>、<code>α</code> 上の二項関係 <code>r</code>、<code>r</code> が同値関係であることの証明 <code>p</code> が与えられたとき、<code>Setoid.mk r p</code> により <code>Setoid</code> クラスのインスタンスを定義することができる。</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>def Quotient {α : Sort u} (s : Setoid α) :=
  @Quot α Setoid.r
<span class="boring">end Hidden
</span></code></pre>
<p>定数(公理) <code>Quotient.mk</code>、<code>Quotient.ind</code>、<code>Quotient.lift</code>、<code>Quotient.sound</code> は <code>Quot</code> の対応する要素の特殊化に他ならない。型クラス推論が型 <code>Setoid α</code> のインスタンスを見つけることができるという事実は、多くの利点をもたらす。まず、<code>Setoid.r a b</code> を <code>a ≈ b</code> (<code>\approx</code> と打つと入力できる)と略記することができる。ここで、<code>Setoid.r</code> という表記について、<code>Setoid</code> のインスタンスが暗黙の引数となっていることに注意してほしい。また、<code>Setoid.refl</code>、<code>Setoid.symm</code>、<code>Setoid.trans</code> という一般的な定理を使って同値関係に関する推論を行うことができる。商においては特に <code>Quot.mk Setoid.r a</code> の一般的な略記 <code>⟦a⟧</code> を使うことができる。ここでも <code>Setoid.r</code> 表記に関して <code>Setoid</code> のインスタンスが暗黙の引数となっている。<code>Quotient.exact</code> という定理もある:</p>
<pre><code class="language-lean"><span class="boring">universe u
</span>#check (@Quotient.exact :
         ∀ {α : Sort u} {s : Setoid α} {a b : α},
           Quotient.mk s a = Quotient.mk s b → a ≈ b)
</code></pre>
<p><code>Quotient.exact</code> と <code>Quotient.sound</code> を組み合わせると、<code>Quotient s</code> の各項が <code>α</code> の項の各同値類と正確に対応することが導かれる。</p>
<p>標準ライブラリでは、型 <code>α × β</code> は型 <code>α</code> と <code>β</code> の直積を表すことを思い出してほしい。商の使い方を説明するために、型 <code>α</code> の項からなる<strong>非順序</strong>対の型を、型 <code>α × α</code> の商として定義してみよう。まず、関連する同値関係を定義する:</p>
<pre><code class="language-lean">private def eqv (p₁ p₂ : α × α) : Prop :=
  (p₁.1 = p₂.1 ∧ p₁.2 = p₂.2) ∨ (p₁.1 = p₂.2 ∧ p₁.2 = p₂.1)

infix:50 &quot; ~ &quot; =&gt; eqv
</code></pre>
<p>次のステップは、<code>eqv</code> が実際に同値関係であること、つまり反射的、対称的、推移的であることを証明することである。依存パターンマッチングを使って場合分けし、仮説を分解し、それを組み立てて結論を出すことで、便利で読みやすい方法でこれら3つの事実を証明することができる。</p>
<pre><code class="language-lean"><span class="boring">private def eqv (p₁ p₂ : α × α) : Prop :=
</span><span class="boring">  (p₁.1 = p₂.1 ∧ p₁.2 = p₂.2) ∨ (p₁.1 = p₂.2 ∧ p₁.2 = p₂.1)
</span><span class="boring">infix:50 &quot; ~ &quot; =&gt; eqv
</span>private theorem eqv.refl (p : α × α) : p ~ p :=
  Or.inl ⟨rfl, rfl⟩

private theorem eqv.symm : ∀ {p₁ p₂ : α × α}, p₁ ~ p₂ → p₂ ~ p₁
  | (a₁, a₂), (b₁, b₂), (Or.inl ⟨a₁b₁, a₂b₂⟩) =&gt;
    Or.inl (by simp_all)
  | (a₁, a₂), (b₁, b₂), (Or.inr ⟨a₁b₂, a₂b₁⟩) =&gt;
    Or.inr (by simp_all)

private theorem eqv.trans : ∀ {p₁ p₂ p₃ : α × α}, p₁ ~ p₂ → p₂ ~ p₃ → p₁ ~ p₃
  | (a₁, a₂), (b₁, b₂), (c₁, c₂), Or.inl ⟨a₁b₁, a₂b₂⟩, Or.inl ⟨b₁c₁, b₂c₂⟩ =&gt;
    Or.inl (by simp_all)
  | (a₁, a₂), (b₁, b₂), (c₁, c₂), Or.inl ⟨a₁b₁, a₂b₂⟩, Or.inr ⟨b₁c₂, b₂c₁⟩ =&gt;
    Or.inr (by simp_all)
  | (a₁, a₂), (b₁, b₂), (c₁, c₂), Or.inr ⟨a₁b₂, a₂b₁⟩, Or.inl ⟨b₁c₁, b₂c₂⟩ =&gt;
    Or.inr (by simp_all)
  | (a₁, a₂), (b₁, b₂), (c₁, c₂), Or.inr ⟨a₁b₂, a₂b₁⟩, Or.inr ⟨b₁c₂, b₂c₁⟩ =&gt;
    Or.inl (by simp_all)

private theorem is_equivalence : Equivalence (@eqv α) :=
  { refl := eqv.refl, symm := eqv.symm, trans := eqv.trans }
</code></pre>
<p><code>eqv</code> が同値関係であることが証明されたので、<code>Setoid (α × α)</code> のインスタンスを構築することができ、<code>Setoid (α × α)</code> を使って非順序対の型 <code>UProd α</code> を定義することができる。</p>
<pre><code class="language-lean"><span class="boring">private def eqv (p₁ p₂ : α × α) : Prop :=
</span><span class="boring">  (p₁.1 = p₂.1 ∧ p₁.2 = p₂.2) ∨ (p₁.1 = p₂.2 ∧ p₁.2 = p₂.1)
</span><span class="boring">infix:50 &quot; ~ &quot; =&gt; eqv
</span><span class="boring">private theorem eqv.refl (p : α × α) : p ~ p :=
</span><span class="boring">  Or.inl ⟨rfl, rfl⟩
</span><span class="boring">private theorem eqv.symm : ∀ {p₁ p₂ : α × α}, p₁ ~ p₂ → p₂ ~ p₁
</span><span class="boring">  | (a₁, a₂), (b₁, b₂), (Or.inl ⟨a₁b₁, a₂b₂⟩) =&gt;
</span><span class="boring">    Or.inl (by simp_all)
</span><span class="boring">  | (a₁, a₂), (b₁, b₂), (Or.inr ⟨a₁b₂, a₂b₁⟩) =&gt;
</span><span class="boring">    Or.inr (by simp_all)
</span><span class="boring">private theorem eqv.trans : ∀ {p₁ p₂ p₃ : α × α}, p₁ ~ p₂ → p₂ ~ p₃ → p₁ ~ p₃
</span><span class="boring">  | (a₁, a₂), (b₁, b₂), (c₁, c₂), Or.inl ⟨a₁b₁, a₂b₂⟩, Or.inl ⟨b₁c₁, b₂c₂⟩ =&gt;
</span><span class="boring">    Or.inl (by simp_all)
</span><span class="boring">  | (a₁, a₂), (b₁, b₂), (c₁, c₂), Or.inl ⟨a₁b₁, a₂b₂⟩, Or.inr ⟨b₁c₂, b₂c₁⟩ =&gt;
</span><span class="boring">    Or.inr (by simp_all)
</span><span class="boring">  | (a₁, a₂), (b₁, b₂), (c₁, c₂), Or.inr ⟨a₁b₂, a₂b₁⟩, Or.inl ⟨b₁c₁, b₂c₂⟩ =&gt;
</span><span class="boring">    Or.inr (by simp_all)
</span><span class="boring">  | (a₁, a₂), (b₁, b₂), (c₁, c₂), Or.inr ⟨a₁b₂, a₂b₁⟩, Or.inr ⟨b₁c₂, b₂c₁⟩ =&gt;
</span><span class="boring">    Or.inl (by simp_all)
</span><span class="boring">private theorem is_equivalence : Equivalence (@eqv α) :=
</span><span class="boring">  { refl := eqv.refl, symm := eqv.symm, trans := eqv.trans }
</span>instance uprodSetoid (α : Type u) : Setoid (α × α) where
  r     := eqv
  iseqv := is_equivalence

def UProd (α : Type u) : Type u :=
  Quotient (uprodSetoid α)

namespace UProd

def mk {α : Type} (a₁ a₂ : α) : UProd α :=
  Quotient.mk' (a₁, a₂)

notation &quot;{ &quot; a₁ &quot;, &quot; a₂ &quot; }&quot; =&gt; mk a₁ a₂

end UProd
</code></pre>
<p>非順序対 <code>Quotient.mk' (a₁, a₂)</code> に対する略記 <code>{a₁, a₂}</code> をローカルに定義していることに注意してほしい。この略記は説明を目的とするなら便利であるが、レコードや集合のような対象を表すのに波括弧を使いにくくなるので、一般的には良いアイデアではない。</p>
<p>既に <code>(a₁, a₂) ~ (a₂, a₁)</code> を証明してあるので、<code>Quot.sound</code> を使うことで <code>{a₁, a₂} = {a₂, a₁}</code> を簡単に証明することができる。</p>
<pre><code class="language-lean"><span class="boring">private def eqv (p₁ p₂ : α × α) : Prop :=
</span><span class="boring">  (p₁.1 = p₂.1 ∧ p₁.2 = p₂.2) ∨ (p₁.1 = p₂.2 ∧ p₁.2 = p₂.1)
</span><span class="boring">infix:50 &quot; ~ &quot; =&gt; eqv
</span><span class="boring">private theorem eqv.refl (p : α × α) : p ~ p :=
</span><span class="boring">  Or.inl ⟨rfl, rfl⟩
</span><span class="boring">private theorem eqv.symm : ∀ {p₁ p₂ : α × α}, p₁ ~ p₂ → p₂ ~ p₁
</span><span class="boring">  | (a₁, a₂), (b₁, b₂), (Or.inl ⟨a₁b₁, a₂b₂⟩) =&gt;
</span><span class="boring">    Or.inl (by simp_all)
</span><span class="boring">  | (a₁, a₂), (b₁, b₂), (Or.inr ⟨a₁b₂, a₂b₁⟩) =&gt;
</span><span class="boring">    Or.inr (by simp_all)
</span><span class="boring">private theorem eqv.trans : ∀ {p₁ p₂ p₃ : α × α}, p₁ ~ p₂ → p₂ ~ p₃ → p₁ ~ p₃
</span><span class="boring">  | (a₁, a₂), (b₁, b₂), (c₁, c₂), Or.inl ⟨a₁b₁, a₂b₂⟩, Or.inl ⟨b₁c₁, b₂c₂⟩ =&gt;
</span><span class="boring">    Or.inl (by simp_all)
</span><span class="boring">  | (a₁, a₂), (b₁, b₂), (c₁, c₂), Or.inl ⟨a₁b₁, a₂b₂⟩, Or.inr ⟨b₁c₂, b₂c₁⟩ =&gt;
</span><span class="boring">    Or.inr (by simp_all)
</span><span class="boring">  | (a₁, a₂), (b₁, b₂), (c₁, c₂), Or.inr ⟨a₁b₂, a₂b₁⟩, Or.inl ⟨b₁c₁, b₂c₂⟩ =&gt;
</span><span class="boring">    Or.inr (by simp_all)
</span><span class="boring">  | (a₁, a₂), (b₁, b₂), (c₁, c₂), Or.inr ⟨a₁b₂, a₂b₁⟩, Or.inr ⟨b₁c₂, b₂c₁⟩ =&gt;
</span><span class="boring">    Or.inl (by simp_all)
</span><span class="boring">private theorem is_equivalence : Equivalence (@eqv α) :=
</span><span class="boring">  { refl := eqv.refl, symm := eqv.symm, trans := eqv.trans }
</span><span class="boring">instance uprodSetoid (α : Type u) : Setoid (α × α) where
</span><span class="boring">  r     := eqv
</span><span class="boring">  iseqv := is_equivalence
</span><span class="boring">def UProd (α : Type u) : Type u :=
</span><span class="boring">  Quotient (uprodSetoid α)
</span><span class="boring">namespace UProd
</span><span class="boring">def mk {α : Type} (a₁ a₂ : α) : UProd α :=
</span><span class="boring">  Quotient.mk' (a₁, a₂)
</span><span class="boring">notation &quot;{ &quot; a₁ &quot;, &quot; a₂ &quot; }&quot; =&gt; mk a₁ a₂
</span>theorem mk_eq_mk (a₁ a₂ : α) : {a₁, a₂} = {a₂, a₁} :=
  Quot.sound (Or.inr ⟨rfl, rfl⟩)
<span class="boring">end UProd
</span></code></pre>
<p>この例を完成させるため、<code>a : α</code> と <code>u : UProd α</code> に対して、<code>a</code> が非順序対 <code>u</code> の要素の1つである場合に成立する命題 <code>a ∈ u</code> を定義する。まず、順序対に対して同じような命題 <code>mem_fn a u</code> を定義する。次に <code>mem_fn</code> が同値関係 <code>eqv</code> を尊重することを補題 <code>mem_respects</code> で示す。これはLeanの標準ライブラリで広く使われているイディオムである。</p>
<pre><code class="language-lean"><span class="boring">private def eqv (p₁ p₂ : α × α) : Prop :=
</span><span class="boring">  (p₁.1 = p₂.1 ∧ p₁.2 = p₂.2) ∨ (p₁.1 = p₂.2 ∧ p₁.2 = p₂.1)
</span><span class="boring">infix:50 &quot; ~ &quot; =&gt; eqv
</span><span class="boring">private theorem eqv.refl (p : α × α) : p ~ p :=
</span><span class="boring">  Or.inl ⟨rfl, rfl⟩
</span><span class="boring">private theorem eqv.symm : ∀ {p₁ p₂ : α × α}, p₁ ~ p₂ → p₂ ~ p₁
</span><span class="boring">  | (a₁, a₂), (b₁, b₂), (Or.inl ⟨a₁b₁, a₂b₂⟩) =&gt;
</span><span class="boring">    Or.inl (by simp_all)
</span><span class="boring">  | (a₁, a₂), (b₁, b₂), (Or.inr ⟨a₁b₂, a₂b₁⟩) =&gt;
</span><span class="boring">    Or.inr (by simp_all)
</span><span class="boring">private theorem eqv.trans : ∀ {p₁ p₂ p₃ : α × α}, p₁ ~ p₂ → p₂ ~ p₃ → p₁ ~ p₃
</span><span class="boring">  | (a₁, a₂), (b₁, b₂), (c₁, c₂), Or.inl ⟨a₁b₁, a₂b₂⟩, Or.inl ⟨b₁c₁, b₂c₂⟩ =&gt;
</span><span class="boring">    Or.inl (by simp_all)
</span><span class="boring">  | (a₁, a₂), (b₁, b₂), (c₁, c₂), Or.inl ⟨a₁b₁, a₂b₂⟩, Or.inr ⟨b₁c₂, b₂c₁⟩ =&gt;
</span><span class="boring">    Or.inr (by simp_all)
</span><span class="boring">  | (a₁, a₂), (b₁, b₂), (c₁, c₂), Or.inr ⟨a₁b₂, a₂b₁⟩, Or.inl ⟨b₁c₁, b₂c₂⟩ =&gt;
</span><span class="boring">    Or.inr (by simp_all)
</span><span class="boring">  | (a₁, a₂), (b₁, b₂), (c₁, c₂), Or.inr ⟨a₁b₂, a₂b₁⟩, Or.inr ⟨b₁c₂, b₂c₁⟩ =&gt;
</span><span class="boring">    Or.inl (by simp_all)
</span><span class="boring">private theorem is_equivalence : Equivalence (@eqv α) :=
</span><span class="boring">  { refl := eqv.refl, symm := eqv.symm, trans := eqv.trans }
</span><span class="boring">instance uprodSetoid (α : Type u) : Setoid (α × α) where
</span><span class="boring">  r     := eqv
</span><span class="boring">  iseqv := is_equivalence
</span><span class="boring">def UProd (α : Type u) : Type u :=
</span><span class="boring">  Quotient (uprodSetoid α)
</span><span class="boring">namespace UProd
</span><span class="boring">def mk {α : Type} (a₁ a₂ : α) : UProd α :=
</span><span class="boring">  Quotient.mk' (a₁, a₂)
</span><span class="boring">notation &quot;{ &quot; a₁ &quot;, &quot; a₂ &quot; }&quot; =&gt; mk a₁ a₂
</span><span class="boring">theorem mk_eq_mk (a₁ a₂ : α) : {a₁, a₂} = {a₂, a₁} :=
</span><span class="boring">  Quot.sound (Or.inr ⟨rfl, rfl⟩)
</span>private def mem_fn (a : α) : α × α → Prop
  | (a₁, a₂) =&gt; a = a₁ ∨ a = a₂

-- auxiliary lemma for proving mem_respects
private theorem mem_swap {a : α} :
      ∀ {p : α × α}, mem_fn a p = mem_fn a (⟨p.2, p.1⟩)
  | (a₁, a₂) =&gt; by
    apply propext
    apply Iff.intro
    . intro
      | Or.inl h =&gt; exact Or.inr h
      | Or.inr h =&gt; exact Or.inl h
    . intro
      | Or.inl h =&gt; exact Or.inr h
      | Or.inr h =&gt; exact Or.inl h


private theorem mem_respects
      : {p₁ p₂ : α × α} → (a : α) → p₁ ~ p₂ → mem_fn a p₁ = mem_fn a p₂
  | (a₁, a₂), (b₁, b₂), a, Or.inl ⟨a₁b₁, a₂b₂⟩ =&gt; by simp_all
  | (a₁, a₂), (b₁, b₂), a, Or.inr ⟨a₁b₂, a₂b₁⟩ =&gt; by simp_all; apply mem_swap

def mem (a : α) (u : UProd α) : Prop :=
  Quot.liftOn u (fun p =&gt; mem_fn a p) (fun p₁ p₂ e =&gt; mem_respects a e)

infix:50 (priority := high) &quot; ∈ &quot; =&gt; mem

theorem mem_mk_left (a b : α) : a ∈ {a, b} :=
  Or.inl rfl

theorem mem_mk_right (a b : α) : b ∈ {a, b} :=
  Or.inr rfl

theorem mem_or_mem_of_mem_mk {a b c : α} : c ∈ {a, b} → c = a ∨ c = b :=
  fun h =&gt; h
<span class="boring">end UProd
</span></code></pre>
<p>利便性のため、標準ライブラリは2変数関数を「持ち上げる」ための <code>Quotient.lift₂</code> と、2変数帰納法のための <code>Quotient.ind₂</code> も定義している。</p>
<p>最後に、なぜ商の構築が関数外延性を含意するのかについて、いくつかのヒントを示してこの節を締めくくる。型 <code>(x : α) → β x</code> を持つ関数の外延性等式が同値関係であることを示すのは難しくない。したがって、「同値関係を足した」依存関数型 <code>extfun α β</code> を考えることができる。もちろん、関数適用は <code>f₁</code> と <code>f₂</code> が同値関係にあるなら、<code>f₁ a</code> は <code>f₂ a</code> と等しいという意味で、同値関係を尊重する。したがって、関数適用は関数 <code>extfun_app : extfun α β → (x : α) → β x</code> に持ち上げられる。しかし、任意の <code>f</code> について、<code>extfun_app ⟦f⟧</code> は <code>fun x =&gt; f x</code> とdefinitionally equalであり、結果として <code>f</code> とdefinitionally equalである。したがって、<code>f₁</code> と <code>f₂</code> が外延的に等しいとき、次のような等号の連鎖が成り立つ:</p>
<pre><code>    f₁ = extfun_app ⟦f₁⟧ = extfun_app ⟦f₂⟧ = f₂
</code></pre>
<p>結果として、<code>f₁</code> と <code>f₂</code> は等しい。</p>
<h2 id="choice-選択原理"><a class="header" href="#choice-選択原理">Choice (選択原理)</a></h2>
<p>標準ライブラリで定義されている最後の公理(選択原理)を述べるには、次のように定義される <code>Nonempty</code> 型が必要である:</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>class inductive Nonempty (α : Sort u) : Prop where
  | intro (val : α) : Nonempty α
<span class="boring">end Hidden
</span></code></pre>
<p><code>Nonempty α</code> 型は <code>Prop</code> 型を持ち、そのコンストラクタはデータを含むので、<a href="./inductive_types.html#inductively-defined-propositions-%E5%B8%B0%E7%B4%8D%E7%9A%84%E3%81%AB%E5%AE%9A%E7%BE%A9%E3%81%95%E3%82%8C%E3%81%9F%E5%91%BD%E9%A1%8C">Inductively Defined Propositions (帰納的に定義された命題)</a>の節で見た通り、<code>Nonempty α</code> 型を除去しても命題を作ることしかできない。実際、<code>Nonempty α</code> は <code>∃ x : α, True</code> と同値である:</p>
<pre><code class="language-lean">example (α : Type u) : Nonempty α ↔ ∃ x : α, True :=
  Iff.intro (fun ⟨a⟩ =&gt; ⟨a, trivial⟩) (fun ⟨a, h⟩ =&gt; ⟨a⟩)
</code></pre>
<p>Lean版の選択公理は次のようにシンプルに表現される:</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span><span class="boring">universe u
</span>axiom choice {α : Sort u} : Nonempty α → α
<span class="boring">end Hidden
</span></code></pre>
<p>「<code>α</code> は空でない」ことの証明 <code>h</code> さえあれば、<code>choice h</code> は魔法のように <code>α</code> の項を生成する。もちろん、<code>choice</code> の使用は意味のある計算をブロックする: 証明無関係の考え方の下では、<code>h</code> はそのような項を見つける方法に関する情報を全く含んでいない。</p>
<p><code>choice</code> は <code>Classical</code> という名前空間の中にあるため、この公理のフルネームは <code>Classical.choice</code> である。選択原理は<em>indefinite description</em>(不定的記述)の原理と同値である。不定的記述の原理は<em>subtypes</em>(部分型)を使って次のように表すことができる:</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span><span class="boring">universe u
</span><span class="boring">axiom choice {α : Sort u} : Nonempty α → α
</span>noncomputable def indefiniteDescription {α : Sort u} (p : α → Prop)
                                        (h : ∃ x, p x) : {x // p x} :=
  choice &lt;| let ⟨x, px⟩ := h; ⟨⟨x, px⟩⟩
<span class="boring">end Hidden
</span></code></pre>
<p>この定義は <code>choice</code> に依存するため、Leanは <code>indefiniteDescription</code> のバイトコードを生成できない。したがって、この定義を <code>noncomputable</code> とマークする必要がある。また、<code>Classical</code> 名前空間では、関数 <code>choose</code> とプロパティ <code>choose_spec</code> は <code>indefiniteDescription</code> の(2つの要素からなる)出力を分解し、各要素を抽出する:</p>
<pre><code class="language-lean"><span class="boring">open Classical
</span><span class="boring">namespace Hidden
</span>noncomputable def choose {α : Sort u} {p : α → Prop} (h : ∃ x, p x) : α :=
  (indefiniteDescription p h).val

theorem choose_spec {α : Sort u} {p : α → Prop} (h : ∃ x, p x) : p (choose h) :=
  (indefiniteDescription p h).property
<span class="boring">end Hidden
</span></code></pre>
<p>また、選択原理 <code>Choice</code> は「空でない」という性質 <code>Nonempty</code> と「有項である」というより構成的な性質 <code>Inhabited</code> の区別をなくしてしまう:</p>
<pre><code class="language-lean"><span class="boring">open Classical
</span>theorem inhabited_of_nonempty : Nonempty α → Inhabited α :=
  fun h =&gt; choice (let ⟨a⟩ := h; ⟨⟨a⟩⟩)
</code></pre>
<p>次節では <code>propext</code>、<code>funext</code>、<code>choice</code> の3つを合わせると、排中律と任意の命題の決定可能性が導かれることを説明する。これらを用いると、不定的記述の原理を次のように強化することができる:</p>
<pre><code class="language-lean"><span class="boring">open Classical
</span><span class="boring">universe u
</span>#check (@strongIndefiniteDescription :
         {α : Sort u} → (p : α → Prop)
         → Nonempty α → {x // (∃ (y : α), p y) → p x})
</code></pre>
<p>前提となる型 <code>α</code> が空でないとすると、<code>p</code> を満たす項が存在するなら、<code>strongIndefiniteDescription p</code> は <code>p</code> を満たす項 <code>x</code> を生成する(<code>p</code> を満たす項が存在しないなら、<code>strongIndefiniteDescription p</code> は <code>choice</code> により生成された型 <code>α</code> の任意の項を返す)。この関数 <code>strongIndefiniteDescription</code> の出力から値要素を抽出する関数は<em>Hilbert's epsilon function</em>(ヒルベルトのε関数)として知られている:</p>
<pre><code class="language-lean"><span class="boring">open Classical
</span><span class="boring">universe u
</span>#check (@epsilon :
         {α : Sort u} → [Nonempty α]
         → (α → Prop) → α)

#check (@epsilon_spec :
         ∀ {α : Sort u} {p : α → Prop} (hex : ∃ (y : α), p y),
           p (@epsilon _ (nonempty_of_exists hex) p))
</code></pre>
<p>関数 <code>epsilon_spec</code> は、<code>p</code> を満たす項が存在するという証明を受け取ると、<code>p (epsilon p)</code> の証明を返す。</p>
<h2 id="the-law-of-the-excluded-middle-排中律"><a class="header" href="#the-law-of-the-excluded-middle-排中律">The Law of the Excluded Middle (排中律)</a></h2>
<p>排中律は次のように表現される:</p>
<pre><code class="language-lean">open Classical

#check (@em : ∀ (p : Prop), p ∨ ¬p)
</code></pre>
<p><a href="http://en.wikipedia.org/wiki/Diaconescu%27s_theorem">Diaconescuの定理</a>は、選択公理から排中律が導かれることを述べている。より正確には、Diaconescuの定理は、<code>Classical.choice</code>、<code>propext</code>、<code>funext</code> から排中律が導かれることを示している。以下に標準ライブラリにあるDiaconescuの定理の証明を記す。</p>
<p>まず、必要な公理をインポートして、2つの述語 <code>U</code> と <code>V</code> を定義する:</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>open Classical
theorem em (p : Prop) : p ∨ ¬p :=
  let U (x : Prop) : Prop := x = True ∨ p
  let V (x : Prop) : Prop := x = False ∨ p

  have exU : ∃ x, U x := ⟨True, Or.inl rfl⟩
  have exV : ∃ x, V x := ⟨False, Or.inl rfl⟩
<span class="boring">  sorry
</span><span class="boring">end Hidden
</span></code></pre>
<p>もし <code>p</code> が真なら、<code>Prop</code> 型の任意の項は <code>U</code> と <code>V</code> の両方に属する。もし <code>p</code> が偽なら、<code>U</code> はシングルトン <code>True</code> であり、<code>V</code> はシングルトン <code>False</code> である。</p>
<p>次に、<code>choose</code> を使って <code>U</code> の元と <code>V</code> の元を1つ選ぶ:</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span><span class="boring">open Classical
</span><span class="boring">theorem em (p : Prop) : p ∨ ¬p :=
</span><span class="boring">  let U (x : Prop) : Prop := x = True ∨ p
</span><span class="boring">  let V (x : Prop) : Prop := x = False ∨ p
</span><span class="boring">  have exU : ∃ x, U x := ⟨True, Or.inl rfl⟩
</span><span class="boring">  have exV : ∃ x, V x := ⟨False, Or.inl rfl⟩
</span>  let u : Prop := choose exU
  let v : Prop := choose exV

  have u_def : U u := choose_spec exU
  have v_def : V v := choose_spec exV
<span class="boring">  sorry
</span><span class="boring">end Hidden
</span></code></pre>
<p><code>U</code> と <code>V</code> はそれぞれ選言命題なので、<code>u_def</code> と <code>v_def</code> の組は計4つのケースを表している。これらのケースのうち1つでは <code>u = True</code> かつ <code>v = False</code> であり、他の全てのケースでは <code>p</code> が真である。したがって、次のようになる:</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span><span class="boring">open Classical
</span><span class="boring">theorem em (p : Prop) : p ∨ ¬p :=
</span><span class="boring">  let U (x : Prop) : Prop := x = True ∨ p
</span><span class="boring">  let V (x : Prop) : Prop := x = False ∨ p
</span><span class="boring">  have exU : ∃ x, U x := ⟨True, Or.inl rfl⟩
</span><span class="boring">  have exV : ∃ x, V x := ⟨False, Or.inl rfl⟩
</span><span class="boring">  let u : Prop := choose exU
</span><span class="boring">  let v : Prop := choose exV
</span><span class="boring">  have u_def : U u := choose_spec exU
</span><span class="boring">  have v_def : V v := choose_spec exV
</span>  have not_uv_or_p : u ≠ v ∨ p :=
    match u_def, v_def with
    | Or.inr h, _ =&gt; Or.inr h
    | _, Or.inr h =&gt; Or.inr h
    | Or.inl hut, Or.inl hvf =&gt;
      have hne : u ≠ v := by simp [hvf, hut, true_ne_false]
      Or.inl hne
<span class="boring">  sorry
</span><span class="boring">end Hidden
</span></code></pre>
<p>一方、<code>p</code> が真であれば、関数外延性と命題外延性によって <code>U</code> と <code>V</code> は等しい。<code>u</code> と <code>v</code> の定義により、<code>u</code> と <code>v</code> も等しいことがわかる。 </p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span><span class="boring">open Classical
</span><span class="boring">theorem em (p : Prop) : p ∨ ¬p :=
</span><span class="boring">  let U (x : Prop) : Prop := x = True ∨ p
</span><span class="boring">  let V (x : Prop) : Prop := x = False ∨ p
</span><span class="boring">  have exU : ∃ x, U x := ⟨True, Or.inl rfl⟩
</span><span class="boring">  have exV : ∃ x, V x := ⟨False, Or.inl rfl⟩
</span><span class="boring">  let u : Prop := choose exU
</span><span class="boring">  let v : Prop := choose exV
</span><span class="boring">  have u_def : U u := choose_spec exU
</span><span class="boring">  have v_def : V v := choose_spec exV
</span><span class="boring">  have not_uv_or_p : u ≠ v ∨ p :=
</span><span class="boring">    match u_def, v_def with
</span><span class="boring">    | Or.inr h, _ =&gt; Or.inr h
</span><span class="boring">    | _, Or.inr h =&gt; Or.inr h
</span><span class="boring">    | Or.inl hut, Or.inl hvf =&gt;
</span><span class="boring">      have hne : u ≠ v := by simp [hvf, hut, true_ne_false]
</span><span class="boring">      Or.inl hne
</span>  have p_implies_uv : p → u = v :=
    fun hp =&gt;
    have hpred : U = V :=
      funext fun x =&gt;
        have hl : (x = True ∨ p) → (x = False ∨ p) :=
          fun _ =&gt; Or.inr hp
        have hr : (x = False ∨ p) → (x = True ∨ p) :=
          fun _ =&gt; Or.inr hp
        show (x = True ∨ p) = (x = False ∨ p) from
          propext (Iff.intro hl hr)
    have h₀ : ∀ exU exV, @choose _ U exU = @choose _ V exV := by
      rw [hpred]; intros; rfl
    show u = v from h₀ _ _
<span class="boring">  sorry
</span><span class="boring">end Hidden
</span></code></pre>
<p><code>not_uv_or_p</code> と <code>p_implies_uv</code> をまとめると、所望の結論が得られる:</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span><span class="boring">open Classical
</span><span class="boring">theorem em (p : Prop) : p ∨ ¬p :=
</span><span class="boring">  let U (x : Prop) : Prop := x = True ∨ p
</span><span class="boring">  let V (x : Prop) : Prop := x = False ∨ p
</span><span class="boring">  have exU : ∃ x, U x := ⟨True, Or.inl rfl⟩
</span><span class="boring">  have exV : ∃ x, V x := ⟨False, Or.inl rfl⟩
</span><span class="boring">  let u : Prop := choose exU
</span><span class="boring">  let v : Prop := choose exV
</span><span class="boring">  have u_def : U u := choose_spec exU
</span><span class="boring">  have v_def : V v := choose_spec exV
</span><span class="boring">  have not_uv_or_p : u ≠ v ∨ p :=
</span><span class="boring">    match u_def, v_def with
</span><span class="boring">    | Or.inr h, _ =&gt; Or.inr h
</span><span class="boring">    | _, Or.inr h =&gt; Or.inr h
</span><span class="boring">    | Or.inl hut, Or.inl hvf =&gt;
</span><span class="boring">      have hne : u ≠ v := by simp [hvf, hut, true_ne_false]
</span><span class="boring">      Or.inl hne
</span><span class="boring">  have p_implies_uv : p → u = v :=
</span><span class="boring">    fun hp =&gt;
</span><span class="boring">    have hpred : U = V :=
</span><span class="boring">      funext fun x =&gt;
</span><span class="boring">        have hl : (x = True ∨ p) → (x = False ∨ p) :=
</span><span class="boring">          fun _ =&gt; Or.inr hp
</span><span class="boring">        have hr : (x = False ∨ p) → (x = True ∨ p) :=
</span><span class="boring">          fun _ =&gt; Or.inr hp
</span><span class="boring">        show (x = True ∨ p) = (x = False ∨ p) from
</span><span class="boring">          propext (Iff.intro hl hr)
</span><span class="boring">    have h₀ : ∀ exU exV, @choose _ U exU = @choose _ V exV := by
</span><span class="boring">      rw [hpred]; intros; rfl
</span><span class="boring">    show u = v from h₀ _ _
</span>  match not_uv_or_p with
  | Or.inl hne =&gt; Or.inr (mt p_implies_uv hne)
  | Or.inr h   =&gt; Or.inl h
<span class="boring">end Hidden
</span></code></pre>
<p>排中律の系としては、二重否定除去、場合分けによる証明、矛盾による証明などがあり、これらは全て節<a href="./propositions_and_proofs.html#classical-logic-%E5%8F%A4%E5%85%B8%E8%AB%96%E7%90%86">Classical Logic (古典論理)</a>で説明されている。排中律と命題外延性は命題完全性を含意する:</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>open Classical
theorem propComplete (a : Prop) : a = True ∨ a = False :=
  match em a with
  | Or.inl ha =&gt; Or.inl (propext (Iff.intro (fun _ =&gt; ⟨⟩) (fun _ =&gt; ha)))
  | Or.inr hn =&gt; Or.inr (propext (Iff.intro (fun h =&gt; hn h) (fun h =&gt; False.elim h)))
<span class="boring">end Hidden
</span></code></pre>
<p>選択原理と合わせると、「全ての命題は決定可能である」というより強い原理も得られる。決定可能命題のクラス <code>Decidable</code> は次のように定義されることを思い出してほしい:</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>class inductive Decidable (p : Prop) where
  | isFalse (h : ¬p) : Decidable p
  | isTrue  (h : p)  : Decidable p
<span class="boring">end Hidden
</span></code></pre>
<p>除去により <code>Prop</code> 型の項しか作れない <code>p ∨ ¬ p</code> とは対照的に、型 <code>Decidable p</code> は直和型 <code>Sum p (¬ p)</code> と等価であり、除去により任意の型の項を作ることができる。型 <code>Decidable p</code> のデータはif-then-else式を書くのに必要である。</p>
<p>古典的推論の例と同様に、「<code>f : α → β</code> が単射で <code>α</code> が有項なら、<code>f</code> は左逆写像を持つ」という定理を証明するためにも <code>choose</code> を使う。左逆写像 <code>linv</code> を定義するために、依存if-then-else式を用いる。<code>if h : c then t else e</code> は <code>dite c (fun h : c =&gt; t) (fun h : ¬ c =&gt; e)</code> の略記であることを思い出してほしい。<code>linv</code> の定義の中で、選択原理は2回使われている: 選択原理は、まず <code>(∃ a : A, f a = b)</code> が「決定可能」であることを示すために、そして <code>f a = b</code> を満たす <code>a</code> を選ぶために使われている。<code>propDecidable</code> はスコープ付きインスタンスであり、<code>open Classical</code> コマンドによって利用可能になることに注意してほしい。このインスタンスにより、このif-then-else式の使用が正当化される(節<a href="./type_classes.html#decidable-propositions-%E6%B1%BA%E5%AE%9A%E5%8F%AF%E8%83%BD%E5%91%BD%E9%A1%8C">Decidable Propositions (決定可能命題)</a>の説明も参照のこと)。</p>
<pre><code class="language-lean">open Classical

noncomputable def linv [Inhabited α] (f : α → β) : β → α :=
  fun b : β =&gt; if ex : (∃ a : α, f a = b) then choose ex else default

theorem linv_comp_self {f : α → β} [Inhabited α]
                       (inj : ∀ {a b}, f a = f b → a = b)
                       : linv f ∘ f = id :=
  funext fun a =&gt;
    have ex  : ∃ a₁ : α, f a₁ = f a := ⟨a, rfl⟩
    have feq : f (choose ex) = f a  := choose_spec ex
    calc linv f (f a)
      _ = choose ex := dif_pos ex
      _ = a         := inj feq
</code></pre>
<p>古典的な観点からすると、<code>linv</code> は関数である。構成的な観点からすると、<code>linv</code> の定義は受け入れがたい: 一般にこのような関数を実装する方法はないため、この構築は何の情報も持たない。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="assets/fzf.umd.js"></script>
        <script type="text/javascript" src="assets/elasticlunr.js"></script>

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
